<!DOCTYPE html>
<html lang="de">
<head>
  <meta name="app:build-iso" content="2025-09-02T00:07:13+02:00">
  <meta name="app:build" content="2025-09-02 00:07">
  <meta name="app:version" content="Frequency 1.34.58">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-Frequency ‚Äì Dein Frequenz-Assistent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #334155; /* Darker text */
            transition: background-color 0.5s ease-in-out; /* Smooth transition for background changes */
        }
        body.highlight-background {
            background-color: #ffe6e6; /* Light red for highlighting */
        }
        .container {
            max-width: 90%;
            margin: 0 auto;
            padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 1.5rem; /* More rounded */
            background-color: #ffffff;
            border: 1px solid #e2e8f0; /* Light border */
        }
        /* General styling for range inputs, adjusted to be more flexible */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%; /* Make them fill container width */
            height: 10px;
            background: #cbd5e1; /* Light gray track */
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: #3b82f6; /* Blue thumb */
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #60a5fa; /* Lighter blue border */
        }

        input[type="range"]::-moz-range-thumb {
            width: 25px;
            height: 25px;
            background: #3b82f6; /* Blue thumb */
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #60a5fa; /* Lighter blue border */
        }

        button {
            transition: background-color 0.2s, transform 0.1s;
        }
        button:hover {
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
        }
        canvas {
            background-color: #e2e8f0; /* Light background for canvas */
            border-radius: 0.75rem;
        }
        .loading-overlay { /* message-box-overlay removed */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            border-radius: 1.5rem;
            z-index: 10;
            text-align: center;
        }
        /* .message-box removed */
        #debugLog {
            background-color: #1f2937; /* Dark gray for log background */
            color: #d1d5db; /* Light gray text */
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            padding: 0.75rem;
            border-radius: 0.5rem;
            height: 200px;
            overflow-y: scroll;
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
            margin-bottom: 16px; /* Explicit 4mm / 16px margin */
        }
        .subtitle { /* This class is now unused with the new banner approach */
            text-align: right;
            color: #ef4444; /* Red color */
            font-size: 0.85rem;
            margin-top: -1.5rem; /* Pull it up a bit */
            margin-bottom: 1rem;
            font-weight: 600;
        }
        /* Styles for Record/Play buttons within Debug-Bereich */
        .debug-controls-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #475569; /* Darker border for debug section separator */
            width: 100%;
            align-items: center;
        }
        .debug-controls-section button {
            width: 100%; /* Make buttons full width in this section */
            font-size: 1.1rem; /* Slightly larger font */
            padding: 0.9rem 1.8rem; /* More padding */
            border-radius: 1rem; /* More rounded */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px; /* More space between icon and text */
            font-weight: 600; /* Bolder text */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); /* Subtle shadow */
        }
        .debug-controls-section button.recording {
            background-color: #dc2626; /* Red for recording */
            animation: pulse-red 1.5s infinite;
        }
        .debug-controls-section button.playing {
            background-color: #0ea5e9; /* Light blue for playing */
            animation: pulse-blue 1.5s infinite;
        }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
        }
        @keyframes pulse-blue {
            0% { box-shadow: 0 0 0 0 rgba(14, 165, 233, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(14, 165, 233, 0); }
            100% { box-shadow: 0 0 0 0 rgba(14, 165, 233, 0); }
        }
        .countdown {
            margin-left: 8px;
            font-weight: bold;
            color: #ffffff; /* Ensure countdown text is visible on colored buttons */
        }

        /* Specific styles for mic-gain-slider-row to match X-Gain 1.0 look */
        .mic-gain-slider-group {
            display: flex;
            flex-direction: column; /* Stack label/value and slider vertically */
            align-items: flex-start; /* Left-align content within this group */
            gap: 5px; /* Small gap between label group and slider */
            margin-bottom: 1rem;
            width: 100%; /* Take full width of parent to control content */
        }

        .mic-gain-label-row { /* New row for label and value */
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Left-align label and value */
            gap: 10px;
            width: 100%; /* Take full width of its parent */
        }
        .mic-gain-label-row label {
            font-size: 1.125rem; /* text-lg */
            font-weight: 500; /* font-medium */
            color: #6d28d9; /* Adjusted from text-purple-700 to match label color for clarity */
        }
        .mic-gain-label-row #micGainValue {
            font-size: 1.5rem; /* text-2xl */
            font-weight: bold; /* font-bold */
            color: #8b5cf6; /* text-purple-600 */
            width: 4rem; /* w-16 or w-24, using a fixed width for compact look */
            text-align: left; /* Aligned to left for compact look as in X-Gain */
        }
        .mic-gain-slider-group input[type="range"]#micGainRange {
            width: 100%; /* Make slider take full width of its parent group */
            /* Removed mx-4 and other horizontal margins, let parent handle spacing */
        }

        /* Adjust overall container for slider section to be narrower for this specific slider */
        /* Removed max-width and auto margins to allow content to align left */
        .mic-gain-slider-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Left-align the entire section's content */
            width: 100%;
        }


        /* Microphone Gain Visualizer Styles */
        .mic-gain-visualizer {
            width: 90%; /* Adjust width to fit within the container */
            height: 25px; /* Slightly taller */
            background-color: #cfd8dc; /* Slightly darker grey for contrast */
            border-radius: 12px; /* More rounded */
            margin: 1rem auto; /* Center it and add some vertical spacing */
            overflow: hidden; /* Ensure the bar stays within bounds */
            display: flex; /* Use flexbox to align the bar inside */
            align-items: center;
            border: 1px solid #b0bec5; /* Subtle border */
        }

        .mic-gain-bar {
            height: 100%;
            width: 0%; /* Initial width */
            background: linear-gradient(to right, #a78bfa, #8b5cf6); /* Purple gradient */
            border-radius: 12px; /* Match container */
            transition: width 0.1s ease-out; /* Slightly slower transition for smoother feel */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Subtle shadow for depth */
        }

        /* Styles for Ist-Wert/Zielwert boxes */
        .value-display-box {
            background-color: #1f2937; /* Dark background matching debug log */
            color: #d1d5db; /* Light text matching debug log */
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem; /* Slightly larger for readability */
            padding: 0.6rem 0.75rem; /* Adjusted padding */
            border-radius: 0.5rem;
            display: flex; /* Use flexbox for label and value alignment */
            justify-content: space-between; /* Space out label and value */
            align-items: center;
            width: 100%; /* Take full width within its flex-item */
            box-sizing: border-box; /* Include padding in width */
        }
        .value-display-box span.label {
            font-weight: bold;
            margin-right: 0.5rem;
            color: #9ca3af; /* Slightly lighter gray for label */
        }
        .value-display-box span.value {
            color: #a78bfa; /* Purple color for the value */
            font-size: 1.1rem; /* Prominent value */
        }

        /* New class for the value boxes container to ensure 4mm gap */
        .value-boxes-container {
            margin-top: 16px; /* 4mm vertical gap from debug log */
            display: flex;
            flex-direction: column; /* Default to column on small screens */
            gap: 16px; /* 4mm gap between boxes */
        }

        @media (min-width: 640px) { /* Tailwind's 'sm' breakpoint */
            .value-boxes-container {
                flex-direction: row; /* Row on larger screens */
            }
        }

        /* Custom styles for lists to ensure proper bullet point indentation */
        .list-outside-indent {
            list-style-position: outside;
            padding-left: 1.5rem; /* Adjust this value as needed for desired indentation */
        }

        /* Styles for collapsible section */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none; /* Prevent text selection on double click */
        }

        .toggle-icon {
            font-size: 1.5rem; /* Make icon a bit larger */
            line-height: 1; /* Adjust line height to prevent extra space */
            margin-left: 0.5rem; /* Space between title and icon */
        }
        /* Specific styling for emphasized text within FAQ */
        .faq-emphasis {
            font-weight: bold;
            color: #9c9c72; /* The new, calmer olive green */
        }

        /* Styles for the new banner */
        .banner {
            background-image: url('https://clipart.designo.ch/banner/imgbannerxfrequency.jpg');
            background-size: cover;
            background-position: center;
            height: 150px; /* Fixed height to ensure image visibility */
            color: #E2E8F0; /* Light text for contrast over dark image */
            padding: 1rem;
            border-radius: 1rem;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative; /* Needed for absolute positioning of text if desired */
            overflow: hidden; /* Ensure image doesn't spill */
        }
        .banner-title {
            font-size: 2.5rem; /* text-4xl */
            font-weight: 800; /* Extra bold */
            color: #ffffff; /* White for better contrast on image */
            line-height: 1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Text shadow for readability */
            z-index: 1; /* Ensure text is above background */
        }
        .banner-slogan {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* Semi-bold */
            color: #e0e0e0; /* Slightly off-white for slogan */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7); /* Text shadow for readability */
            z-index: 1; /* Ensure text is above background */
            margin-top: 0.5rem; /* Small gap between title and slogan */
        }

        /* Style for the delete icon */
        .delete-icon {
            cursor: pointer;
            color: #ef4444; /* Red color */
            margin-left: 0.5rem;
            font-weight: bold;
            font-size: 1rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.5rem; /* Make it a square */
            height: 1.5rem;
            border-radius: 0.25rem; /* Slightly rounded corners */
            transition: background-color 0.2s ease;
        }

        .delete-icon:hover {
            background-color: #fca5a5; /* Lighter red on hover */
            color: #b91c1c; /* Darker red for icon on hover */
        }

        /* Style for file input label */
        .file-input-label {
            background-color: #f97316; /* Orange-600 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            font-size: 1.125rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s, transform 0.1s;
        }
        .file-input-label:hover {
            background-color: #ea580c; /* Orange-700 */
            transform: translateY(-1px);
        }
        .file-input-label.disabled {
            background-color: #a3a3a3; /* Gray for disabled */
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
        }

        /* Flex container for language dropdown and display for responsive wrap */
        .language-display-container {
            display: flex;
            flex-wrap: wrap; /* Allows items to wrap to the next line */
            align-items: center;
            gap: 0.5rem; /* Small gap between elements */
        }

        /* Ensure "Voreingestellt:" and the language text can break */
        .browser-language-wrapper {
            display: flex; /* Use flex to align "Voreingestellt:" and its value */
            flex-wrap: wrap; /* Allow wrapping within this wrapper if needed */
            gap: 0.25rem; /* Smaller gap for the inline elements */
        }
        
        .browser-language-wrapper span {
            white-space: normal; /* Allow text to wrap naturally */
        }
        .browser-language-wrapper .text-gray-800 {
            white-space: nowrap; /* Keep the actual language value on one line */
        }

        @media (max-width: 640px) { /* Adjust for smaller screens like mobile */
            .language-display-container {
                flex-direction: column; /* Stack dropdown and display vertically */
                align-items: flex-start; /* Align stacked items to the left */
            }
            .browser-language-wrapper {
                margin-top: 0.5rem; /* Add some space above the wrapped language text */
            }
        }
    </style>
    <!-- Open Graph Protocol Meta Tags for Social Media Sharing -->
    <meta property="og:title" content="X-Frequency ‚Äì Dein Frequenz-Assistent">
    <meta property="og:description" content="Ein innovatives Tool zur Erforschung und Anwendung von Audiofrequenzen f√ºr Wohlbefinden und technische Analyse. Automatische Frequenzerkennung und Wiedergabe.">
    <meta property="og:image" content="https://clipart.designo.ch/banner/imgpromoxfrequency.jpg">
    <meta property="og:url" content="https://x-event.designo.ch/frequency">
    <meta property="og:type" content="website">
    <meta property="og:locale" content="de_CH">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-3ZK9H57DJ2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('config', 'G-3ZK9H57DJ2');
    </script>

    <style>
    /* faq-polish-13427 */
    #faqContent .list-outside-indent { list-style-position: outside; padding-left: 1.15rem; }
    #faqContent p { margin: .35rem 0 .25rem 0; }
    #faqContent ul.list-disc li { margin: .25rem 0; }
    </style>
    

    <style>
    /* xf-loader-13430 */
    #appLoader{position:fixed;inset:0;background:radial-gradient(1200px 800px at 50% -20%,rgba(80,80,120,.18),transparent),linear-gradient(#0e0f12,#111318);display:flex;align-items:center;justify-content:center;z-index:9999;transition:opacity .35s ease}
    #appLoader[hidden]{opacity:0;pointer-events:none}
    #appLoader .card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);backdrop-filter:blur(6px);padding:18px 20px;border-radius:14px;min-width:260px;box-shadow:0 6px 26px rgba(0,0,0,.35);color:#e9eef5;text-align:center}
    #appLoader .title{font-weight:600;letter-spacing:.2px;margin-bottom:10px}
    #appLoader .bar{height:6px;background:rgba(255,255,255,.15);border-radius:999px;overflow:hidden;margin-top:8px}
    #appLoader .bar span{display:block;height:100%;width:10%;background:linear-gradient(90deg,#7aa2ff,#61d2ff);border-radius:999px;transition:width .25s ease}
    #appLoader .msg{font-size:.95rem;opacity:.9;margin-top:10px}
    @media (prefers-reduced-motion: reduce){#appLoader{transition:none}#appLoader .bar span{transition:none}}
    </style>
    

<style id="diag-mini-13439">
#xf-mini-diag{pointer-events:auto; position:fixed; right:14px; bottom:58px; background:rgba(12,18,38,.92); border:1px solid rgba(255,255,255,.1);
  padding:10px 12px; border-radius:10px; font-size:13px; line-height:1.35; color:#dfe9f7; box-shadow:0 8px 30px rgba(0,0,0,.35); width: min(340px, 92vw); display:none; z-index:9999}
#xf-mini-diag h4{margin:0 0 6px 0; font-size:13px; color:#bcd7ff}
#xf-mini-diag .row{display:flex; justify-content:space-between; gap:8px; margin:3px 0}
#xf-mini-diag .key{opacity:.75}
#xf-mini-diag .val{font-weight:600}
#xf-mini-diag .log{max-height:160px; overflow:auto; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.08); padding:6px; border-radius:8px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px}
#xf-mini-toggle{position:fixed; right:14px; bottom:14px; z-index:2147483000; pointer-events:auto}
#xf-mini-toggle button{pointer-events:auto; background:#0d1b36; border:1px solid #27426b; color:#cfe6ff; border-radius:999px; padding:8px 12px; cursor:pointer}
#xf-mini-toggle button:hover{background:#112244}
.clipping-dot{display:inline-block; width:8px; height:8px; border-radius:50%; background:#ef5350; margin-left:6px; vertical-align:middle; opacity:0; transition:opacity .15s ease}
[title]{pointer-events:auto}
</style>

</head>
<body class="min-h-screen flex items-center justify-center p-4">
  <div id="appLoader" role="status" aria-live="polite">
    <div class="card" role="group" aria-label="App wird geladen">
      <div class="title">X‚ÄëFrequency l√§dt‚Ä¶</div>
      <div class="bar"><span id="loaderBar" style="width:12%"></span></div>
      <div class="msg" id="loaderText">Module laden‚Ä¶</div>
    </div>
  </div>

    <div class="container relative w-full lg:w-2/3 xl:w-1/2">
        <!-- NEW: Banner with image, title, and slogan -->
        <div class="banner" role="banner" aria-label="X-Frequency App Banner mit Hintergrundbild">
            <h1 class="banner-title">X-Frequency üé∂</h1>
            <p class="banner-slogan">Dein Frequenz-Assistent</p>
        </div>

        <!-- Loading Overlay -->
        <div id="loadingOverlay" class="loading-overlay hidden" role="status" aria-live="polite">
            <p class="text-blue-600 font-semibold">Lade Audio-Kontext und Mikrofon... Bitte warten.</p>
        </div>

        <div class="mb-6 bg-blue-50 p-4 rounded-xl border border-blue-200">
            <h2 class="text-xl font-semibold mb-3 text-blue-700">üîä Frequenz-Generator</h2>
            <div class="flex flex-col sm:flex-row items-center justify-between mb-4">
                <label for="manualFrequencyInput" class="text-lg font-medium whitespace-nowrap mr-2">Manuelle Frequenz:</label>
                <input type="number" id="manualFrequencyInput" min="20" max="20000" step="0.01" value="440.00"
                    class="text-2xl font-bold text-blue-600 w-32 text-right p-1 border border-blue-300 rounded-md bg-blue-50"
                    aria-label="Manuelle Frequenzeingabe in Hertz" title="Geben Sie eine Frequenz zwischen 20 Hz und 20000 Hz ein.">
                <input type="range" id="frequencyRange" min="20" max="20000" value="440" class="flex-grow mx-4"
                    aria-label="Frequenz-Schieberegler" title="Frequenz manuell einstellen"
                    aria-valuemin="20" aria-valuemax="20000" aria-valuenow="440">
                <span class="text-lg font-medium text-blue-700"> Hz</span>
            </div>
            <div class="grid grid-cols-1 gap-4">
                <button id="playStopBtn" class="bg-blue-600 text-white py-3 px-6 rounded-xl font-semibold text-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
                    aria-label="Frequenz abspielen oder stoppen" title="Startet oder stoppt die manuelle Frequenzwiedergabe">
                    Manuell abspielen
                </button>
            </div>
        </div>

        <div class="mb-6 bg-purple-50 p-4 rounded-xl border border-purple-200">
            <h2 class="text-xl font-semibold mb-3 text-purple-700">üé§ Frequenz-Analyse (Mikrofon)</h2>
            <div class="flex flex-col sm:flex-row items-center justify-between mb-4">
                <label for="sensitivityRange" class="text-lg font-medium whitespace-nowrap mr-2">Erkennungs-Empfindlichkeit:</label>
                <span id="sensitivityValue" class="text-2xl font-bold text-purple-600 w-24 text-right"
                    aria-live="polite" aria-label="Aktueller Wert der Erkennungs-Empfindlichkeit in Dezibel">
                    -55
                </span>
                <input type="range" id="sensitivityRange" min="-90" max="-20" value="-55" class="flex-grow mx-4"
                    aria-label="Schieberegler f√ºr Erkennungs-Empfindlichkeit" title="Stellt die Empfindlichkeit der Frequenzerkennung ein (in dB)"
                    aria-valuemin="-90" aria-valuemax="-20" aria-valuenow="-55">
                <span class="text-lg font-medium text-purple-700"> dB</span>
            </div>
            <canvas id="frequencyCanvas" class="w-full h-64 border border-purple-300"
                aria-label="Frequenzspektrum-Visualisierung" role="img" title="Zeigt das aktuelle Audiofrequenzspektrum an."></canvas>
            <div id="messageWrapper" class="min-h-[80px] text-center mt-4 mb-2 flex flex-col justify-center items-center" aria-live="polite">
                <p id="overlapMessage" class="text-red-600 font-bold text-lg hidden" aria-atomic="true">Frequenz√ºberschneidung erkannt! üö®</p>
                <p id="currentPlayingPreset" class="text-green-700 font-semibold text-base hidden" aria-atomic="true">Spiele: <span id="currentPlayingPresetName"></span> (<span id="currentPlayingPresetFreq"></span> Hz)</p>
            </div>
            <p id="micPermissionWarning" class="mt-4 text-center text-orange-600 text-sm hidden" role="alert" aria-atomic="true">
                ‚ö†Ô∏è Mikrofonzugriff verweigert. Bitte erlauben Sie den Zugriff in Ihren Browsereinstellungen.
            </p>
        </div>

        <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-xl font-semibold text-gray-700">‚ú® Frequenz-Assistenten & Kategorien</h2>
                <div class="flex items-center gap-2">
                    <span class="text-lg text-gray-700" aria-hidden="true">‚áÖ</span>
                    <select id="sortDropdown" class="rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-1 px-2 text-sm"
                        aria-label="Sortieroptionen f√ºr Frequenzen" title="W√§hlen Sie die Sortierreihenfolge f√ºr die Frequenzlisten.">
                        <option value="thematic">Thematisch</option>
                        <option value="alphabetical">Alphabetisch (A-Z)</option>
                        <option value="frequency_asc">Frequenz (Aufsteigend)</option>
                        <option value="frequency_desc">Frequenz (Absteigend)</option>
                    </select>
                </div>
            </div>

            <div class="mb-6 bg-yellow-50 p-4 rounded-xl border border-yellow-200">
                <h2 class="text-xl font-semibold mb-3 text-yellow-700">Automatischer Frequenz-Assistent</h2>
                <p class="text-sm text-gray-600 mb-4">W√§hlen Sie Frequenzen, die die App √ºberwachen und automatisch f√ºr <span id="dynamicAutomationDescriptionDuration" aria-live="polite" aria-label="Eingestellte minimale Wiedergabedauer f√ºr die Automatisierung">10</span> Sekunden abspielen soll, wenn eine √úberschneidung erkannt wird, oder so lange, bis eine neue √úberschneidung festgestellt wird.</p>
                <div id="presetFrequenciesContainer" class="flex flex-col gap-3 mb-4" role="group" aria-label="Vordefinierte Standardfrequenzen">
                    <!-- Preset checkboxes will be dynamically inserted here -->
                </div>
            </div>

            <div class="mb-6 bg-indigo-50 p-4 rounded-xl border border-indigo-200">
                <h2 class="text-xl font-semibold mb-3 text-indigo-700">Mystische Frequenzen f√ºr Muster in der Natur</h2>
                <p class="text-sm text-gray-600 mb-4">Diese Frequenzen sind mit Konzepten von Wasserstruktur, Zell-Harmonie und geometrischen Mustern in der Natur verbunden.</p>
                <div id="mysticalFrequenciesContainer" class="flex flex-col gap-3 mb-4" role="group" aria-label="Mystische Frequenzen">
                    <!-- Mystical preset checkboxes will be dynamically inserted here -->
                </div>
            </div>
            
            <div class="mb-6 bg-orange-50 p-4 rounded-xl border border-orange-200">
                <h3 class="text-xl font-semibold mb-3 text-orange-700">Weitere Harmonie-Frequenzen</h3>
                <p class="text-sm text-gray-600 mb-4">Zus√§tzliche Frequenzen zur Harmonisierung und zur F√∂rderung des Wohlbefindens.</p>
                <div class="flex items-center gap-2 mb-3">
                    <input type="checkbox" id="enableHarmonyFreq" class="form-checkbox h-4 w-4 text-orange-600 rounded"
                        aria-label="Harmonie-Frequenz ausw√§hlen aktivieren/deaktivieren" title="Aktivieren Sie diese Option, um eine Harmonie-Frequenz auszuw√§hlen.">
                    <label for="enableHarmonyFreq" class="text-gray-700 text-sm">Harmonie-Frequenz ausw√§hlen</label>
                </div>
                <select id="harmonyFrequencyDropdown" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-orange-300 focus:ring focus:ring-orange-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-2 px-3" disabled
                    aria-label="Dropdown f√ºr Harmonie-Frequenzen" title="W√§hlen Sie eine Harmonie-Frequenz aus.">
                    <option value="">Bitte w√§hlen Sie eine Frequenz</option>
                    <!-- Options dynamically loaded by JS -->
                </select>
            </div>

            <div class="mb-6 bg-emerald-50 p-4 rounded-xl border border-emerald-200">
                <h3 class="text-xl font-semibold mb-3 text-emerald-700">Frequenzen f√ºr Umweltanalyse</h3>
                <p class="text-sm text-gray-600 mb-4">Frequenzen, die mit Umweltph√§nomenen und nat√ºrlichen Mustern in Verbindung stehen.</p>
                <div class="flex items-center gap-2 mb-3">
                    <input type="checkbox" id="enableEnvironmentFreq" class="form-checkbox h-4 w-4 text-emerald-600 rounded"
                        aria-label="Umwelt-Frequenz ausw√§hlen aktivieren/deaktivieren" title="Aktivieren Sie diese Option, um eine Umwelt-Frequenz auszuw√§hlen.">
                    <label for="enableEnvironmentFreq" class="text-gray-700 text-sm">Umwelt-Frequenz ausw√§hlen</label>
                </div>
                <select id="environmentFrequencyDropdown" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-emerald-300 focus:ring focus:ring-emerald-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-2 px-3" disabled
                    aria-label="Dropdown f√ºr Umwelt-Frequenzen" title="W√§hlen Sie eine Umwelt-Frequenz aus.">
                    <option value="">Bitte w√§hlen Sie eine Frequenz</option>
                    <!-- Options dynamically loaded by JS -->
                </select>
            </div>

            <!-- NEU: Benutzerdefinierte Frequenzen -->
            <div class="mb-6 bg-rose-50 p-4 rounded-xl border border-rose-200">
                <h3 class="text-xl font-semibold mb-3 text-rose-700">Benutzerdefinierte Frequenzen</h3>
                <p class="text-sm text-gray-600 mb-4">Hier k√∂nnen Sie eigene Frequenzen hinzuf√ºgen, verwalten und speichern.</p>
                
                <!-- Checkboxen oben -->
                <div id="customFrequenciesContainer" class="flex flex-col gap-3 mb-4" role="group" aria-label="Benutzerdefinierte Frequenzen Liste">
                    <!-- Custom preset checkboxes will be dynamically inserted here -->
                </div>

                <!-- Eingabefelder unten -->
                <div class="flex flex-col sm:flex-row gap-4 mb-4 items-center">
                    <input type="text" id="customFreqNameInput" placeholder="Name der Frequenz"
                        class="flex-1 p-2 border border-rose-300 rounded-md bg-rose-50 text-rose-800 placeholder-rose-400"
                        aria-label="Name der benutzerdefinierten Frequenz" title="Geben Sie einen Namen f√ºr Ihre Frequenz ein.">
                    <input type="number" id="customFreqValueInput" min="0.1" max="20000" step="0.01" placeholder="Frequenz (Hz)"
                        class="flex-1 p-2 border border-rose-300 rounded-md bg-rose-50 text-rose-800 placeholder-rose-400"
                        aria-label="Wert der benutzerdefinierten Frequenz in Hertz" title="Geben Sie eine Frequenz zwischen 0.1 Hz und 20000 Hz ein.">
                    <button id="addCustomFreqBtn" class="bg-rose-600 text-white py-2 px-4 rounded-xl font-semibold text-base hover:bg-rose-700 focus:outline-none focus:ring-4 focus:ring-rose-300 w-full sm:w-auto"
                        aria-label="Benutzerdefinierte Frequenz hinzuf√ºgen" title="F√ºgt die eingegebene Frequenz zur Liste hinzu.">
                        Hinzuf√ºgen
                    </button>
                </div>
            </div>



            <div class="grid grid-cols-1 gap-4 mt-4">
                <button id="toggleAutomationBtn" class="bg-yellow-600 text-white py-3 px-6 rounded-xl font-semibold text-lg hover:bg-yellow-700 focus:outline-none focus:ring-4 focus:ring-yellow-300" disabled
                    aria-label="Automatisches Mith√∂ren starten oder stoppen" title="Startet oder stoppt die automatische Frequenzerkennung und -wiedergabe.">
                    Automatisches Mith√∂ren starten
                </button>
            </div>
        </div>

        <div class="mb-6 bg-blue-100 p-4 rounded-xl border border-blue-300">
            <h2 class="text-xl font-semibold mb-3 text-blue-800">üêõ Diagnose Panel</h2>



			
			
            <div class="flex items-center mb-4">
                <input type="checkbox" id="debugToggle" class="form-checkbox h-4 w-4 text-blue-600 rounded mr-2"
                    aria-label="Debug-Log aktivieren" title="Aktiviert oder deaktiviert das Debug-Log f√ºr Systeminformationen.">
                <label for="debugToggle" class="text-blue-800 font-medium mr-4">Debug-Log aktivieren</label>

                <input type="checkbox" id="freezeToggle" class="form-checkbox h-4 w-4 text-blue-600 rounded mr-2"
                    aria-label="Debug-Log einfrieren" title="Friert das Debug-Log ein, um die aktuelle Ansicht zu behalten.">
                <label for="freezeToggle" class="text-blue-800 font-medium">Log einfrieren</label>
            </div>
			
			
             <div id="speechFrequencyTestContainer" class="flex flex-col gap-3 mb-4" role="group" aria-label="Sprechfrequenz Test-Optionen">
                 <!-- Checkbox will be dynamically inserted here -->
             </div>			
			
			
            <div class="flex items-center mb-4 mt-2">
                <input type="checkbox" id="forceOutputToggle" class="form-checkbox h-4 w-4 text-red-600 rounded mr-2"
                    aria-label="Force Output Testmodus aktivieren" title="Aktiviert den Testmodus, um eine ausgew√§hlte Frequenz kontinuierlich auszugeben.">
                <label for="forceOutputToggle" class="text-red-800 font-medium">Force Output (Testmodus)</label>
            </div>
            <pre id="debugLog" class="hidden" role="log" aria-live="polite" aria-label="Debug-Log Ausgaben"></pre>

            <div class="value-boxes-container">
                <div id="currentFreqDisplay" class="value-display-box flex-1 hidden" aria-live="polite">
                    <span class="label">Ist-Wert:</span>
                    <span class="value" id="currentFreqValue" aria-label="Aktuelle gemessene Frequenz">N/A</span>
                </div>
                <div id="targetFreqDisplay" class="value-display-box flex-1 hidden" aria-live="polite">
                    <span class="label">Zielwert:</span>
                    <span class="value" id="targetFreqValue" aria-label="Ziel-Frequenz f√ºr die Automatisierung">N/A</span>
                </div>
            </div>

            <div class="debug-controls-section">
                <h3 class="text-lg font-semibold text-blue-800">Audio-Aufnahme & Wiedergabe</h3>
                <button id="micToggleBtn" class="bg-green-600 text-white py-3 px-6 rounded-xl font-semibold text-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300"
                    aria-label="Mikrofon starten oder stoppen" title="Aktiviert oder deaktiviert den Mikrofonzugriff f√ºr die Frequenzanalyse.">
                    Mikrofon starten
                </button>
                <p id="micStatus" class="mt-2 text-sm text-gray-600 text-center" aria-live="polite" aria-atomic="true">Mikrofon-Status: Inaktiv</p>

                <button id="recordBtn" disabled aria-label="Audio aufzeichnen" title="Zeichnet 5 Sekunden Audio vom Mikrofon auf.">
                    <span>‚è∫Ô∏è 5 Sek. Ton aufzeichnen</span>
                    <span id="recordCountdown" class="countdown" aria-live="polite"></span>
                </button>
                <button id="playBtn" disabled aria-label="Aufgenommenes Audio abspielen" title="Spielt die zuletzt aufgenommene Audiodatei ab.">
                    <span>‚ñ∂Ô∏è File abspielen</span>
                    <span id="playCountdown" class="countdown" aria-live="polite"></span>
                </button>
                <div class="flex items-center mt-2">
                    <input type="checkbox" id="forcePassthroughCheckbox" class="form-checkbox h-4 w-4 text-purple-600 rounded mr-2" disabled
                        aria-label="Force Passthrough (Aux-OUT) aktivieren" title="Gibt Live-Mikrofon-Audio direkt √ºber den Audio-Ausgang aus.">
                    <label for="forcePassthroughCheckbox" class="text-purple-800 font-medium">Force Passthrough (Aux-OUT)</label>
                </div>
                <p class="text-sm text-gray-600 mt-1">Hinweis: Live-Audio vom Mikrofon wird √ºber Aux-OUT ausgegeben. Es k√∂nnen Echos oder Drop-Outs auftreten.</p>
            </div>
        </div>

        <div class="mb-6 bg-gray-100 p-4 rounded-xl border border-gray-300">
            <h2 class="text-xl font-semibold mb-3 text-gray-700">‚öôÔ∏è Einstellungen</h2>

            <!-- NEU: Sub-DIV f√ºr Mikrofon-Gain -->
            <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Mikrofon-Gain</h3>
                <p class="text-sm text-gray-600 mb-4">Stellen Sie die Lautst√§rke des Mikrofoneingangs ein. Ein h√∂herer Gain-Wert erh√∂ht die Empfindlichkeit des Mikrofons.</p>
                <div class="mic-gain-slider-group">
                    <div class="mic-gain-label-row">
                        <label for="micGainRange">Gain-Wert:</label>
                        <span id="micGainValue" aria-live="polite" aria-label="Aktueller Mikrofon-Gain Wert">1.00</span>
                    </div>
                    <input type="range" id="micGainRange" min="0" max="100" step="0.01" value="1" disabled
                        aria-label="Mikrofon-Gain-Regler" title="Stellt die Lautst√§rke des Mikrofoneingangs ein."
                        aria-valuemin="0" aria-valuemax="100" aria-valuenow="1">
                </div>
                <div id="micGainVisualizer" class="mic-gain-visualizer hidden" role="progressbar" aria-label="Mikrofon-Gain-Pegelanzeige" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div class="mic-gain-bar"></div>
                </div>
            </div>

            <!-- NEU: Sub-DIV f√ºr Automatisierungsdauer -->
            <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Automatisierungsdauer</h3>
                <p class="text-sm text-gray-600 mb-4">Legen Sie die minimale Dauer fest, f√ºr die ein automatisch erkannter Ton abgespielt wird, bevor die App nach einer neuen √úberschneidung sucht.</p>
                <div class="flex items-center">
                    <label for="automationDurationInput" class="text-lg font-medium text-gray-700 whitespace-nowrap mr-2">Min. Wiedergabedauer:</label>
                    <input type="number" id="automationDurationInput" min="1" max="600" step="1" value="10"
                        class="text-2xl font-bold text-gray-600 w-24 text-right p-1 border border-gray-300 rounded-md bg-gray-50"
                        aria-label="Minimale Wiedergabedauer f√ºr Automatisierung in Sekunden" title="Legen Sie die minimale Dauer fest, f√ºr die ein automatisch erkannter Ton abgespielt wird."
                        aria-valuemin="1" aria-valuemax="600" aria-valuenow="10">
                    <span id="automationDurationValue" class="text-xl font-bold text-gray-600 w-16 text-left">&nbsp;Sek.</span>
                </div>
            </div>

            <!-- NEU: Sub-DIV f√ºr Frequenzen Import/Export -->
            <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Frequenzen Import/Export</h3>
                <p class="text-sm text-gray-600 mb-4">Verwalten Sie Ihre benutzerdefinierten Frequenzen, indem Sie diese als JSON-Dateien exportieren oder importieren.</p>
                <div class="flex flex-col sm:flex-row gap-4 justify-between">
                    <button id="exportCustomFrequenciesBtn" class="bg-indigo-600 text-white py-2 px-4 rounded-xl font-semibold text-base hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 w-full sm:w-auto"
                        aria-label="Benutzerdefinierte Frequenzen exportieren" title="Exportiert alle benutzerdefinierten Frequenzen als JSON-Datei.">
                        Exportieren Frequenzen
                    </button>
                    <label for="importCustomFrequenciesInput" class="file-input-label w-full sm:w-auto">
                        <span title="Importiere benutzerdefinierte Frequenzen">Importieren Frequenzen</span>
                        <input type="file" id="importCustomFrequenciesInput" accept=".json" class="hidden"
                            aria-label="Benutzerdefinierte Frequenzen importieren" title="Importiert benutzerdefinierte Frequenzen aus einer JSON-Datei.">
                    </label>
                </div>
            </div>
            
            <!-- NEU: Sub-DIV f√ºr Audio-Hardware -->
            <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Audio-Hardware</h3>
                <p class="text-sm text-gray-600 mb-4">Diese √úbersicht zeigt die von Ihrem System erkannten Audio-Ger√§te. Die tats√§chliche Auswahl der aktiven Ein- und Ausgabeger√§te (Mikrofon und Lautsprecher) erfolgt in den Audio-Einstellungen Ihres Betriebssystems oder Browsers. Bei √Ñnderungen der Hardware-Konfiguration ist ein Neuladen der Seite erforderlich.</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <div class="flex-1">
                        <label for="inputDropdown" class="block text-lg font-medium text-gray-700 mb-2">Aktives Eingabeger√§t:</label>
                        <select id="inputDropdown" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-2 px-3" disabled
                            aria-label="Anzeige des aktiven Audio-Eingabeger√§ts" title="Zeigt das aktuell im System/Browser ausgew√§hlte Audio-Eingabeger√§t an.">
                            <option>Lade Eingabeger√§te...</option>
                        </select>
                    </div>
                    <div class="flex-1">
                        <label for="outputDropdown" class="block text-lg font-medium text-gray-700 mb-2">Aktives Ausgabeger√§t:</label>
                        <select id="outputDropdown" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-2 px-3" disabled
                            aria-label="Anzeige des aktiven Audio-Ausgabeger√§ts" title="Zeigt das aktuell im System/Browser ausgew√§hlte Audio-Ausgabeger√§t an.">
                            <option>Lade Ausgabeger√§te...</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- NEU: Sub-DIV f√ºr Spracheinstellungen -->
            <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Spracheinstellungen</h3>
                <p class="text-sm text-gray-600 mb-4">W√§hlen Sie die Anzeigesprache der App, um die Benutzeroberfl√§che anzupassen.</p>
                <div class="flex items-center gap-2 language-display-container">
                    <label for="languageDropdown" class="block text-base font-medium text-gray-700">Language / Sprache / Idioma / ËØ≠Ë®Ä:</label>
                    <select id="languageDropdown" class="block rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-2 px-3"
                        aria-label="Sprache ausw√§hlen" title="W√§hlen Sie die Anzeigesprache der App.">
                        <option value="de">Deutsch</option>
                        <option value="en">English</option>
                        <option value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ© (Arabisch)</option>
                        <option value="zh">‰∏≠Êñá (Mandarin)</option>
                        <option value="fr">Fran√ßais (Franz√∂sisch)</option>
                        <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä (Hindi)</option>
                        <option value="ja">Êó•Êú¨Ë™û (Japanisch)</option>
                        <option value="pt-BR">Portugu√™s (Brasilien)</option>
                        <option value="ru">–†—É—Å—Å–∫–∏–π (Russisch)</option>
                        <option value="es">Espa√±ol (Spanisch)</option>
                    </select>
                    <div class="browser-language-wrapper text-base text-gray-800 whitespace-nowrap sm:ml-4"
                        aria-live="polite" aria-label="Voreingestellte Browsersprache">
                        <span>Voreingestellt:</span> <span id="browserLanguageDisplay">Deutsch</span>
                    </div>
                </div>
            </div>
        </div>


        <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
            <div id="importantFrequenciesHeader" class="collapsible-header" role="button" aria-expanded="false" aria-controls="importantFrequenciesContent"
                title="Klicken Sie, um wichtige Frequenzen (Beispiele) anzuzeigen oder auszublenden.">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">üí° Wichtige Frequenzen (Beispiele)</h2>
                <span id="importantFrequenciesArrow" class="toggle-icon" aria-hidden="true">‚¨áÔ∏è</span>
            </div>
            <div id="importantFrequenciesContent" class="hidden">
                <ul class="list-disc text-gray-600 text-sm space-y-2 list-outside-indent">
                    <li><span class="font-normal">Schumann-Resonanz (Erde - Grundwelle):</span> 7.83 Hz</li>
                    <li><span class="font-normal">Schumann-Resonanz (Erde - 2. Harmonie):</span> 14.1 Hz</li>
                    <li><span class="font-normal">Schumann-Resonanz (Erde - 3. Harmonie):</span> 20.3 Hz</li>
                    <li><span class="font-normal">Solfeggio Mi (DNA-Reparatur):</span> 528 Hz</li>
                    <li><span class="font-normal">Solfeggio Fa (Herzfrequenz Harmonisierung):</span> 639 Hz</li>
                    <li><span class="font-normal">Heilende Wasserfrequenz:</span> 432 Hz</li>
                    <li><span class="font-normal">Ganzk√∂rper-Entspannung (Delta-Wellen):</span> 4 Hz</li>
                </ul>
            </div>
        </div>

        <div class="mb-6 bg-green-50 p-4 rounded-xl border border-green-200">
            <div id="appUsageHeader" class="collapsible-header" role="button" aria-expanded="false" aria-controls="appUsageContent"
                title="Klicken Sie, um Anwendungsbeispiele der App anzuzeigen oder auszublenden.">
                <h2 class="text-xl font-semibold mb-3 text-green-700">‚úÖ Wof√ºr diese App verwendet werden kann</h2>
                <span id="appUsageArrow" class="toggle-icon" aria-hidden="true">‚¨áÔ∏è</span>
            </div>
            <div id="appUsageContent" class="hidden">
                <ul class="list-disc text-gray-600 text-sm space-y-2 list-outside-indent">
                    <li><span class="font-bold">Entspannung und Meditation:</span> Einsatz von beruhigenden Frequenzen zur F√∂rderung von Ruhe und innerer Balance.</li>
                    <li><span class="font-bold">Unterst√ºtzung bei Schlafst√∂rungen:</span> Nutzung spezifischer Frequenzen zur Verbesserung der Schlafqualit√§t durch gezielte Klanganwendungen.</li>
                    <li><span class="font-bold">Konzentration und Produktivit√§t:</span> Schaffung einer optimalen akustischen Umgebung, die Fokus und Lernf√§higkeit unterst√ºtzt.</li>
                    <li><span class="font-bold">Naturbeobachtung und Umweltanalyse:</span> Identifizierung und Analyse von Tierstimmen oder spezifischen Umweltfrequenzen.</li>
                    <li><span class="font-bold">Klangtherapie und Wohlbefinden:</span> Erg√§nzende Anwendung zur F√∂rderung des k√∂rperlichen und geistigen Wohlbefindens (kein Ersatz f√ºr medizinische Behandlung).</li>
                    <li><span class="font-bold">Lern- und Lehrmittel:</span> Praktische Demonstration von Frequenzen, Schallwellen und deren Auswirkungen in Bildungseinrichtungen.</li>
                    <li><span class="font-bold">Akustische Optimierung:</span> Analyse der Raumakustik und Hilfestellung bei der optimalen Platzierung von Lautsprechern.</li>
                    <li><span class="font-bold">Kreative Soundexploration:</span> Experimentieren mit Frequenzen zur Erzeugung einzigartiger Soundeffekte und Texturen f√ºr musikalische oder k√ºnstlerische Projekte.</li>
                    <li><span class="font-bold">Pers√∂nliche Energie-Harmonisierung:</span> Unterst√ºtzung des Energieflusses im K√∂rper durch gezielte Frequenzeinwirkung und Resonanz.</li>
                    <li><span class="font-bold">Frequenzen und Wasser:</span> Wissenschaftliche Forschung und Experimente zur Beeinflussung von Wasserstrukturen durch spezifische Frequenzen.</li>
                    <li><span class="font-bold">Konzert & B√ºhnenprojektion:</span> Integration in Kunst- und B√ºhnenprojekte: Nutzung von Frequenzen zur Steuerung von Wasserspielen, Lichteffekten und holographischen Projektionen bei Konzerten oder Performances.</li>
                </ul>
            </div>
        </div>

        <div class="mb-6 bg-yellow-50 p-4 rounded-xl border border-yellow-200">
            <div id="faqHeader" class="collapsible-header" role="button" aria-expanded="false" aria-controls="faqContent"
                title="Klicken Sie, um h√§ufig gestellte Fragen anzuzeigen oder auszublenden.">
                <h2 class="text-xl font-semibold mb-3 text-yellow-700">‚ùì H√§ufig gestellte Fragen (FAQ)</h2>
                <span id="faqArrow" class="toggle-icon" aria-hidden="true">‚¨áÔ∏è</span>
            </div>
            <div id="faqContent" class="hidden">
                <ul class="list-disc text-gray-600 text-sm space-y-3 list-outside-indent">
                    <li>
                        <span class="font-bold">1. Weshalb funktioniert das "automatische Mith√∂ren" nur mit einem Full-Range-Vibration-Lautsprecher, bzw. einem K√∂rperschall Lautsprecher oder mit angeschlossenem Kopfh√∂rer?</span><br>
                        Das "automatische Mith√∂ren" der X-Frequency App ist darauf ausgelegt, Frequenzen aus dem <span class="faq-emphasis">akustischen Raum</span> zu erfassen. Wenn du normale Lautsprecher verwendest, geben diese den Ton ab, und das Mikrofon deines Ger√§ts w√ºrde diesen Ton sofort wieder aufnehmen. Das erzeugt eine <span class="faq-emphasis">R√ºckkopplungsschleife</span> oder ein Echo, das die Messung verf√§lschen und sogar zu unangenehmen Pfeifger√§uschen f√ºhren kann.
                        Ein <span class="faq-emphasis">Full-Range-Vibration-Lautsprecher</span> oder ein <span class="faq-emphasis">K√∂rperschalllautsprecher</span> sendet die Frequenzen direkt in einen Gegenstand (z.B. einen Tisch oder ein Glas Wasser), ohne sie direkt in die Luft abzustrahlen. Dadurch kann das Mikrofon die Umgebungsger√§usche klarer erfassen. Bei <span class="faq-emphasis">Kopfh√∂rern</span> wird der Ton direkt an deine Ohren geleitet und st√∂rt das Mikrofon nicht, sodass eine saubere Analyse der Umgebung m√∂glich ist.
                    </li>
                    <li>
                        <span class="font-bold">2. Weshalb kann ich z.B. "Tiefe Erdung (1.2 Hz)" nicht h√∂ren?</span><br>
                        Frequenzen wie "Tiefe Erdung" (1.2 Hz) liegen im sogenannten <span class="faq-emphasis">Infraschallbereich</span>. Das menschliche Ohr kann T√∂ne in der Regel nur im Frequenzbereich von etwa <span class="faq-emphasis">20 Hz bis 20.000 Hz</span> wahrnehmen. Frequenzen unter 20 Hz werden als Infraschall bezeichnet und sind f√ºr uns nicht h√∂rbar, obwohl sie physikalisch vorhanden sind und manchmal als Druck oder Vibration empfunden werden k√∂nnen. Die App erzeugt diese Frequenzen korrekt, aber du kannst sie aus biologischen Gr√ºnden nicht h√∂ren.
                    </li>
                    <li>
                        <span class="font-bold">3. Wenn ich den Ton aufzeichne/abspiele, weshalb ist die Aufzeichnung so schlecht?</span><br>
                        Die Qualit√§t der Audioaufnahme und -wiedergabe in einer Web-App wie X-Frequency kann durch mehrere Faktoren beeinflusst werden:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Browser- und Systemlimitierungen:</span> Webbrowser haben oft Einschr√§nkungen bei der Audioverarbeitung, die eine Studioqualit√§t schwierig machen. Die Aufnahme erfolgt im WebM-Format, das f√ºr die Echtzeit√ºbertragung optimiert ist, aber nicht immer die h√∂chste Wiedergabetreue bietet.</li>
                            <li><span class="faq-emphasis">Mikrofonqualit√§t:</span> Das eingebaute Mikrofon deines Ger√§ts ist selten f√ºr hochwertige Aufnahmen optimiert. Externe Mikrofone verbessern die Qualit√§t erheblich.</li>
                            <li><span class="faq-emphasis">Umgebungsger√§usche:</span> St√∂rger√§usche in deiner Umgebung werden mit aufgezeichnet.</li>
                            <li><span class="faq-emphasis">Hardware-Ressourcen:</span> Langsamere Prozessoren oder unzureichender Arbeitsspeicher k√∂nnen zu "Dropouts" oder Verzerrungen f√ºhren.</li>
                            <li><span class="faq-emphasis">"Force Passthrough" (Aux-OUT):</span> Wenn diese Option aktiviert ist, wird das Live-Mikrofonsignal direkt an den Audio-Ausgang geleitet. Dies kann zu Echos oder einer schlechten Klangqualit√§t f√ºhren, da das System das Signal zweimal verarbeitet und wiedergibt.</li>
                        </ul>
                        Um die Qualit√§t zu verbessern, achte auf eine ruhige Umgebung, verwende ein hochwertiges externes Mikrofon und deaktiviere <span class="faq-emphasis">"Force Passthrough"</span> w√§hrend der Aufnahme.
                    </li>
                    <li>
                        <span class="font-bold">4. Bei Input/Output werden nicht die richtigen Ger√§te MIC/AUX angezeigt, was kann ich tun?</span><br>
                        Wenn die gew√ºnschten Audio-Ger√§te (Mikrofon/Aux-Ausgang) nicht in den Dropdowns erscheinen, kann das mehrere Ursachen haben:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Berechtigungen:</span> Stelle sicher, dass du deinem Browser die Erlaubnis erteilt hast, auf Audio-Ger√§te zuzugreifen. Ohne diese Berechtigung k√∂nnen Ger√§te nicht erkannt werden.</li>
                            <li><span class="faq-emphasis">Ger√§te angeschlossen?:</span> Pr√ºfe, ob deine Ger√§te (z.B. externes Mikrofon, USB-Soundkarte, Kopfh√∂rer) korrekt an deinen Computer angeschlossen und eingeschaltet sind.</li>
                            <li><span class="faq-emphasis">Systemeinstellungen:</span> √úberpr√ºfe die Audio-Einstellungen deines Betriebssystems (Windows, macOS, Linux), um sicherzustellen, dass die Ger√§te dort als aktiv erkannt werden.</li>
                            <li><span class="faq-emphasis">Browser-Neustart:</span> Manchmal hilft es, den Browser neu zu starten, nachdem neue Ger√§te angeschlossen wurden.</li>
                            <li><span class="faq-emphasis">Treiber:</span> Stelle sicher, dass die Treiber f√ºr deine Audio-Hardware auf dem neuesten Stand sind.</li>
                            <li><span class="faq-emphasis">Ger√§tewechsel:</span> Werden neue Mikrofon- oder Audio-Ausgabeger√§te hinzugef√ºgt, muss unter Umst√§nden der Computer neu gestartet werden, damit sie korrekt erkannt werden.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-bold">5. Ben√∂tige ich spezielle Hardware (Mikrofon, Lautsprecher) f√ºr X-Frequency?</span><br>
                        Die X-Frequency App ist so konzipiert, dass sie mit der Standard-Audio-Hardware deines Ger√§ts (integriertes Mikrofon und Lautsprecher) funktioniert. F√ºr die grundlegende Frequenzerzeugung und -analyse reicht dies aus. Um jedoch die volle Leistungsf√§higkeit zu nutzen, insbesondere f√ºr das "automatische Mith√∂ren" ohne R√ºckkopplung, oder f√ºr pr√§zisere Analysen und Aufnahmen, werden <span class="faq-emphasis">externe Kopfh√∂rer</span> oder <span class="faq-emphasis">Full-Range-Vibration-Lautsprecher/K√∂rperschalllautsprecher</span> empfohlen. Ein hochwertiges externes Mikrofon verbessert die Aufnahmequalit√§t erheblich.
                    </li>
                    <li>
                        <span class="font-bold">6. Wie stelle ich eine Frequenz manuell ein und spiele sie ab?</span><br>
                        Im Bereich "Frequenz-Generator" kannst du die gew√ºnschte Frequenz auf zwei Arten einstellen:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Verwende den <span class="faq-emphasis">Schieberegler</span> (`frequencyRange`), um die Frequenz grob einzustellen.</li>
                            <li>Nutze das <span class="faq-emphasis">Eingabefeld</span> (`manualFrequencyInput`), um einen exakten Wert in Hertz (Hz) einzugeben.</li>
                        </ul>
                        Sobald die gew√ºnschte Frequenz eingestellt ist, klicke auf den Button <span class="faq-emphasis">"Manuell abspielen"</span>. Um die Wiedergabe zu stoppen, klicke denselben Button erneut, der sich dann in "Manuell stoppen" ge√§ndert hat.
                    </li>
                    <li>
                        <span class="font-bold">7. Warum erhalte ich eine "Mikrofonzugriff verweigert"-Warnung?</span><br>
                        Diese Warnung erscheint, wenn die App nicht auf das Mikrofon deines Ger√§ts zugreifen kann. Dies liegt meist an fehlenden Berechtigungen:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Dein Browser ben√∂tigt die explizite <span class="faq-emphasis">Erlaubnis</span>, auf das Mikrofon zuzugreifen. √úberpr√ºfe die Einstellungen deines Browsers (oft in den Datenschutz- oder Website-Berechtigungen), ob der Zugriff f√ºr diese Seite blockiert ist.</li>
                            <li>Manchmal muss auch das <span class="faq-emphasis">Betriebssystem</span> (Windows, macOS, Android, iOS) den Mikrofonzugriff f√ºr den Browser erlauben.</li>
                            <li>Stelle sicher, dass kein anderes Programm das Mikrofon exklusiv nutzt.</li>
                        </ul>
                        Nachdem du die Berechtigungen angepasst hast, lade die Seite neu.
                    </li>
                    <li>
                        <span class="font-bold">8. Wie funktioniert die "Automatisches Mith√∂ren"-Funktion und wie richte ich sie ein?</span><br>
                        Die Funktion "Automatisches Mith√∂ren" erm√∂glicht es der App, Frequenzen in deiner Umgebung √ºber das Mikrofon zu √ºberwachen und bei Erkennung einer ausgew√§hlten Frequenz diese automatisch abzuspielen. So richtest du sie ein:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Aktiviere im Bereich "Frequenz-Assistenten & Kategorien" die gew√ºnschten Frequenzen √ºber die <span class="faq-emphasis">Checkboxen</span> oder w√§hle sie aus den <span class="faq-emphasis">Dropdown-Men√ºs</span> ("Harmonie-Frequenz", "Umwelt-Frequenz") aus.</li>
                            <li>Die App spielt die ausgew√§hlte Frequenz ab, sobald sie eine √úberschneidung mit dem Mikrofonsignal feststellt. Sie wechselt automatisch zu einer neu erkannten Frequenz, sobald die Mindestwiedergabedauer der aktuellen Frequenz (siehe Einstellungen) √ºberschritten ist.</li>
                            <li>Starte die Funktion, indem du auf <span class="faq-emphasis">"Automatisches Mith√∂ren starten"</span> klickst. Der Button √§ndert sich zu "Automatisches Mith√∂ren stoppen", um die Funktion jederzeit zu beenden.</li>
                        </ul>
                        Hinweis: F√ºr diese Funktion ist ein aktiviertes Mikrofon erforderlich.
                    </li>
                    <li>
                        <span class="font-bold">9. Was bedeutet "Erkennungs-Empfindlichkeit" (dB) und wie beeinflusst sie die Frequenz-Analyse?</span><br>
                        Die <span class="faq-emphasis">Erkennungs-Empfindlichkeit (dB)</span> bestimmt, wie "laut" ein Signal sein muss, damit die App es als relevante Frequenz erkennt. dB steht f√ºr Dezibel, eine logarithmische Masseinheit f√ºr Lautst√§rke:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Ein Wert wie <span class="faq-emphasis">-55 dB</span> bedeutet, dass die App nur Frequenzen erkennt, die √ºber dieser Lautst√§rke liegen. Alles darunter wird ignoriert.</li>
                            <li><span class="faq-emphasis">Niedrigere dB-Werte</span> (z.B. -70 dB) machen die App empfindlicher, sie erkennt auch leisere Signale.</li>
                            <li><span class="faq-emphasis">H√∂here dB-Werte</span> (z.B. -30 dB) machen die App weniger empfindlich, sie reagiert nur auf lautere Signale.</li>
                        </ul>
                        Du kannst den Wert mit dem Schieberegler anpassen, um Umgebungsger√§usche herauszufiltern oder sehr leise Frequenzen zu erfassen.
                    </li>
                    <li>
                        <span class="font-bold">10. Warum gibt es im Debug-Bereich eine Option "Force Output (Testmodus)" und wof√ºr ist sie?</span><br>
                        Der <span class="faq-emphasis">"Force Output (Testmodus)"</span> im Debug-Bereich ist eine erweiterte Funktion f√ºr Testzwecke:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Wenn dieser Modus aktiviert ist, <span class="faq-emphasis">deaktiviert</span> er alle automatischen Mikrofon- und Erkennungsfunktionen.</li>
                            <li>Du kannst dann <span class="faq-emphasis">manuell eine einzelne Frequenz</span> aus den "Frequenz-Assistenten"-Kategorien ausw√§hlen, die dann <span class="faq-emphasis">sofort und kontinuierlich</span> abgespielt wird, unabh√§ngig vom Mikrofoneingang.</li>
                            <li>Dies ist n√ºtzlich, um die Ausgabe bestimmter Frequenzen zu testen, ohne dass die Mikrofonanalyse oder die Automatisierungslogik eingreifen. Es ist eine Art "erzwungener" Frequenzausgang f√ºr Debugging-Zwecke.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-bold">11. Wie kann ich Audio mit der App aufnehmen und wiedergeben?</span><br>
                        Im "Debug-Bereich" findest du die Optionen zur Audio-Aufnahme und -Wiedergabe:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Stelle sicher, dass das <span class="faq-emphasis">Mikrofon aktiviert</span> ist ("Mikrofon starten").</li>
                            <li>Klicke auf <span class="faq-emphasis">"‚è∫Ô∏è 5 Sek. Ton aufzeichnen"</span>, um eine kurze Audioaufnahme zu starten. W√§hrend der Aufnahme wird ein Countdown angezeigt.</li>
                            <li>Nachdem die Aufnahme beendet ist, wird der Button <span class="faq-emphasis">"‚ñ∂Ô∏è File abspielen"</span> aktiv. Klicke darauf, um die soeben gemachte Aufnahme abzuspielen. Du kannst sie jederzeit durch erneutes Klicken auf den "Abspielen stoppen"-Button anhalten.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-bold">12. Meine Frequenz-Visualisierung auf dem Canvas zeigt keine klaren Spitzen oder ist leer ‚Äì was mache ich falsch?</span><br>
                        Eine leere oder unklare Frequenz-Visualisierung kann mehrere Gr√ºnde haben:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Mikrofon nicht aktiv:</span> Stelle sicher, dass du das Mikrofon mit dem Button "Mikrofon starten" aktiviert hast.</li>
                            <li><span class="faq-emphasis">Mikrofon-Berechtigungen:</span> Pr√ºfe, ob der Browser die Berechtigung zum Mikrofonzugriff hat (siehe FAQ 7).</li>
                            <li><span class="faq-emphasis">Kein Audioeingang:</span> Sprich ins Mikrofon oder spiele einen Ton in der N√§he ab. Die Visualisierung reagiert auf Ger√§usche.</li>
                            <li><span class="faq-emphasis">Mikrofon-Gain zu niedrig:</span> Erh√∂he den "Mikrofon-Gain" im Einstellungsbereich. Wenn der Gain zu niedrig ist, werden auch laute Ger√§usche nicht erfasst.</li>
                            <li><span class="faq-emphasis">Erkennungs-Empfindlichkeit zu hoch:</span> Wenn die "Erkennungs-Empfindlichkeit" (dB) zu hoch eingestellt ist (z.g. -20 dB), werden nur sehr laute Signale angezeigt. Versuche, den Wert zu senken (z.B. auf -60 dB), um auch leisere Ger√§usche zu visualisieren.</li>
                            <li><span class="faq-emphasis">"Force Output (Testmodus)" aktiv:</span> Im "Force Output" Modus ist die Mikrofoneingabe deaktiviert, daher wird die Visualisierung leer bleiben.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-bold">13. Was ist der Unterschied zwischen den "Mystischen Frequenzen" und "Weiteren Harmonie-Frequenzen"?</span><br>
                        Beide Kategorien sind Teil der "Frequenz-Assistenten", haben aber unterschiedliche Schwerpunkte:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Mystische Frequenzen f√ºr Muster in der Natur:</span> Diese Frequenzen sind eher theoretisch und experimentell. Sie sind mit Konzepten wie Cymatik (Sichtbarmachung von Schall), Wasserstrukturen, Zell-Harmonie und geometrischen Mustern verbunden, die in der Natur vorkommen sollen. Ihre Anwendung ist eher explorativ.</li>
                            <li><span class="faq-emphasis">Weitere Harmonie-Frequenzen:</span> Diese Frequenzen sind typischerweise mit esoterischen oder alternativen Gesundheitskonzepten verbunden, die das Wohlbefinden, die Harmonisierung von Energiezentren (Chakren) oder spezifische Absichten (z.B. "Divine Frequency", "Miracle Frequency") unterst√ºtzen sollen. Ihre Wirkung wird oft im Kontext von Resonanz und Schwingung verstanden.</li>
                        </ul>
                        Beide sind als erg√§nzende Anwendungen zu verstehen und ersetzen keine wissenschaftlich fundierten oder medizinischen Behandlungen.
                    </li>
                    <li>
                        <span class="font-bold">14. Kann ich X-Frequency auch auf meinem Smartphone oder Tablet nutzen?</span><br>
                        Ja, X-Frequency ist als Web-App konzipiert und sollte auf den meisten modernen Smartphones und Tablets √ºber den Browser funktionieren. Die Benutzeroberfl√§che ist <span class="faq-emphasis">responsive</span> gestaltet, das heisst, sie passt sich automatisch an verschiedene Bildschirmgr√∂ssen an, um eine gute Bedienbarkeit auf mobilen Ger√§ten zu gew√§hrleisten.
                        Beachte jedoch, dass die Leistung und die Qualit√§t des Mikrofons und der Lautsprecher je nach Ger√§t variieren k√∂nnen. F√ºr optimale Ergebnisse, insbesondere bei der Frequenz-Analyse, k√∂nnten externe Mikrofone oder Kopfh√∂rer auch auf mobilen Ger√§ten von Vorteil sein. Stelle sicher, dass dein mobiler Browser die Medienberechtigungen f√ºr den Mikrofonzugriff erteilen kann.
                    </li>
                    <li>
                        <span class="font-bold">15. Vom Live-Konzert zu einer dynamischen, visuellen B√ºhnenshow ‚Äì wie funktioniert das?</span><br>
                        Die X-Frequency App kann als Herzst√ºck einer faszinierenden Live-Performance dienen, die Sound in dynamische visuelle Muster verwandelt:
                        <ul class="list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Ein <span class="faq-emphasis">Mikrofon</span> f√§ngt den <span class="faq-emphasis">Live-Sound</span> des Konzerts oder der Performance ein.</li>
                            <li>Diese App analysiert den eingehenden <span class="faq-emphasis">Audiostream kontinuierlich</span> und erkennt, wenn bestimmte <span class="faq-emphasis">Frequenzen √ºberlagert</span> werden. Du kannst hierf√ºr die "Automatisches Mith√∂ren"-Funktion nutzen und die entsprechenden Frequenzen ausw√§hlen.</li>
                            <li>Wird eine solche Frequenz√ºberschneidung erkannt, leitet die App das <span class="faq-emphasis">analysierte Signal</span> (oder einen generierten, korrespondierenden Ton) f√ºr die eingestellte Dauer √ºber einen <span class="faq-emphasis">Aux-Ausgang</span> an einen <span class="faq-emphasis">K√∂rperschall-Lautsprecher</span> weiter.</li>
                            <li>Dieser Lautsprecher ist an einer Art <span class="faq-emphasis">Teller mit Wasser</span> befestigt, der dadurch zum <span class="faq-emphasis">Schwingen gebracht</span> wird. So entstehen dynamische und hypnotisierende <span class="faq-emphasis">Wellenmuster auf der Wasseroberfl√§che</span>. Dies ist das Prinzip der <span class="faq-emphasis">Cymatik</span>.</li>
                            <li>Die gesamte Installation ist von <span class="faq-emphasis">LED-Licht</span> umgeben, das sich farblich an die B√ºhnenbeleuchtung anpasst und die Wellenmuster eindrucksvoll inszeniert.</li>
                            <li>Eine <span class="faq-emphasis">Kamera</span> (oder ein Smartphone) filmt die sich ver√§ndernde Wasseroberfl√§che, idealerweise aus der Vogelperspektive.</li>
                            <li>Abschliessend projiziert ein <span class="faq-emphasis">R√ºckprojektionsbeamer</span> das <span class="faq-emphasis">Live-Bild des Wassers</span> auf die grosse <span class="faq-emphasis">B√ºhnenleinwand</span>, wodurch eine einzigartige, visuelle Darstellung des Konzert-Sounds in Echtzeit entsteht. Das Publikum erlebt den Klang nicht nur auditiv, sondern auch als faszinierendes, fl√ºssiges Kunstwerk.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-bold">16. Wie kann ich meine eigenen "Benutzerdefinierte Frequenzen" hinzuf√ºgen, bearbeiten oder l√∂schen?</span><br>
                        Im Bereich <span class="faq-emphasis">"Benutzerdefinierte Frequenzen"</span> k√∂nnen Sie Ihre eigenen Frequenzen verwalten:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Hinzuf√ºgen:</span> Geben Sie einfach einen Namen und den gew√ºnschten Frequenzwert (in Hz) in die daf√ºr vorgesehenen Eingabefelder ein und klicken Sie auf den Button <span class="faq-emphasis">"Hinzuf√ºgen"</span>. Die neue Frequenz erscheint sofort in der Liste dar√ºber.</li>
                            <li><span class="faq-emphasis">Bearbeiten:</span> Eine direkte Bearbeitungsfunktion f√ºr bestehende benutzerdefinierte Frequenzen ist derzeit nicht integriert. Um einen Wert zu √§ndern, l√∂schen Sie die Frequenz und f√ºgen Sie sie neu mit den korrigierten Daten hinzu.</li>
                            <li><span class="faq-emphasis">L√∂schen:</span> Neben jeder benutzerdefinierten Frequenz in der Liste finden Sie ein <span class="faq-emphasis">"‚úñ"</span>-Symbol. Klicken Sie darauf, um die entsprechende Frequenz aus Ihrer Liste zu entfernen. Eine Best√§tigung wird angefordert, um versehentliche L√∂schungen zu verhindern.</li>
                        </ul>
                        Alle √Ñnderungen werden automatisch im Browser gespeichert, sodass Ihre benutzerdefinierten Frequenzen auch nach dem Neuladen der Seite erhalten bleiben.
                    </li>
                    <li>
                        <span class="font-bold">17. Kann ich meine "Benutzerdefinierte Frequenzen" mit anderen teilen oder auf ein anderes Ger√§t √ºbertragen?</span><br>
                        Ja, die App bietet Funktionen zum einfachen Teilen und √úbertragen Ihrer benutzerdefinierten Frequenzen:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Exportieren:</span> Im <span class="faq-emphasis">"Einstellungen"</span>-Bereich finden Sie einen Button <span class="faq-emphasis">"Exportieren Frequenzen"</span>. Klicken Sie darauf, um alle Ihre benutzerdefinierten Frequenzen als JSON-Datei herunterzuladen. Diese Datei k√∂nnen Sie dann per E-Mail, Messenger oder USB-Stick teilen.</li>
                            <li><span class="faq-emphasis">Importieren:</span> Ebenfalls im <span class="faq-emphasis">"Einstellungen"</span>-Bereich gibt es eine Option <span class="faq-emphasis">"Importieren Frequenzen"</span>. Klicken Sie darauf, um eine zuvor exportierte JSON-Datei auszuw√§hlen. Sie werden gefragt, ob Sie die importierten Frequenzen zur bestehenden Liste hinzuf√ºgen oder die aktuelle Liste damit √ºberschreiben m√∂chten. Dies ist ideal, um Ihre Frequenzen auf ein neues Ger√§t zu √ºbertragen oder Listen von Freunden zu √ºbernehmen.</li>
                        </ul>
                    </li>
                    <li><span class="font-bold">18. Wie kann ich meine &quot;Benutzerdefinierte Frequenzen&quot; thematisch sortieren?</span><br><p>Direkt in der App l√§sst sich <span class="faq-emphasis">nicht sortieren</span>. So geht‚Äôs in f√ºnf Schritten:</p>
<ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1"><li>Zwei <span class="faq-emphasis">Dummy‚ÄëEintr√§ge</span> anlegen (z.&nbsp;B. <em>Dummy‚Äë1 (111&nbsp;Hz)</em> und <em>Dummy‚Äë2 (222&nbsp;Hz)</em>).</li><li>Alle Frequenzen als <code>.json</code> <span class="faq-emphasis">exportieren</span>.</li><li>Die <code>JSON</code> in einem Editor (z.&nbsp;B. <em>Notepad</em> oder <em>VS&nbsp;Code</em>) thematisch <span class="faq-emphasis">ordnen</span> und speichern.</li><li>In der App die bestehenden <span class="faq-emphasis">Custom‚ÄëEintr√§ge</span> <span class="faq-emphasis">l√∂schen</span>, damit die Liste leer ist.</li><li>Die thematisch sortierte <code>.json</code> wieder <span class="faq-emphasis">importieren</span>.</li></ul>
<p><span class="faq-emphasis">Durch Erstellungsreihenfolge:</span> Wenn Sie die Sortierung auf <span class="faq-emphasis">‚ÄûThematisch‚Äú</span> (Standardeinstellung) belassen, werden Ihre benutzerdefinierten Frequenzen in der Reihenfolge angezeigt, in der Sie sie hinzugef√ºgt haben.</p></li>
                        </ul>
                        </li>
                </ul>
            </div>
        </div>

        <!-- NEU: Wichtige Links & Communities Sektion -->
        <div class="mb-6 bg-blue-50 p-4 rounded-xl border border-blue-200">
            <div id="linksHeader" class="collapsible-header" role="button" aria-expanded="false" aria-controls="linksContent"
                title="Klicken Sie, um Links und Community-Plattformen anzuzeigen oder auszublenden.">
                <h2 class="text-xl font-semibold mb-3 text-blue-700">üîó Links & Communities</h2>
                <span id="linksArrow" class="toggle-icon" aria-hidden="true">‚¨áÔ∏è</span>
            </div>
            <div id="linksContent" class="hidden">
                <ul class="list-disc text-gray-600 text-sm space-y-2 list-outside-indent">
                    <li><span class="font-bold">X-Frequency Home:</span> <a href="https://xfrequency.blogspot.com" target="_blank" class="font-semibold text-blue-600 hover:underline">xfrequency.blogspot.com</a></li>
                    <li><span class="font-bold">X-Frequency Bilder Galerie:</span> <a href="https://photos.app.goo.gl/nyzgZgiddFXUd4eW9" target="_blank" class="font-semibold text-blue-600 hover:underline">X-Frequency Bilder Galerie</a></li>
                    <li><span class="font-bold">YouTube-Kan√§le von Sound Healing K√ºnstlern:</span> Suchen Sie nach "Sound Healing Music" oder "Klangheilung" auf <a href="https://www.youtube.com/" target="_blank" class="font-semibold text-blue-600 hover:underline">YouTube</a>, um viele K√ºnstler und Meditationskan√§le zu finden.</li>
                    <li><span class="font-bold">Foren/Gruppen zu Bioresonanz, Frequenztherapie, esoterische Klangpraktiken und Cymatik-Forschung:</span> Suchen Sie auf Plattformen wie <a href="https://www.reddit.com/subreddits/search?q=sound+healing+cymatics" target="_blank" class="font-semibold text-blue-600 hover:underline">Reddit</a> (z.g. Subreddits wie r/SoundHealing) oder in spezialisierten Bioresonanz- und Alternativmedizin-Foren.</li>
                    <li><span class="font-bold">Facebook-Gruppen:</span> Suchen Sie nach "Sound Healing Practitioners", "Cymatics Art & Science" oder "Alternative Frequenztherapien" auf <a href="https://www.facebook.com/groups/" target="_blank" class="font-semibold text-blue-600 hover:underline">Facebook</a>, um aktive Communities zu finden.</li>
                    <li><span class="font-bold">Hashtags:</span> #cymatik #cymatics #resonanz #resonance #schwingung #vibration #frequenz #frequency #frequenzen #harmonics #overtone #bioresonanz #klang #sound #klangheilung #soundhealing #meditation #relaxation #focus #wellbeing #heilung #healing #chakra #chakras #solfeggio #schumann #infraschall #ultraschall #isocronic #binaural #delta #theta #alpha #beta #gamma #wasser #cymagraph #fft #spectrum #acoustics #psychoakustik #psychoacoustics #entrainment</li>
                </ul>
          </div>
        </div>
        <!-- ENDE: NEU Wichtige Links & Communities Sektion -->


        <div class="mb-6 bg-purple-50 p-4 rounded-xl border border-purple-200">
            <div id="aboutAppHeader" class="collapsible-header" role="button" aria-expanded="false" aria-controls="aboutAppContent"
                title="Klicken Sie, um Informationen √ºber die X-Frequency App anzuzeigen oder auszublenden.">
                <h2 class="text-xl font-semibold mb-3 text-purple-700">‚ÑπÔ∏è √úber X-Frequency</h2>
                <span id="aboutAppArrow" class="toggle-icon" aria-hidden="true">‚¨áÔ∏è</span>
            </div>
            <div id="aboutAppContent" class="hidden">
                <ul class="list-disc text-gray-600 text-sm space-y-2 list-outside-indent">
                    <li><span class="font-bold">Release:</span> Frequency 1.34.58</li>
                    <li><span class="font-bold">Status:</span> Beta-Version (laufende Entwicklung)</li>
                    <li><span class="font-bold">Entwicklungsteam:</span> Gemini AI & Albertus Zerk</li>
                    <li><span class="font-bold">Zweck:</span> Ein innovatives Tool zur Erforschung und Anwendung von Audiofrequenzen f√ºr verschiedene Bereiche des Wohlbefindens und der technischen Analyse.</li>
                    <li><span class="font-bold">Rechtliches:</span> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="license noopener" aria-label="Creative Commons BY-NC-SA 4.0 Lizenz">CC BY-NC-SA 4.0</a></li>
                    <li><span class="font-bold">Homepage:</span> <a href="https://x-event.designo.ch/frequency" target="_blank" class="font-semibold text-blue-600 hover:underline" title="Besuchen Sie die X-Frequency Homepage">x-event.designo.ch/frequency</a></li>
                </ul>
<div style="display:flex;justify-content:center;align-items:center;margin-top:8px;"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="license noopener" aria-label="Creative Commons BY-NC-SA 4.0 Lizenz"><img src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png" alt="CC BY-NC-SA 4.0" style="height:16px; opacity:0.95;"></a></div>
            </div>
        </div>

        <div class="mt-8 text-center text-gray-600 text-sm flex flex-col sm:flex-row justify-center items-center space-y-2 sm:space-y-0 sm:space-x-4">
<p>
                Feurig unterst√ºtzt von <a href="https://www.stimmenfeuer.ch/" target="_blank" class="font-semibold text-red-600 hover:underline" title="Besuchen Sie die Stimmenfeuer Homepage.">Stimmenfeuer</a> üî•
            </p>
        </div>

    </div>
    <script>
        // Global variables for AudioContext, oscillator, analyser, etc.
        let audioContext;
        let oscillator;
        let outputGainNode; // Renamed to clarify it's for the app's output tone
        let analyser;
        let frequencyData;
        let timeDomainData; // To store time domain data for gain visualization
        let micStream;
        let micSourceNode; // Node for the microphone input
        let micInputGainNode; // Gain node for microphone input
        let animationFrameId; // For spectrum visualization

        // Automation related variables
        let isAutomationActive = false;
        let currentPlayingPresetFrequency = null; // Stores the preset object currently playing by automation
        let playbackStartedAt = 0; // Timestamp (audioContext.currentTime) for min. duration tracking
        let playbackDurationMs = 10000; // Configurable: 10 seconds (for automation minimum playback)

        let micWasInitiallyOffBeforeAutomation = false; // Flag to track if mic was started by automation

        // Debug related variables
        let debugActive = false;
        let isLogFrozen = false; // New variable for freezing the log
        let isForceOutputActive = false; // New variable for Force Output mode
        let currentForcedPreset = null; // To track which single preset is playing in force mode.

        // Recording and Playback variables
        let mediaRecorder;
        let audioChunks = [];
        let recordedBlob = null;
        let recordedBlobUrl = null;
        let audioPlayer = new Audio();
        let recordCountdownInterval;
        let playCountdownInterval; // Defined globally now

        let lastLogTime = 0;
        const LOG_INTERVAL_MS = 200; // Log roughly 5 times per second (1000ms / 5 = 200ms)
        const FADE_TIME = 0.05; // 50ms fade time for smooth transitions

        // DOM Elements
        const frequencyRange = document.getElementById('frequencyRange');
        const manualFrequencyInput = document.getElementById('manualFrequencyInput');
        const playStopBtn = document.getElementById('playStopBtn');
        const micToggleBtn = document.getElementById('micToggleBtn');
        const micStatusSpan = document.getElementById('micStatus');
        const micGainRange = document.getElementById('micGainRange');
        const micGainValueSpan = document.getElementById('micGainValue');
        const sensitivityRange = document.getElementById('sensitivityRange');
        const sensitivityValueSpan = document.getElementById('sensitivityValue');
        const frequencyCanvas = document.getElementById('frequencyCanvas');
        const overlapMessage = document.getElementById('overlapMessage');
        const currentPlayingPresetSpan = document.getElementById('currentPlayingPreset');
        const currentPlayingPresetNameSpan = document.getElementById('currentPlayingPresetName');
        const currentPlayingPresetFreqSpan = document.getElementById('currentPlayingPresetFreq');
        const micPermissionWarning = document.getElementById('micPermissionWarning');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const presetFrequenciesContainer = document.getElementById('presetFrequenciesContainer');
        const mysticalFrequenciesContainer = document.getElementById('mysticalFrequenciesContainer');
        const speechFrequencyTestContainer = document.getElementById('speechFrequencyTestContainer'); 
        
        // Harmonie and Umwelt Frequencies DOM Elements
        const enableHarmonyFreq = document.getElementById('enableHarmonyFreq');
        const harmonyFrequencyDropdown = document.getElementById('harmonyFrequencyDropdown');
        const enableEnvironmentFreq = document.getElementById('enableEnvironmentFreq');
        const environmentFrequencyDropdown = document.getElementById('environmentFrequencyDropdown');

        // NEU: DOM Elemente f√ºr Benutzerdefinierte Frequenzen
        const customFreqNameInput = document.getElementById('customFreqNameInput');
        const customFreqValueInput = document.getElementById('customFreqValueInput');
        const addCustomFreqBtn = document.getElementById('addCustomFreqBtn');
        const customFrequenciesContainer = document.getElementById('customFrequenciesContainer');
        const exportCustomFrequenciesBtn = document.getElementById('exportCustomFrequenciesBtn');
        const importCustomFrequenciesInput = document.getElementById('importCustomFrequenciesInput');


        // Renamed/Combined automation buttons
        const toggleAutomationBtn = document.getElementById('toggleAutomationBtn');
        const debugToggle = document.getElementById('debugToggle');
        const freezeToggle = document.getElementById('freezeToggle');
        const forceOutputToggle = document.getElementById('forceOutputToggle');
        const debugLog = document.getElementById('debugLog');
        const currentFreqDisplay = document.getElementById('currentFreqDisplay');
        const currentFreqValueSpan = document.getElementById('currentFreqValue');
        const targetFreqDisplay = document.getElementById('targetFreqDisplay');
        const targetFreqValueSpan = document.getElementById('targetFreqValue');
        const inputDropdown = document.getElementById('inputDropdown');
        const outputDropdown = document.getElementById('outputDropdown');
        const codeRemixLink = document.getElementById('codeRemixLink');
        const dynamicAutomationDescriptionDuration = document.getElementById('dynamicAutomationDescriptionDuration');

        // Recording/Playback DOM elements
        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const recordCountdownSpan = document.getElementById('recordCountdown');
        const playCountdownSpan = document.getElementById('playCountdown');
        const forcePassthroughCheckbox = document.getElementById('forcePassthroughCheckbox');

        // Gain Visualizer DOM elements
        const micGainVisualizer = document.getElementById('micGainVisualizer');
        const micGainBar = micGainVisualizer.querySelector('.mic-gain-bar');

        // New DOM elements for automation duration
        const automationDurationInput = document.getElementById('automationDurationInput');
        const automationDurationValueSpan = document.getElementById('automationDurationValue');

        // Variable to hold the base text for the play button after recording
        let playButtonCurrentBaseText = 'File abspielen';

        // Collapsible section elements
        const importantFrequenciesHeader = document.getElementById('importantFrequenciesHeader');
        const importantFrequenciesContent = document.getElementById('importantFrequenciesContent');
        const importantFrequenciesArrow = document.getElementById('importantFrequenciesArrow');

        // New collapsible section elements
        const appUsageHeader = document.getElementById('appUsageHeader');
        const appUsageContent = document.getElementById('appUsageContent');
        const appUsageArrow = document.getElementById('appUsageArrow');

        const faqHeader = document.getElementById('faqHeader');
        const faqContent = document.getElementById('faqContent');
        const faqArrow = document.getElementById('faqArrow');

        const linksHeader = document.getElementById('linksHeader');
        const linksContent = document.getElementById('linksContent');
        const linksArrow = document.getElementById('linksArrow');

        const aboutAppHeader = document.getElementById('aboutAppHeader');
        const aboutAppContent = document.getElementById('aboutAppContent');
        const aboutAppArrow = document.getElementById('aboutAppArrow');

        // Language selection DOM Element and browser language display
        const languageDropdown = document.getElementById('languageDropdown');
        const browserLanguageDisplay = document.getElementById('browserLanguageDisplay');

        // Sorting Dropdown
        const sortDropdown = document.getElementById('sortDropdown');

        const canvasCtx = frequencyCanvas.getContext('2d');

        // State variables
        let isPlaying = false; // For manual playback
        let isMicActive = false;
        let OVERLAP_THRESHOLD_DB = -55; // Initial value, now adjustable

        // Constants for visualization and detection
        const SMOOTHING_TIME_CONSTANT = 0.8; // How much the new value influences the current value
        const FFT_SIZE = 2048; // Number of samples for FFT. Must be a power of 2.
        const RECORD_PLAY_DURATION_SEC = 5; // Duration for recording and playing audio

        // Global Set to track checked presets by their overallIndex in ALL_PRESET_FREQUENCIES
        let checkedPresetIndices = new Set();
        // Map to store event listeners for force output mode, to properly detach them
        const forceModeListeners = new Map();

        // --- Preset Frequencies (immutable master data) ---
        const STANDARD_FREQUENCIES = [
            { name: "Schumann-Resonanz (Erde - Grundwelle)", freq: 7.83, category: "standard" },
            { name: "Schumann-Resonanz (Erde - 2. Harmonie)", freq: 14.1, category: "standard" },
            { name: "Schumann-Resonanz (Erde - 3. Harmonie)", freq: 20.3, category: "standard" },
            { name: "Solfeggio Ut (Befreiung von Schuld & Angst)", freq: 396, category: "standard" },
            { name: "Solfeggio Re (Transformation & Wunder)", freq: 417, category: "standard" },
            { name: "Solfeggio Mi (DNA-Reparatur & Zellregeneration)", freq: 528, category: "standard" },
            { name: "Solfeggio Fa (Verbindungen & Beziehungen)", freq: 639, category: "standard" },
            { name: "Solfeggio Sol (Intuition & G√∂ttliche F√ºhrung)", freq: 741, category: "standard" },
            { name: "Solfeggio La (R√ºckkehr zur Einheit)", freq: 852, category: "standard" },
            { name: "Heilende Wasserfrequenz", freq: 432, category: "standard" },
            { name: "Herzchakra Harmonisierung", freq: 639, category: "standard" },
            { name: "Wurzelchakra Stabilisierung", freq: 256, category: "standard" },
            { name: "Sakralchakra Kreativit√§t", freq: 303, category: "standard" },
            { name: "Solarplexuschakra Kraft", freq: 320, category: "standard" },
            { name: "Halschakra Ausdruck", freq: 384, category: "standard" },
            { name: "Stirnchakra Intuition", freq: 768, category: "standard" },
            { name: "Kronenchakra Verbindung", freq: 963, category: "standard" },
            { name: "Ganzk√∂rper-Entspannung (Delta-Wellen)", freq: 4, category: "standard" },
            { name: "Klarheit des Geistes (Gamma-Wellen)", freq: 40, category: "standard" },
            { name: "Tiefe Erdung", freq: 1.2, category: "standard" },
        ];

        const MYSTICAL_FREQUENCIES = [
            { name: "Wassertropfen-Muster (Cymatik)", freq: 111, category: "mystical" },
            { name: "Schildkr√∂tenpanzer-Muster", freq: 128, category: "mystical" },
            { name: "Schneckenhaus-Spirale", freq: 96, category: "mystical" },
            { name: "Bienenwaben-Struktur", freq: 444, category: "mystical" },
            { name: "Farnblatt-Fraktal", freq: 161.8, category: "mystical" }
        ];

        const SPEECH_FREQUENCY_PRESET = { name: "Menschliche Sprechfrequenz erkennen (Test)", freq: 180, isRange: true, minFreq: 80, maxFreq: 300, category: "speech" };

        const HARMONY_FREQUENCIES = [
            { name: "Divine Frequency", freq: 444, category: "harmony" }, { name: "Miracle Frequency", freq: 777, category: "harmony" },
            { name: "Completion/Unity", freq: 999, category: "harmony" }, { name: "Angelic Frequency", freq: 111, category: "harmony" },
            { name: "Change/Transformation", freq: 555, category: "harmony" }, { name: "Abundance/Balance", freq: 888, category: "harmony" },
            { name: "Nikola Teslas Code", freq: 369, category: "harmony" }, { name: "Growth", freq: 484, category: "harmony" },
            { name: "Serenity", freq: 686, category: "harmony" }, { name: "New Beginnings", freq: 1001, category: "harmony" },
            { name: "Spiritual Alignment", freq: 1212, category: "harmony" }, { name: "Positive Change", freq: 1313, category: "harmony" },
            { name: "Inner Guidance", freq: 1414, category: "harmony" }, { name: "Love/Romance", freq: 1515, category: "harmony" },
            { name: "Spiritual Journey", freq: 1616, category: "harmony" }, { name: "Manifestation", freq: 1717, category: "harmony" },
            { name: "New Cycles", freq: 1818, category: "harmony" }, { name: "Divine Purpose", freq: 1919, category: "harmony" },
            { name: "Clarity/Vision", freq: 2020, category: "harmony" }, { name: "Harmony/Balance", freq: 2121, category: "harmony" }
        ];

        const ENVIRONMENT_FREQUENCIES = [
            { name: "Whale Song", freq: 52, category: "environment" }, { name: "Elephant Subsonic", freq: 18, category: "environment" },
            { name: "Earth Hum", freq: 60, category: "environment" }, { name: "Bird Song Average", freq: 250, category: "environment" },
            { name: "Insect Buzz", freq: 4000, category: "environment" }, { name: "Geomagnetic Pulsation", freq: 10, category: "environment" },
            { name: "Rainfall Sound", freq: 1500, category: "environment" }, { name: "Wind Gusts", freq: 2000, category: "environment" },
            { name: "Thunder Rumbles", freq: 30, category: "environment" }, { name: "Ocean Waves", freq: 75, category: "environment" },
            { name: "River Flow", freq: 120, category: "environment" }, { name: "Earthquake Minor", freq: 20, category: "environment" },
            { name: "Tree Rustling", freq: 50, category: "environment" }, { name: "Crickets Chirping", freq: 300, category: "environment" },
            { name: "Frog Croaks", freq: 800, category: "environment" }, { name: "Mosquito Whine", freq: 1500, category: "environment" },
            { name: "Bee Humming", freq: 2500, category: "environment" }, { name: "Wolf Howl", freq: 45, category: "environment" },
            { name: "Cicada Song", freq: 3000, category: "environment" }, { name: "Coyote Bark", freq: 700, category: "environment" }
        ];

        // NEU: Array f√ºr benutzerdefinierte Frequenzen
        let USER_DEFINED_FREQUENCIES = []; // This will be loaded from localStorage

        // This array must remain in a fixed order and contains ALL possible presets for stable data-index lookups.
        // It needs to be re-generated whenever USER_DEFINED_FREQUENCIES changes, and also when sorting changes.
        let ALL_PRESET_FREQUENCIES = [];

        /**
         * Regenerates the ALL_PRESET_FREQUENCIES array by combining all source presets
         * and applying the current sorting. It then triggers the UI rendering.
         * This is the central point to ensure ALL_PRESET_FREQUENCIES is always sorted
         * for correct data-index mapping.
         */
        function updateAllPresetFrequenciesAndRender() {
            // 1. Capture currently checked presets by their unique identifiers
            const currentlyCheckedUniqueIds = new Set();
            checkedPresetIndices.forEach(idx => {
                const preset = ALL_PRESET_FREQUENCIES[idx];
                if (preset) {
                    if (preset.category === "custom" && preset.customIndex !== undefined) {
                        currentlyCheckedUniqueIds.add(`custom-${preset.customIndex}`);
                    } else if (!preset.isDropdown) { // Standard, mystical, speech
                        currentlyCheckedUniqueIds.add(`${preset.category}-${preset.name}-${preset.freq}`);
                    } else { // Dropdown virtual presets
                        currentlyCheckedUniqueIds.add(`dropdown-${preset.id}`);
                    }
                }
            });

            let combinedPresets = [
                ...STANDARD_FREQUENCIES,
                ...MYSTICAL_FREQUENCIES,
                SPEECH_FREQUENCY_PRESET,
                ...USER_DEFINED_FREQUENCIES.map((p, index) => ({ ...p, category: "custom", customIndex: index }))
            ];

            const sortType = sortDropdown.value;

            switch (sortType) {
                case 'alphabetical':
                    combinedPresets.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'frequency_asc':
                    combinedPresets.sort((a, b) => a.freq - b.freq);
                    break;
                case 'frequency_desc':
                    combinedPresets.sort((a, b) => b.freq - a.freq);
                    break;
                case 'thematic':
                default:
                    // For 'thematic', reconstruct in original defined order
                    combinedPresets = [
                        ...STANDARD_FREQUENCIES,
                        ...MYSTICAL_FREQUENCIES,
                        SPEECH_FREQUENCY_PRESET,
                        ...USER_DEFINED_FREQUENCIES.map((p, index) => ({ ...p, category: "custom", customIndex: index }))
                    ];
                    break;
            }

            // Now, ALL_PRESET_FREQUENCIES will hold the sorted list of actual presets.
            // We add the virtual dropdown presets *after* sorting, so their indices are stable at the end.
            ALL_PRESET_FREQUENCIES = [
                ...combinedPresets,
                { id: 'enableHarmonyFreq', name: "Harmony Selected", freq: null, isDropdown: true, elementId: 'enableHarmonyFreq' },
                { id: 'enableEnvironmentFreq', name: "Environment Selected", freq: null, isDropdown: true, elementId: 'enableEnvironmentFreq' }
            ];

            // 2. Clear and then rebuild checkedPresetIndices based on the new ALL_PRESET_FREQUENCIES
            checkedPresetIndices.clear();
            ALL_PRESET_FREQUENCIES.forEach((preset, index) => {
                let uniqueId;
                if (preset.category === "custom" && preset.customIndex !== undefined) {
                    uniqueId = `custom-${preset.customIndex}`;
                } else if (!preset.isDropdown) {
                    uniqueId = `${preset.category}-${preset.name}-${preset.freq}`;
                } else {
                    uniqueId = `dropdown-${preset.id}`;
                }

                if (currentlyCheckedUniqueIds.has(uniqueId)) {
                    checkedPresetIndices.add(index);
                }
            });

            // Re-render all sections based on the new ALL_PRESET_FREQUENCIES order.
            renderStandardPresets();
            renderMysticalPresets();
            renderSpeechPreset();
            renderCustomFrequencies();

            // Re-populate and restore selection for Harmony and Environment Dropdowns
            populateHarmonyAndEnvironmentDropdowns();

            // Re-evaluate automation button state, as checked presets might have changed.
            updateAutomationButtonState();
            updateValueBoxesVisibility();
        }


        /**
         * Loads user-defined frequencies from localStorage.
         */
        function loadCustomFrequencies() {
            try {
                const storedFrequencies = localStorage.getItem('userDefinedFrequencies');
                if (storedFrequencies) {
                    const parsed = JSON.parse(storedFrequencies);
                    // Basic validation to ensure it's an array of objects with name and freq
                    if (Array.isArray(parsed) && parsed.every(f => typeof f.name === 'string' && typeof f.freq === 'number')) {
                        USER_DEFINED_FREQUENCIES = parsed;
                        console.log('Benutzerdefinierte Frequenzen aus localStorage geladen.');
                    } else {
                        console.warn('Ung√ºltiges Format f√ºr benutzerdefinierte Frequenzen im localStorage. Daten werden ignoriert.');
                        USER_DEFINED_FREQUENCIES = [];
                    }
                }
            } catch (e) {
                console.error('Fehler beim Laden der benutzerdefinierten Frequenzen aus localStorage:', e);
                USER_DEFINED_FREQUENCIES = [];
            }
            updateAllPresetFrequenciesAndRender(); // Re-populate ALL_PRESET_FREQUENCIES after loading and render
        }

        /**
         * Saves user-defined frequencies to localStorage.
         */
        function saveCustomFrequencies() {
            try {
                localStorage.setItem('userDefinedFrequencies', JSON.stringify(USER_DEFINED_FREQUENCIES));
                console.log('Benutzerdefinierte Frequenzen in localStorage gespeichert.');
            } catch (e) {
                console.error('Fehler beim Speichern der benutzerdefinierten Frequenzen in localStorage:', e);
            }
        }


        /**
         * Initializes the AudioContext and related nodes.
         * This should be called only once initially, but its resume logic can be called multiple times.
         */
        async function initAudioContext() {
            // If AudioContext already exists and is not closed, just ensure it's running
            if (audioContext && audioContext.state !== 'closed') {
                if (audioContext.state === 'suspended') {
                    try {
                        await audioContext.resume();
                        console.log('AudioContext resumed.');
                    } catch (error) {
                        console.error('Failed to resume AudioContext:', error);
                        // Do not re-throw, allow the app to continue trying
                    }
                }
                return; // Context is already created and potentially resumed
            }

            // If context doesn't exist or is closed, create a new one
            loadingOverlay.classList.remove('hidden');
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Ensure context is running immediately after creation if it's not already
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                analyser = audioContext.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                analyser.smoothingTimeConstant = SMOOTHING_TIME_CONSTANT;
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                timeDomainData = new Uint8Array(analyser.fftSize);

                analyser.minDecibels = -90;
                analyser.maxDecibels = -10;

                // Create oscillator and outputGainNode ONLY ONCE here
                oscillator = audioContext.createOscillator();
                outputGainNode = audioContext.createGain();
                outputGainNode.gain.value = 0; // Start with 0 gain
                oscillator.connect(outputGainNode);
                outputGainNode.connect(audioContext.destination);
                oscillator.start(0); // Start oscillator once, let gain control sound

                micInputGainNode = audioContext.createGain();
                micInputGainNode.gain.value = parseFloat(micGainRange.value);

                console.log('AudioContext initialisiert und l√§uft.');
            } catch (error) {
                console.error('Fehler beim Initialisieren des AudioContext:', error);
                console.error('Entschuldigung, Ihr Browser unterst√ºtzt die Web Audio API nicht oder es gab ein Problem beim Starten.');
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        }

        /**
         * Starts the frequency generator.
         * @param {number} freq - The frequency to play.
         */
        async function startOscillator(freq) {
            await initAudioContext(); // Ensure AudioContext is running
            if (!audioContext || audioContext.state !== 'running' || !oscillator || !outputGainNode) {
                console.error("AudioContext oder Oszillator/Gain-Node sind nicht bereit zum Abspielen.");
                return;
            }

            // Immediately set frequency
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

            // Cancel any pending gain ramps and ramp up to target volume
            outputGainNode.gain.cancelScheduledValues(audioContext.currentTime);
            // Ensure current value is the start point for ramp (important if previous ramp was interrupted)
            outputGainNode.gain.setValueAtTime(outputGainNode.gain.value, audioContext.currentTime); 
            outputGainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + FADE_TIME);

            isPlaying = true;
            playStopBtn.textContent = 'Manuell stoppen';
            playStopBtn.setAttribute('title', 'Stoppt die manuelle Frequenzwiedergabe');
            playStopBtn.setAttribute('aria-label', 'Manuelle Frequenzwiedergabe stoppen');
            console.log(`Spiele Frequenz: ${freq} Hz (sanft einblendend). AudioContext state: ${audioContext.state}, Target Gain: ${outputGainNode.gain.value}`);
        }

        /**
         * Stops the frequency generator.
         */
        function stopOscillator() {
            if (isPlaying && oscillator && outputGainNode && audioContext) {
                // Smoothly ramp down the gain to 0
                outputGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                outputGainNode.gain.setValueAtTime(outputGainNode.gain.value, audioContext.currentTime); // Ensure current value is the start point for ramp
                outputGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + FADE_TIME);

                // Set isPlaying to false immediately, but the sound will fade out
                isPlaying = false;
                playStopBtn.textContent = 'Manuell abspielen';
                playStopBtn.setAttribute('title', 'Startet die manuelle Frequenzwiedergabe');
                playStopBtn.setAttribute('aria-label', 'Manuelle Frequenzwiedergabe starten');
                console.log('Frequenz gestoppt (sanft ausblendend).');
            }
            currentForcedPreset = null;
            // Ensure UI for automatic playback is hidden even if it wasn't triggered by an automation stop
            currentPlayingPresetSpan.classList.add('hidden');
            overlapMessage.classList.add('hidden');
            document.body.classList.remove('highlight-background');
        }

        /**
         * Updates the frequency of the oscillator and synchronizes both input fields.
         * This function will be called by both the range slider and the number input.
         */
        function updateFrequencyControls(event) {
            let freq;
            if (event.target.id === 'frequencyRange') {
                freq = parseFloat(frequencyRange.value);
                manualFrequencyInput.value = freq.toFixed(2);
            } else if (event.target.id === 'manualFrequencyInput') {
                const rawValue = manualFrequencyInput.value;
                if (rawValue === '' || isNaN(parseFloat(rawValue))) {
                    if (event.type === 'input') return;
                }
                freq = parseFloat(rawValue);
                const min = parseFloat(manualFrequencyInput.min);
                const max = parseFloat(manualFrequencyInput.max);
                freq = Math.max(min, Math.min(max, freq));

                if (event.type === 'input') {
                    frequencyRange.value = freq;
                } else if (event.type === 'change') {
                    manualFrequencyInput.value = freq.toFixed(2);
                    frequencyRange.value = freq;
                }
            } else {
                freq = parseFloat(manualFrequencyInput.value);
            }

            // Update aria-valuenow for both elements
            if (!isNaN(freq)) {
                manualFrequencyInput.setAttribute('aria-valuenow', freq.toFixed(2));
                frequencyRange.setAttribute('aria-valuenow', freq.toFixed(0)); // Range slider usually integer value for aria-valuenow
            }

            // Only update oscillator frequency if manually playing and not in force mode/automation
            if (oscillator && isPlaying && !currentPlayingPresetFrequency && !isForceOutputActive && !isNaN(freq)) {
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            }
            if (!isNaN(freq)) {
                console.log(`Manuelle Frequenz: ${freq.toFixed(2)} Hz`);
            }
        }

        /**
         * Toggles microphone input on/off.
         */
        async function toggleMicrophone() {
            await initAudioContext(); // Ensure AudioContext is running
            if (!audioContext || audioContext.state !== 'running') {
                console.error("AudioContext ist nicht bereit f√ºr Mikrofon-Zugriff.");
                return;
            }

            if (isMicActive) {
                // Stop microphone
                if (micStream) {
                    micStream.getTracks().forEach(track => track.stop());
                }
                if (micSourceNode) {
                    micSourceNode.disconnect();
                }
                if (micInputGainNode) {
                    micInputGainNode.disconnect(analyser);
                    if (forcePassthroughCheckbox.checked) {
                        micInputGainNode.disconnect(audioContext.destination);
                    }
                }
                stopSpectrumVisualization();
                micStatusSpan.textContent = 'Mikrofon-Status: Inaktiv';
                micToggleBtn.textContent = 'Mikrofon starten';
                micToggleBtn.setAttribute('title', 'Aktiviert den Mikrofonzugriff f√ºr die Frequenzanalyse.');
                micToggleBtn.setAttribute('aria-label', 'Mikrofon starten');
                isMicActive = false;
                micGainRange.disabled = true;
                overlapMessage.classList.add('hidden');
                micPermissionWarning.classList.add('hidden');
                currentPlayingPresetSpan.classList.add('hidden');

                // If automation was active and playing, stop the oscillator
                if (isAutomationActive && currentPlayingPresetFrequency) {
                    stopOscillator(); // Now uses smooth stop
                    currentPlayingPresetFrequency = null; // Clear playing preset
                    console.log('Automatischer Ton gestoppt, da Mikrofon deaktiviert.');
                    document.body.classList.remove('highlight-background'); // Ensure highlight is removed
                }

                recordBtn.disabled = true;
                playBtn.disabled = !recordedBlob;
                forcePassthroughCheckbox.disabled = true;
                forcePassthroughCheckbox.checked = false;

                updateValueBoxesVisibility();
                updateMicGainVisualizerState(); // Update visualizer state

                console.log('Mikrofon gestoppt.');
            } else {
                // Start microphone
                loadingOverlay.classList.remove('hidden');
                try {
                    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    micSourceNode = audioContext.createMediaStreamSource(micStream);

                    micSourceNode.connect(micInputGainNode);
                    micInputGainNode.connect(analyser);

                    if (forcePassthroughCheckbox.checked) {
                        micInputGainNode.connect(audioContext.destination);
                    }

                    micStatusSpan.textContent = 'Mikrofon-Status: Aktiv';
                    micToggleBtn.textContent = 'Mikrofon stoppen';
                    micToggleBtn.setAttribute('title', 'Deaktiviert den Mikrofonzugriff.');
                    micToggleBtn.setAttribute('aria-label', 'Mikrofon stoppen');
                    isMicActive = true;
                    micGainRange.disabled = false;
                    micPermissionWarning.classList.add('hidden');
                    startSpectrumVisualization();

                    recordBtn.disabled = false;
                    forcePassthroughCheckbox.disabled = false;
                    playBtn.disabled = !recordedBlob;

                    updateValueBoxesVisibility();
                    updateMicGainVisualizerState(); // Update visualizer state

                    console.log('Mikrofon gestartet.');
                } catch (error) {
                    console.error('Fehler beim Zugriff auf das Mikrofon:', error);
                    micStatusSpan.textContent = 'Mikrofon-Status: Fehler';
                    micPermissionWarning.classList.remove('hidden');
                    console.error('Konnte nicht auf das Mikrofon zugreifen. Bitte √ºberpr√ºfen Sie Ihre Berechtigungen.');

                    recordBtn.disabled = true;
                    playBtn.disabled = true;
                    forcePassthroughCheckbox.disabled = true;
                    forcePassthroughCheckbox.checked = false;
                    
                    updateValueBoxesVisibility();
                    updateMicGainVisualizerState(); // Update visualizer state even on error

                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            }
        }

        /**
         * Calculates the amplitude (in dB) for a given frequency bin.
         * @param {number} value - The raw amplitude value from analyser.getByteFrequencyData (0-255).
         * @returns {number} The amplitude in dB.
         */
        function getAmplitudeInDb(value) {
            if (!analyser || value === 0) return analyser ? analyser.minDecibels : -90;
            const minDb = analyser.minDecibels;
            const maxDb = analyser.maxDecibels;
            return minDb + (value / 255) * (maxDb - minDb);
        }

        /**
         * Starts the frequency spectrum visualization loop.
         */
        function startSpectrumVisualization() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(drawFrequencySpectrum);
        }

        /**
         * Stops the frequency spectrum visualization loop.
         */
        function stopSpectrumVisualization() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                canvasCtx.clearRect(0, 0, frequencyCanvas.width, frequencyCanvas.height);
            }
        }

        /**
         * Draws the frequency spectrum on the canvas and performs overlap detection for automation.
         */
        function drawFrequencySpectrum() {
            // Added robust checks for analyser and frequencyData
            if (!isMicActive || !analyser || !frequencyData || audioContext.state !== 'running') {
                stopSpectrumVisualization();
                return;
            }

            animationFrameId = requestAnimationFrame(drawFrequencySpectrum);

            analyser.getByteFrequencyData(frequencyData);
            analyser.getByteTimeDomainData(timeDomainData); // For mic gain visualizer

            // Update aria-valuenow for micGainVisualizer
            const rmsValue = calculateRMS(timeDomainData);
            micGainVisualizer.setAttribute('aria-valuenow', Math.round(rmsValue * 100)); // Assuming 0-100 scale for aria

            const WIDTH = frequencyCanvas.width;
            const HEIGHT = frequencyCanvas.height;

            canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
            canvasCtx.fillStyle = 'rgb(226, 232, 240)'; // Canvas background
            canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

            const barWidth = (WIDTH / analyser.frequencyBinCount) * 2.5; // Adjusted to spread out
            let x = 0;

            let currentPeakFreq = 0;
            let maxAmplitudeOverall = analyser.minDecibels;

            // Draw vertical bars
            for (let i = 0; i < analyser.frequencyBinCount; i++) {
                const value = frequencyData[i]; // 0-255
                const amplitudeDb = getAmplitudeInDb(value);

                if (amplitudeDb > maxAmplitudeOverall) {
                    maxAmplitudeOverall = amplitudeDb;
                    currentPeakFreq = i * (audioContext.sampleRate / analyser.fftSize);
                }

                // Calculate bar height based on amplitude relative to maxDecibels (top of canvas) and minDecibels (bottom of canvas)
                const normalizedHeight = (amplitudeDb - analyser.minDecibels) / (analyser.maxDecibels - analyser.minDecibels);
                const barHeight = normalizedHeight * HEIGHT;

                canvasCtx.fillStyle = 'rgb(' + (value + 100) + ',50,50)'; // Color based on amplitude
                canvasCtx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight); // Draw from bottom up

                x += barWidth + 1; // Spacing between bars
            }

            // Draw the red horizontal threshold line based on OVERLAP_THRESHOLD_DB
            // Convert dB value to Y-coordinate on the canvas
            // Y-axis: 0 (top) is maxDecibels, HEIGHT (bottom) is minDecibels
            const normalizedThresholdY = (OVERLAP_THRESHOLD_DB - analyser.minDecibels) / (analyser.maxDecibels - analyser.minDecibels);
            const thresholdY = HEIGHT - (normalizedThresholdY * HEIGHT); // Invert Y-axis for drawing

            canvasCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; // Bright red, semi-transparent
            canvasCtx.lineWidth = 2;
            canvasCtx.setLineDash([5, 5]); // Dashed line
            canvasCtx.beginPath();
            canvasCtx.moveTo(0, thresholdY);
            canvasCtx.lineTo(WIDTH, thresholdY);
            canvasCtx.stroke();
            canvasCtx.setLineDash([]); // Reset line dash

            // Update Mic Gain Visualizer (RMS based)
            let sumSquares = 0;
            for (let i = 0; i < timeDomainData.length; i++) {
                const value = (timeDomainData[i] - 128) / 128; // Normalize to -1 to 1
                sumSquares += value * value;
            }
            const rms = Math.sqrt(sumSquares / timeDomainData.length);
            
            const visualLevel = Math.min(1, rms * 2); // Scale RMS to a visual level (e.g., 0-1)
            micGainBar.style.width = `${visualLevel * 100}%`;

            // Note: micGainVisualizer visibility is now managed by updateMicGainVisualizerState()
            // This loop only updates the bar's width if visible.


            // Update "Ist-Wert" und "Zielwert" displays
            updateValueBoxesVisibility();
            if (!currentFreqDisplay.classList.contains('hidden')) {
                currentFreqValueSpan.textContent = `${currentPeakFreq.toFixed(1)} Hz`; // Peak frequency
            }


            // Automation logic:
            if (!isForceOutputActive && isAutomationActive) {
                const binWidth = audioContext.sampleRate / analyser.fftSize;
                let highestPriorityOverlappingPreset = null;
                let presetsToMonitor = [];

                // Add selected standard, mystical, and speech presets (checkboxes)
                // Filter ALL_PRESET_FREQUENCIES to include only those that are currently checked AND not dropdowns
                ALL_PRESET_FREQUENCIES.forEach((preset, index) => {
                    if (!preset.isDropdown) {
                        const checkbox = document.getElementById(`preset-${index}`);
                        if (checkbox && checkbox.checked) {
                            presetsToMonitor.push(preset);
                        }
                    }
                });

                // Add selected harmony frequency if enabled
                if (enableHarmonyFreq.checked) {
                    const freq = parseFloat(harmonyFrequencyDropdown.value);
                    if (!isNaN(freq)) {
                        presetsToMonitor.push({ name: harmonyFrequencyDropdown.selectedOptions[0].text, freq: freq, category: "harmony" });
                    }
                }

                // Add selected environment frequency if enabled
                if (enableEnvironmentFreq.checked) {
                    const freq = parseFloat(environmentFrequencyDropdown.value);
                    if (!isNaN(freq)) {
                        presetsToMonitor.push({ name: environmentFrequencyDropdown.selectedOptions[0].text, freq: freq, category: "environment" });
                    }
                }
                
                // Now, iterate through `presetsToMonitor` to find overlaps
                for (const preset of presetsToMonitor) {
                    let isOverlapping = false;
                    const targetFreq = preset.freq;
                    const targetBin = Math.round(targetFreq / binWidth);

                    let maxAmplitudeInTargetArea = analyser.minDecibels;

                    // Check target bin and immediate neighbors to account for FFT spread
                    const binsToCheck = [];
                    // Ensure bins are within valid range
                    if (targetBin >= 0 && targetBin < analyser.frequencyBinCount) {
                        binsToCheck.push(targetBin);
                    }
                    if (targetBin - 1 >= 0) { // Check left neighbor if exists
                        binsToCheck.push(targetBin - 1);
                    }
                    if (targetBin + 1 < analyser.frequencyBinCount) { // Check right neighbor if exists
                        binsToCheck.push(targetBin + 1);
                    }

                    for (const bin of binsToCheck) {
                        const amplitudeDb = getAmplitudeInDb(frequencyData[bin]);
                        if (amplitudeDb > maxAmplitudeInTargetArea) {
                            maxAmplitudeInTargetArea = amplitudeDb;
                        }
                    }
                    if (maxAmplitudeInTargetArea > OVERLAP_THRESHOLD_DB) {
                        isOverlapping = true;
                    }

                    if (isOverlapping) {
                        highestPriorityOverlappingPreset = preset;
                        break; // Found highest priority overlapping preset, exit loop
                    }
                }

                if (highestPriorityOverlappingPreset) {
                    // Eine Frequenz wird im Mikrofon erkannt
                    if (!currentPlayingPresetFrequency) {
                        // Fall 1: Keine Frequenz wird aktuell abgespielt, starte die neu erkannte.
                        startOscillator(highestPriorityOverlappingPreset.freq);
                        currentPlayingPresetFrequency = highestPriorityOverlappingPreset;
                        playbackStartedAt = audioContext.currentTime; // Setze Startzeit f√ºr min. Dauer, falls sp√§ter ben√∂tigt
                        currentPlayingPresetNameSpan.textContent = highestPriorityOverlappingPreset.name;
                        currentPlayingPresetFreqSpan.textContent = highestPriorityOverlappingPreset.isRange ? `${highestPriorityOverlappingPreset.minFreq}-${highestPriorityOverlappingPreset.maxFreq} Hz` : `${highestPriorityOverlappingPreset.freq} Hz`;
                        currentPlayingPresetSpan.classList.remove('hidden');
                        overlapMessage.classList.remove('hidden');
                        document.body.classList.add('highlight-background');
                        console.log(`Automatischer Start: ${highestPriorityOverlappingPreset.name} (${highestPriorityOverlappingPreset.freq} Hz)`);
                    } else if (currentPlayingPresetFrequency.freq !== highestPriorityOverlappingPreset.freq) {
                        // Fall 2: Eine andere Frequenz wird erkannt. Pr√ºfe Mindestwiedergabedauer.
                        const timeElapsedSinceLastSwitch = audioContext.currentTime - playbackStartedAt;
                        if (timeElapsedSinceLastSwitch * 1000 >= playbackDurationMs) { // Check if min duration has passed
                            stopOscillator(); // Stoppe die aktuelle (mit Rampe)
                            startOscillator(highestPriorityOverlappingPreset.freq); // Starte die neue (mit Rampe)
                            currentPlayingPresetFrequency = highestPriorityOverlappingPreset;
                            playbackStartedAt = audioContext.currentTime; // Setze Startzeit f√ºr den neuen Ton
                            currentPlayingPresetNameSpan.textContent = highestPriorityOverlappingPreset.name;
                            currentPlayingPresetFreqSpan.textContent = highestPriorityOverlappingPreset.isRange ? `${highestPriorityOverlappingPreset.minFreq}-${highestPriorityOverlappingPreset.maxFreq} Hz` : `${highestPriorityOverlappingPreset.freq} Hz`;
                            currentPlayingPresetSpan.classList.remove('hidden');
                            overlapMessage.classList.remove('hidden');
                            document.body.classList.add('highlight-background');
                            console.log(`Automatischer Wechsel zu: ${highestPriorityOverlappingPreset.name} (${highestPriorityOverlappingPreset.freq} Hz) nach Mindestdauer.`);
                        } else {
                            // Mindestdauer noch nicht erreicht, bleibe bei der aktuellen Frequenz
                            console.log(`Automatisches Mith√∂ren: Warten auf Mindestdauer (${playbackDurationMs / 1000} Sek.) vor Wechsel zu ${highestPriorityOverlappingPreset.name}.`);
                            // Keep overlap message and highlight active as a new potential overlap is still present
                            overlapMessage.classList.remove('hidden');
                            document.body.classList.add('highlight-background');
                        }
                    } else {
                        // Fall 3: Dieselbe Frequenz wird immer noch erkannt und wird bereits abgespielt.
                        // Der Ton l√§uft "ewig" weiter. Nur UI-Status aktualisieren.
                        overlapMessage.classList.remove('hidden'); // √úberschneidungsnachricht anzeigen
                        document.body.classList.add('highlight-background'); // Hintergrund hervorheben
                    }
                } else {
                    // Keine Frequenz wird im Mikrofon erkannt.
                    if (currentPlayingPresetFrequency) {
                        // Fall 4: Eine Frequenz wird aktuell abgespielt, aber ihre Quelle wird nicht mehr erkannt.
                        // Gem√§ss neuer Logik spielt der Ton *unbegrenzt* weiter.
                        overlapMessage.classList.add('hidden'); // √úberschneidungsnachricht ausblenden
                        document.body.classList.remove('highlight-background'); // Hintergrund-Hervorhebung entfernen
                        console.log('Automatisches Mith√∂ren: Aktuelle Frequenz nicht mehr erkannt, spielt aber weiter (gem√§ss Logik).');
                        // Hier wird stopOscillator() NICHT aufgerufen.
                    } else {
                        // Fall 5: Keine Frequenz wird erkannt und keine Frequenz wird aktuell abgespielt.
                        // UI sauber halten.
                        overlapMessage.classList.add('hidden');
                        document.body.classList.remove('highlight-background');
                    }
                }
            } else {
                // Automatisierung ist nicht aktiv ODER "Force Output" ist aktiv.
                // √úberschneidungsnachricht und Hintergrund-Hervorhebung ausblenden.
                overlapMessage.classList.add('hidden');
                document.body.classList.remove('highlight-background');

                // Wenn Automatisierung gerade deaktiviert wurde und ein Ton spielte, stoppe ihn.
                if (currentPlayingPresetFrequency && isPlaying) {
                    stopOscillator(); // Now uses smooth stop
                    currentPlayingPresetFrequency = null;
                    console.log('Automatischer Ton gestoppt, da Automatisierung deaktiviert.');
                }
            }


            if (debugActive && isMicActive && !isLogFrozen && (audioContext.currentTime * 1000 - lastLogTime) > LOG_INTERVAL_MS) {
                lastLogTime = audioContext.currentTime * 1000;
                let logEntry = `[${new Date().toLocaleTimeString()}] `;

                logEntry += `Peak: ${currentPeakFreq.toFixed(1)} Hz (${maxAmplitudeOverall.toFixed(1)} dB)`;

                const speechPresetIndex = ALL_PRESET_FREQUENCIES.findIndex(p => p.name === SPEECH_FREQUENCY_PRESET.name);
                const speechPreset = ALL_PRESET_FREQUENCIES[speechPresetIndex];
                const speechCheckbox = document.getElementById(`preset-${speechPresetIndex}`);

                if (speechPreset && speechPreset.isRange) {
                    const binWidth = audioContext.sampleRate / analyser.fftSize;
                    const minBin = Math.round(speechPreset.minFreq / binWidth);
                    const maxBin = Math.round(speechPreset.maxFreq / binWidth);
                    const actualMinBin = Math.max(0, minBin);
                    const actualMaxBin = Math.min(analyser.frequencyBinCount - 1, maxBin);
                    let speechRangeAmplitude = 0;

                    if (actualMinBin <= actualMaxBin) { // Ensure the range is valid
                        for (let i = actualMinBin; i <= actualMaxBin; i++) {
                            const value = frequencyData[i];
                            speechRangeAmplitude += value;
                        }
                        const averageSpeechAmplitude = speechRangeAmplitude / (actualMaxBin - actualMinBin + 1);
                        const speechAmplitudeDb = getAmplitudeInDb(averageSpeechAmplitude);
                        logEntry += ` | Sprache (AVG): ${speechAmplitudeDb.toFixed(1)} dB`;
                        if (speechCheckbox && speechCheckbox.checked && speechAmplitudeDb > OVERLAP_THRESHOLD_DB) {
                            logEntry += ` - DETECTED!`;
                        }
                    } else {
                        logEntry += ` | Sprache (AVG): N/A (Ung√ºltiger Frequenzbereich)`;
                    }
                } else {
                    logEntry += ` | Sprache (AVG): N/A (Preset nicht gefunden oder kein Bereich)`;
                }

                debugLog.textContent += logEntry + '\n';
                debugLog.scrollTop = debugLog.scrollHeight;
            }
        }

        /**
         * Generic listener for preset checkboxes.
         * @param {Event} event - The change event from the checkbox.
         */
        const presetCheckboxChangeListener = (event) => {
            const index = parseInt(event.target.dataset.index);
            if (event.target.checked) {
                checkedPresetIndices.add(index);
            } else {
                checkedPresetIndices.delete(index);
            }
            updateAutomationButtonState();
            updateValueBoxesVisibility();
            window.dispatchEvent(new Event("xf:ready"));
        };

        /**
         * Creates a checkbox element for a given preset.
         * Attaches the generic presetCheckboxChangeListener.
         * @param {object} preset - The preset object.
         * @param {string} checkboxColorClass - Tailwind class for checkbox color (e.g., 'text-blue-600').
         * @returns {HTMLElement} The created div element containing the checkbox and label.
         */
        function createPresetCheckbox(preset, checkboxColorClass, labelClassOverride) {
            const div = document.createElement('div');
            div.className = 'flex items-center gap-2';

            let overallIndex = -1;
            if (preset.category === "custom" && preset.customIndex !== undefined) {
                // For custom presets, find by customIndex (which should be unique)
                overallIndex = ALL_PRESET_FREQUENCIES.findIndex(p => p.category === "custom" && p.customIndex === preset.customIndex);
            } else {
                // For non-custom presets, find by name, freq, category
                overallIndex = ALL_PRESET_FREQUENCIES.findIndex(p => p.name === preset.name && p.freq === preset.freq && p.category === preset.category);
            }
            
            // Handle cases where preset might not be found (e.g., dropdown virtual presets)
            // if (overallIndex === -1) { /* error or skip */ }


            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = `form-checkbox h-4 w-4 rounded ${checkboxColorClass}`;
            checkbox.id = `preset-${overallIndex}`;
            checkbox.dataset.index = overallIndex; // Store overall index for lookup
            checkbox.checked = checkedPresetIndices.has(overallIndex); // Set initial checked state
            checkbox.setAttribute('aria-label', `${preset.name} Frequenz aktivieren`);
            checkbox.setAttribute('title', `W√§hlen Sie diese Option, um die Frequenz ${preset.name} f√ºr die Automatisierung zu √ºberwachen.`);


            const label = document.createElement('label');
            label.htmlFor = `preset-${overallIndex}`;
            const displayFreq = preset.isRange ? `${preset.minFreq}-${preset.maxFreq} Hz` : `${preset.freq} Hz`;
            label.className = (labelClassOverride && typeof labelClassOverride === 'string' && labelClassOverride.trim().length)
  ? labelClassOverride
  : 'text-gray-700 text-sm';
            label.textContent = `${preset.name} (${displayFreq})`;

            checkbox.addEventListener('change', presetCheckboxChangeListener);

            div.appendChild(checkbox);
            div.appendChild(label);

            // Add delete icon for custom frequencies
            if (preset.category === "custom") {
                const deleteIcon = document.createElement('span');
                deleteIcon.className = 'delete-icon';
                deleteIcon.textContent = '‚úñ'; // Unicode multiplication sign or 'x'
                deleteIcon.title = `L√∂schen Sie die benutzerdefinierte Frequenz '${preset.name}'`;
                deleteIcon.setAttribute('aria-label', `Frequenz ${preset.name} l√∂schen`);
                deleteIcon.dataset.customIndex = preset.customIndex; // Store original customIndex for deletion
                deleteIcon.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent checkbox from being toggled if clicking delete icon
                    // Use a confirmation dialog (custom, not alert)
                    showConfirmationDialog(`M√∂chten Sie die Frequenz '${preset.name} (${preset.freq} Hz)' wirklich l√∂schen?`, () => {
                        const indexToDelete = parseInt(e.target.dataset.customIndex);
                        deleteCustomFrequency(indexToDelete);
                    });
                });
                div.appendChild(deleteIcon);
            }

            return div;
        }

        /**
         * Renders standard presets into their container.
         * It now filters directly from the global, sorted ALL_PRESET_FREQUENCIES.
         */
        function renderStandardPresets() {
            presetFrequenciesContainer.innerHTML = ''; // Clear existing
            ALL_PRESET_FREQUENCIES.filter(p => p.category === 'standard').forEach(preset => {
                presetFrequenciesContainer.appendChild(createPresetCheckbox(preset, 'text-blue-600'));
            });
        }

        /**
         * Renders mystical frequencies into their container.
         * It now filters directly from the global, sorted ALL_PRESET_FREQUENCIES.
         */
        function renderMysticalPresets() {
            mysticalFrequenciesContainer.innerHTML = ''; // Clear existing
            ALL_PRESET_FREQUENCIES.filter(p => p.category === 'mystical').forEach(preset => {
                mysticalFrequenciesContainer.appendChild(createPresetCheckbox(preset, 'text-indigo-600'));
            });
        }

        /**
         * Renders the speech frequency preset into its container.
         * It now filters directly from the global, sorted ALL_PRESET_FREQUENCIES.
         */
        function renderSpeechPreset() {
            speechFrequencyTestContainer.innerHTML = '';
            ALL_PRESET_FREQUENCIES.filter(p => p.category === 'speech').forEach(preset => {
                speechFrequencyTestContainer.appendChild(createPresetCheckbox(preset, 'text-cyan-600', 'text-blue-800 font-medium mr-4'));
            });
        }

        /**
         * Renders custom frequencies into their container.
         * Note: This function will be called *after* ALL_PRESET_FREQUENCIES is updated
         * and filtered for category 'custom' to ensure correct indices.
         */
        function renderCustomFrequencies() {
            customFrequenciesContainer.innerHTML = ''; // Clear existing
            // Filter ALL_PRESET_FREQUENCIES for custom ones, as they now contain the correct overallIndex
            ALL_PRESET_FREQUENCIES.filter(p => p.category === 'custom').forEach(preset => {
                // For custom frequencies, use a distinct color, e.g., text-rose-600
                customFrequenciesContainer.appendChild(createPresetCheckbox(preset, 'text-rose-600'));
            });
        }

        // Global references for force mode dropdown listeners to ensure correct removal
        let forceHarmonyDropdownListener = null;
        let forceEnvironmentDropdownListener = null;

        /**
         * Initializes rendering for dropdowns (Harmony, Environment) and the speech preset.
         * Sets up their initial event listeners (for normal mode).
         */
        function initializePresetRenderers() {
            // Setup listeners for Harmony Frequencies dropdown (normal mode)
            if (enableHarmonyFreq) {
                enableHarmonyFreq.addEventListener('change', () => {
                    // This block runs ONLY if NOT in force output mode, or if the force mode listener is removed.
                    // This listener is for normal automation behavior.
                    if (!isForceOutputActive) { 
                       harmonyFrequencyDropdown.disabled = !enableHarmonyFreq.checked;
                       updateAutomationButtonState();
                       updateValueBoxesVisibility();
                    }
                });
            }
            if (harmonyFrequencyDropdown) {
                harmonyFrequencyDropdown.addEventListener('change', () => {
                    // This block runs ONLY if NOT in force output mode.
                    if (!isForceOutputActive) {
                        updateAutomationButtonState();
                        updateValueBoxesVisibility();
                    }
                });
            }

            // Setup listeners for Environment Frequencies dropdown (normal mode)
            if (enableEnvironmentFreq) {
                enableEnvironmentFreq.addEventListener('change', () => {
                    // This block runs ONLY if NOT in force output mode.
                    if (!isForceOutputActive) {
                        environmentFrequencyDropdown.disabled = !enableEnvironmentFreq.checked;
                        updateAutomationButtonState();
                        updateValueBoxesVisibility();
                    }
                });
            }
            if (environmentFrequencyDropdown) {
                environmentFrequencyDropdown.addEventListener('change', () => {
                    // This block runs ONLY if NOT in force output mode.
                    if (!isForceOutputActive) {
                        updateAutomationButtonState();
                        updateValueBoxesVisibility();
                    }
                });
            }
        }
        
        /**
         * Populates and restores selections for Harmony and Environment Dropdowns.
         * This is now separate from the main ALL_PRESET_FREQUENCIES sorting.
         */
        function populateHarmonyAndEnvironmentDropdowns() {
            const currentHarmonySelection = harmonyFrequencyDropdown ? harmonyFrequencyDropdown.value : null;
            const currentEnvironmentSelection = environmentFrequencyDropdown ? environmentFrequencyDropdown.value : null;

            if (harmonyFrequencyDropdown) {
                let sortedHarmony = [...HARMONY_FREQUENCIES];
                const sortType = sortDropdown.value;
                if (sortType === 'alphabetical') sortedHarmony.sort((a, b) => a.name.localeCompare(b.name));
                else if (sortType === 'frequency_asc') sortedHarmony.sort((a, b) => a.freq - b.freq);
                else if (sortType === 'frequency_desc') sortedHarmony.sort((a, b) => b.freq - a.freq);

                harmonyFrequencyDropdown.innerHTML = sortedHarmony.map(p => `<option value="${p.freq}">${p.name} (${p.freq} Hz)</option>`).join('');
                if (currentHarmonySelection && sortedHarmony.some(p => p.freq == currentHarmonySelection)) {
                    harmonyFrequencyDropdown.value = currentHarmonySelection;
                } else {
                    harmonyFrequencyDropdown.value = sortedHarmony.length > 0 ? sortedHarmony[0].freq : '';
                }
                // Ensure the disabled state is re-applied/restored
                harmonyFrequencyDropdown.disabled = !enableHarmonyFreq.checked;
            }

            if (environmentFrequencyDropdown) {
                let sortedEnvironment = [...ENVIRONMENT_FREQUENCIES];
                const sortType = sortDropdown.value;
                if (sortType === 'alphabetical') sortedEnvironment.sort((a, b) => a.name.localeCompare(b.name));
                else if (sortType === 'frequency_asc') sortedEnvironment.sort((a, b) => a.freq - b.freq);
                else if (sortType === 'frequency_desc') sortedEnvironment.sort((a, b) => b.freq - a.freq);

                environmentFrequencyDropdown.innerHTML = sortedEnvironment.map(p => `<option value="${p.freq}">${p.name} (${p.freq} Hz)</option>`).join('');
                if (currentEnvironmentSelection && sortedEnvironment.some(p => p.freq == currentEnvironmentSelection)) {
                    environmentFrequencyDropdown.value = currentEnvironmentSelection;
                } else {
                    environmentFrequencyDropdown.value = sortedEnvironment.length > 0 ? sortedEnvironment[0].freq : '';
                }
                // Ensure the disabled state is re-applied/restored
                environmentFrequencyDropdown.disabled = !enableEnvironmentFreq.checked;
            }
        }


        /**
         * Populates the input and output audio device dropdowns.
         */
        async function populateAudioDevices() {
            try {
                // Request media devices permissions first to ensure labels are available
                await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                const devices = await navigator.mediaDevices.enumerateDevices();

                inputDropdown.innerHTML = '';
                outputDropdown.innerHTML = '';

                let hasInput = false;
                let hasOutput = false;

                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Ger√§t (${device.kind})`;
                    option.setAttribute('title', `Audio ${device.kind === 'audioinput' ? 'Eingang' : 'Ausgang'}: ${device.label || `Ger√§t (${device.kind})`}`);

                    if (device.kind === 'audioinput') {
                        inputDropdown.appendChild(option);
                        hasInput = true;
                    } else if (device.kind === 'audiooutput') {
                        outputDropdown.appendChild(option);
                        hasOutput = true;
                    }
                });

                if (!hasInput) {
                    inputDropdown.innerHTML = '<option value="">Keine Eingabeger√§te gefunden</option>';
                    inputDropdown.setAttribute('title', 'Keine Audio-Eingabeger√§te verf√ºgbar.');
                }
                if (!hasOutput) {
                    outputDropdown.innerHTML = '<option value="">Keine Ausgabeger√§te gefunden</option>';
                    outputDropdown.setAttribute('title', 'Keine Audio-Ausgabeger√§te gefunden</option>');
                }

                inputDropdown.disabled = true;
                outputDropdown.disabled = true;

                console.log('Audio-Ger√§te geladen.');

            } catch (err) {
                console.error('Fehler beim Laden der Audio-Ger√§te:', err);
                inputDropdown.innerHTML = '<option value="">Zugriff verweigert/Fehler beim Laden</option>';
                outputDropdown.innerHTML = '<option value="">Zugriff verweigert/Fehler beim Laden</option>';
                inputDropdown.setAttribute('title', 'Fehler beim Laden der Eingabeger√§te oder Zugriff verweigert.');
                outputDropdown.setAttribute('title', 'Fehler beim Laden der Ausgabeger√§te oder Zugriff verweigert.');
            }
        }

        /**
         * Calculates the Root Mean Square (RMS) of audio data.
         * @param {Uint8Array} data - The time domain data from analyser.getByteTimeDomainData().
         * @returns {number} The RMS value (0-1).
         */
        function calculateRMS(data) {
            let sumSquares = 0;
            for (let i = 0; i < data.length; i++) {
                const value = (data[i] - 128) / 128; // Normalize to -1 to 1
                sumSquares += value * value;
            }
            return Math.sqrt(sumSquares / data.length);
        }

        /**
         * Shows a custom confirmation dialog.
         * @param {string} message - The message to display.
         * @param {Function} onConfirm - Callback for confirmation.
         * @param {Function} [onCancel] - Callback for cancellation.
         */
        function showConfirmationDialog(message, onConfirm, onCancel = () => {}) {
            const dialog = document.createElement('div');
            dialog.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
            dialog.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
                    <p class="text-lg font-semibold text-gray-800 mb-4">${message}</p>
                    <div class="flex justify-around gap-4">
                        <button id="confirmDialogBtn" class="bg-red-600 text-white py-2 px-4 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">
                            Best√§tigen
                        </button>
                        <button id="cancelDialogBtn" class="bg-gray-300 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400">
                            Abbrechen
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);

            document.getElementById('confirmDialogBtn').onclick = () => {
                onConfirm();
                document.body.removeChild(dialog);
            };
            document.getElementById('cancelDialogBtn').onclick = () => {
                onCancel();
                document.body.removeChild(dialog);
            };
        }

        /**
         * Applies or removes "Force Output" mode.
         * @param {boolean} isActive - True to activate, false to deactivate.
         */
        function applyForceOutputMode(isActive) {
            manualFrequencyInput.disabled = isActive;
            frequencyRange.disabled = isActive;
            playStopBtn.disabled = isActive;
            micGainRange.disabled = isActive;
            sensitivityRange.disabled = isActive;
            automationDurationInput.disabled = isActive;
            sortDropdown.disabled = isActive;
            
            // Disable custom frequency input fields and buttons
            customFreqNameInput.disabled = isActive;
            customFreqValueInput.disabled = isActive;
            addCustomFreqBtn.disabled = isActive;
            exportCustomFrequenciesBtn.disabled = isActive;
            importCustomFrequenciesInput.disabled = isActive;
            // Also disable the label acting as the import button
            document.querySelector('label[for="importCustomFrequenciesInput"]').classList.toggle('disabled', isActive);


            debugToggle.disabled = false;
            freezeToggle.disabled = false;

            // Get reference to the Speech Frequency Test checkbox
            const speechPresetIndex = ALL_PRESET_FREQUENCIES.findIndex(p => p.name === SPEECH_FREQUENCY_PRESET.name && p.category === 'speech');
            const speechCheckbox = document.getElementById(`preset-${speechPresetIndex}`);

            // Get all dynamically inserted preset checkboxes (standard, mystical, custom)
            const allDynamicallyInsertedCheckboxes = Array.from(document.querySelectorAll('#presetFrequenciesContainer input[type="checkbox"], #mysticalFrequenciesContainer input[type="checkbox"], #customFrequenciesContainer input[type="checkbox"]'));

            // Combine all checkboxes that *will* be force-controlled (excluding speech initially, it's re-added below)
            const allForceSelectableCheckboxes = [...allDynamicallyInsertedCheckboxes, enableHarmonyFreq, enableEnvironmentFreq].filter(Boolean);


            if (isActive) {
                stopAutomation();
                stopOscillator();
                if (isMicActive) {
                    toggleMicrophone();
                }
                toggleAutomationBtn.disabled = true;
                
                recordBtn.disabled = true;
                playBtn.disabled = true;
                forcePassthroughCheckbox.disabled = true;
                forcePassthroughCheckbox.checked = false;

                stopSpectrumVisualization();

                // Clear checkedPresetIndices as only one will be active in force mode
                checkedPresetIndices.clear();

                // Disable Speech Frequency Test checkbox and ensure it's unchecked
                if (speechCheckbox) {
                    speechCheckbox.disabled = true;
                    speechCheckbox.checked = false;
                    // Remove its generic listener to prevent unexpected behavior while disabled
                    speechCheckbox.removeEventListener('change', presetCheckboxChangeListener);
                }

                // Apply force mode specific listeners to other checkboxes
                allForceSelectableCheckboxes.forEach(checkbox => {
                    // Temporarily remove the generic change listener
                    checkbox.removeEventListener('change', presetCheckboxChangeListener);
                    checkbox.checked = false; // Ensure they start unchecked
                    checkbox.disabled = false; // Make them clickable

                    // Disable delete icons for custom frequencies in force mode
                    const parentDiv = checkbox.closest('div.flex.items-center.gap-2');
                    const deleteIcon = parentDiv ? parentDiv.querySelector('.delete-icon') : null;
                    if (deleteIcon) deleteIcon.style.pointerEvents = 'none';

                    const forceListener = async (event) => {
                        await initAudioContext();
                        if (!audioContext || audioContext.state !== 'running') return;

                        if (event.target.checked) {
                            // Uncheck all other force-selectable checkboxes
                            allForceSelectableCheckboxes.forEach(otherCheckbox => {
                                if (otherCheckbox !== checkbox && otherCheckbox.checked) {
                                    otherCheckbox.checked = false;
                                    // Disable their respective dropdown if it was active
                                    if (otherCheckbox === enableHarmonyFreq && harmonyFrequencyDropdown) harmonyFrequencyDropdown.disabled = true;
                                    if (otherCheckbox === enableEnvironmentFreq && environmentFrequencyDropdown) environmentFrequencyDropdown.disabled = true;
                                }
                            });
                            
                            // Stop any currently forced preset before starting a new one
                            stopOscillator();

                            // Start oscillator for the newly checked item
                            let selectedPreset = null;
                            if (checkbox === enableHarmonyFreq) {
                                if (harmonyFrequencyDropdown) harmonyFrequencyDropdown.disabled = false; // Enable dropdown
                                selectedPreset = { 
                                    name: harmonyFrequencyDropdown.selectedOptions.length > 0 ? harmonyFrequencyDropdown.selectedOptions[0].textContent : "Harmonie Frequenz", 
                                    freq: parseFloat(harmonyFrequencyDropdown.value), 
                                    isDropdown: true, 
                                    elementId: 'enableHarmonyFreq' 
                                };
                                startOscillator(selectedPreset.freq);
                            } else if (checkbox === enableEnvironmentFreq) {
                                if (environmentFrequencyDropdown) environmentFrequencyDropdown.disabled = false; // Enable dropdown
                                selectedPreset = { name: environmentFrequencyDropdown.selectedOptions.length > 0 ? environmentFrequencyDropdown.selectedOptions[0].textContent : "Umwelt Frequenz", freq: parseFloat(environmentFrequencyDropdown.value), isDropdown: true, elementId: 'enableEnvironmentFreq' };
                                startOscillator(selectedPreset.freq);
                            } else { // It's one of the static presets (Standard, Mystical, Custom)
                                const index = parseInt(checkbox.dataset.index);
                                selectedPreset = ALL_PRESET_FREQUENCIES[index];
                                if (selectedPreset) {
                                    startOscillator(selectedPreset.freq);
                                }
                                // Ensure dropdowns remain disabled if a static preset is checked
                                if (enableHarmonyFreq) harmonyFrequencyDropdown.disabled = true;
                                if (enableEnvironmentFreq) environmentFrequencyDropdown.disabled = true;
                            }
                            currentForcedPreset = selectedPreset; // Set the current forced preset
                            // Update checkedPresetIndices for force mode (only the selected one is relevant)
                            checkedPresetIndices.clear(); // Clear all
                            if (selectedPreset && selectedPreset.isDropdown) {
                                const idx = ALL_PRESET_FREQUENCIES.findIndex(p => p.id === selectedPreset.elementId);
                                if (idx !== -1) checkedPresetIndices.add(idx);
                            } else if (selectedPreset && checkbox.dataset.index !== undefined) {
                                checkedPresetIndices.add(parseInt(checkbox.dataset.index));
                            }

                        } else { // Current checkbox is being unchecked
                            let shouldStopOscillator = true;
                            // Check if any other force-selectable checkbox is still checked
                            if (allForceSelectableCheckboxes.some(otherCheckbox => otherCheckbox.checked)) {
                                shouldStopOscillator = false; // Another one is checked, don't stop
                            }

                            if (shouldStopOscillator) {
                                stopOscillator();
                                currentForcedPreset = null;
                            }
                            // Disable dropdown if its enable checkbox is unchecked
                            if (checkbox === enableHarmonyFreq) harmonyFrequencyDropdown.disabled = true;
                            if (checkbox === enableEnvironmentFreq) environmentFrequencyDropdown.disabled = true;

                            // Remove from checkedPresetIndices
                            const index = parseInt(checkbox.dataset.index);
                            if (!isNaN(index)) checkedPresetIndices.delete(index);
                            if (checkbox === enableHarmonyFreq) checkedPresetIndices.delete(ALL_PRESET_FREQUENCIES.findIndex(p => p.id === 'enableHarmonyFreq'));
                            if (checkbox === enableEnvironmentFreq) checkedPresetIndices.delete(ALL_PRESET_FREQUENCIES.findIndex(p => p.id === 'enableEnvironmentFreq'));
                        }
                        updateValueBoxesVisibility(); // Update debug display
                    };
                    checkbox.addEventListener('change', forceListener);
                    forceModeListeners.set(checkbox.id, forceListener); // Store listener for later removal
                });

                // Add force mode listeners for dropdowns (for when the DROPDOWN VALUE changes)
                if (harmonyFrequencyDropdown) {
                     forceHarmonyDropdownListener = async () => {
                         await initAudioContext();
                         if (audioContext && audioContext.state === 'running') {
                             stopOscillator(); // Stop any previous forced preset
                             startOscillator(parseFloat(harmonyFrequencyDropdown.value));
                             currentForcedPreset = { 
                                name: harmonyFrequencyDropdown.selectedOptions.length > 0 ? harmonyFrequencyDropdown.selectedOptions[0].textContent : "Harmonie Frequenz", 
                                freq: parseFloat(harmonyFrequencyDropdown.value), 
                                isDropdown: true, 
                                elementId: 'enableHarmonyFreq' 
                             };
                             updateValueBoxesVisibility();
                         }
                     };
                     harmonyFrequencyDropdown.addEventListener('change', forceHarmonyDropdownListener);
                     forceModeListeners.set('harmony-dropdown-change-force-listener', forceHarmonyDropdownListener);
                }
                if (environmentFrequencyDropdown) {
                     forceEnvironmentDropdownListener = async () => {
                         await initAudioContext();
                         if (audioContext && audioContext.state === 'running') {
                             stopOscillator(); // Stop any previous forced preset
                             startOscillator(parseFloat(environmentFrequencyDropdown.value));
                             currentForcedPreset = { name: environmentFrequencyDropdown.selectedOptions.length > 0 ? environmentFrequencyDropdown.selectedOptions[0].textContent : "Umwelt Frequenz", freq: parseFloat(environmentFrequencyDropdown.value), isDropdown: true, elementId: 'enableEnvironmentFreq' };
                             updateValueBoxesVisibility();
                         }
                     };
                     environmentFrequencyDropdown.addEventListener('change', forceEnvironmentDropdownListener);
                     forceModeListeners.set('environment-dropdown-change-force-listener', forceEnvironmentDropdownListener);
                }


            } else { // isActive is FALSE (exiting force output mode)
                stopOscillator();
                currentForcedPreset = null;
                updateAutomationButtonState();

                recordBtn.disabled = !isMicActive;
                playBtn.disabled = !recordedBlob;
                forcePassthroughCheckbox.disabled = !isMicActive;
                sortDropdown.disabled = false; // Re-enable sort dropdown

                if (debugActive && isMicActive) {
                    startSpectrumVisualization();
                }

                // Clear checkedPresetIndices upon exiting force mode
                checkedPresetIndices.clear();

                // Re-enable Speech Frequency Test checkbox and re-attach generic listener
                if (speechCheckbox) {
                    speechCheckbox.disabled = false;
                    speechCheckbox.addEventListener('change', presetCheckboxChangeListener); // Re-attach generic listener
                }

                allForceSelectableCheckboxes.forEach(checkbox => {
                    // Remove force mode listener if it exists
                    const forceListener = forceModeListeners.get(checkbox.id);
                    if (forceListener) {
                        checkbox.removeEventListener('change', forceListener);
                        forceModeListeners.delete(checkbox.id);
                    }
                    // Re-attach generic listener
                    checkbox.addEventListener('change', presetCheckboxChangeListener);
                    checkbox.disabled = false; // Ensure they are re-enabled
                    // Their checked state is managed by checkedPresetIndices and the rendering functions

                    // Re-enable delete icons for custom frequencies
                    const parentDiv = checkbox.closest('div.flex.items-center.gap-2');
                    const deleteIcon = parentDiv ? parentDiv.querySelector('.delete-icon') : null;
                    if (deleteIcon) deleteIcon.style.pointerEvents = 'auto';
                });

                // Remove dropdown force change listeners and re-attach normal listeners if needed
                if (harmonyFrequencyDropdown && forceModeListeners.has('harmony-dropdown-change-force-listener')) {
                    harmonyFrequencyDropdown.removeEventListener('change', forceModeListeners.get('harmony-dropdown-change-force-listener'));
                    forceModeListeners.delete('harmony-dropdown-change-force-listener');
                }
                if (environmentFrequencyDropdown && forceModeListeners.has('environment-dropdown-change-force-listener')) {
                    environmentFrequencyDropdown.removeEventListener('change', forceModeListeners.get('environment-dropdown-change-force-listener'));
                    forceModeListeners.delete('environment-dropdown-change-force-listener');
                }
                // The dropdown's disabled state is controlled by its checkbox's state in normal mode
                if (enableHarmonyFreq) harmonyFrequencyDropdown.disabled = !enableHarmonyFreq.checked;
                if (enableEnvironmentFreq) environmentFrequencyDropdown.disabled = !enableEnvironmentFreq.checked;
            }

            updateValueBoxesVisibility(); // Call again for final state
            updateMicGainVisualizerState();
            console.log(`Force Output Mode: ${isActive ? 'Aktiviert' : 'Deaktiviert'}`);
        }

        /**
         * Updates the state and text of the automation toggle button.
         */
        function updateAutomationButtonState() {
            if (isForceOutputActive) {
                toggleAutomationBtn.disabled = true;
                toggleAutomationBtn.textContent = 'Automatisches Mith√∂ren starten';
                toggleAutomationBtn.setAttribute('title', 'Automatisches Mith√∂ren im Force Output Modus deaktiviert.');
                toggleAutomationBtn.setAttribute('aria-label', 'Automatisches Mith√∂ren kann im Force Output Modus nicht gestartet werden.');
                return;
            }

            // Get all preset checkboxes (standard, mystical, custom)
            const allPresetCheckboxes = Array.from(document.querySelectorAll('#presetFrequenciesContainer input[type="checkbox"], #mysticalFrequenciesContainer input[type="checkbox"], #customFrequenciesContainer input[type="checkbox"]'));
            const anyPresetChecked = allPresetCheckboxes.some(cb => cb.checked);
            
            const isHarmonyFreqChecked = enableHarmonyFreq ? enableHarmonyFreq.checked : false;
            const isEnvironmentFreqChecked = enableEnvironmentFreq ? enableEnvironmentFreq.checked : false;

            const anyAutomationActive = anyPresetChecked || isHarmonyFreqChecked || isEnvironmentFreqChecked;

            if (isAutomationActive) {
                if (!anyAutomationActive) {
                    console.log('Automatisches Mith√∂ren gestoppt, da keine Frequenzen mehr ausgew√§hlt sind.');
                    stopAutomation();
                    return;
                }
                toggleAutomationBtn.disabled = false;
                toggleAutomationBtn.textContent = 'Automatisches Mith√∂ren stoppen';
                toggleAutomationBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'focus:ring-yellow-300');
                toggleAutomationBtn.classList.add('bg-red-600', 'hover:bg-red-700', 'focus:ring-red-300');
                toggleAutomationBtn.setAttribute('title', 'Stoppt die automatische Frequenzerkennung und -wiedergabe.');
                toggleAutomationBtn.setAttribute('aria-label', 'Automatisches Mith√∂ren stoppen.');

            } else {
                toggleAutomationBtn.disabled = !anyAutomationActive;
                toggleAutomationBtn.textContent = 'Automatisches Mith√∂ren starten';
                toggleAutomationBtn.classList.remove('bg-red-600', 'hover:bg-red-700', 'focus:ring-red-300');
                toggleAutomationBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700', 'focus:ring-yellow-300');
                toggleAutomationBtn.setAttribute('title', 'Startet die automatische Frequenzerkennung und -wiedergabe.');
                toggleAutomationBtn.setAttribute('aria-label', 'Automatisches Mith√∂ren starten.');
            }
            updateValueBoxesVisibility();
        }

        /**
         * Controls the visibility and content of the "Ist-Wert" und "Zielwert" display boxes.
         */
        function updateValueBoxesVisibility() {
            // Get all preset checkboxes (standard, mystical, speech, custom) and filter for checked ones
            const checkedCheckboxes = Array.from(document.querySelectorAll('#presetFrequenciesContainer input[type="checkbox"], #mysticalFrequenciesContainer input[type="checkbox"], #speechFrequencyTestContainer input[type="checkbox"], #customFrequenciesContainer input[type="checkbox"]'))
                                             .filter(checkbox => checkbox.checked);
            
            const isHarmonyFreqChecked = enableHarmonyFreq ? enableHarmonyFreq.checked : false;
            const isEnvironmentFreqChecked = enableEnvironmentFreq ? enableEnvironmentFreq.checked : false;

            const shouldBeVisible = debugActive && isMicActive && !isLogFrozen && !isForceOutputActive;

            // Determine target frequency display based on active automation mode
            let targetText = 'N/A';
            let showTargetBox = false;

            if (shouldBeVisible) {
                let activeFrequencies = [];

                checkedCheckboxes.forEach(checkbox => {
                    const index = parseInt(checkbox.dataset.index);
                    const preset = ALL_PRESET_FREQUENCIES[index];
                    if (preset) {
                        activeFrequencies.push(preset.isRange ? `${preset.minFreq}-${preset.maxFreq} Hz` : `${preset.freq} Hz`);
                    }
                });

                if (isHarmonyFreqChecked) {
                    const freq = parseFloat(harmonyFrequencyDropdown.value);
                    if (!isNaN(freq)) {
                        activeFrequencies.push(`${freq.toFixed(1)} Hz (Harmonie)`);
                    }
                }
                if (isEnvironmentFreqChecked) {
                    const freq = parseFloat(environmentFrequencyDropdown.value);
                    if (!isNaN(freq)) {
                        activeFrequencies.push(`${freq.toFixed(1)} Hz (Umwelt)`);
                    }
                }

                if (activeFrequencies.length > 0) {
                    targetText = activeFrequencies.join(' & ');
                    showTargetBox = true;
                }
            } else if (isForceOutputActive && currentForcedPreset) { // Show target in force output mode
                targetText = currentForcedPreset.isRange ? 
                                `${currentForcedPreset.minFreq}-${currentForcedPreset.maxFreq} Hz` : 
                                `${currentForcedPreset.freq} Hz`;
                showTargetBox = true;
            }


            // Update visibility and text
            if (debugActive && isMicActive && !isLogFrozen && showTargetBox) {
                currentFreqDisplay.classList.remove('hidden');
                targetFreqDisplay.classList.remove('hidden');
                targetFreqValueSpan.textContent = targetText;
            } else {
                currentFreqDisplay.classList.add('hidden');
                targetFreqDisplay.classList.add('hidden');
                currentFreqValueSpan.textContent = 'N/A';
                targetFreqValueSpan.textContent = 'N/A';
            }
        }


        /**
         * Starts the automatic frequency assistant.
         */
        async function startAutomation() {
            if (isForceOutputActive) {
                console.log('Automatischer Frequenz-Assistent ist im "Force Output" Modus deaktiviert.');
                return;
            }

            // Get all preset checkboxes (standard, mystical, speech, custom)
            const allPresetCheckboxes = Array.from(document.querySelectorAll('#presetFrequenciesContainer input[type="checkbox"], #mysticalFrequenciesContainer input[type="checkbox"], #speechFrequencyTestContainer input[type="checkbox"], #customFrequenciesContainer input[type="checkbox"]'));
            const anyPresetChecked = allPresetCheckboxes.some(cb => cb.checked);

            const isHarmonyFreqChecked = enableHarmonyFreq ? enableHarmonyFreq.checked : false;
            const isEnvironmentFreqChecked = enableEnvironmentFreq ? enableEnvironmentFreq.checked : false;


            if (!anyPresetChecked && !isHarmonyFreqChecked && !isEnvironmentFreqChecked) {
                console.log('Bitte w√§hlen Sie mindestens eine Frequenz f√ºr die Automatisierung aus.');
                updateAutomationButtonState();
                return;
            }

            micWasInitiallyOffBeforeAutomation = !isMicActive;

            if (!isMicActive) {
                await toggleMicrophone(); 
                if (!isMicActive) {
                    console.error('Automatisierung konnte nicht gestartet werden: Mikrofonzugriff fehlgeschlagen.');
                    updateAutomationButtonState();
                    return;
                }
            }
            isAutomationActive = true;
            updateAutomationButtonState();
            console.log('Automatischer Frequenz-Assistent gestartet.');
        }

        /**
         * Stops the automatic frequency assistant.
         */
        function stopAutomation() {
            isAutomationActive = false;
            updateAutomationButtonState();

            stopOscillator(); // Now uses smooth stop
            currentPlayingPresetFrequency = null;
            playbackStartedAt = 0;

            currentPlayingPresetSpan.classList.add('hidden');
            overlapMessage.classList.add('hidden'); // Ensure overlap message is hidden on stop
            document.body.classList.remove('highlight-background');

            if (micWasInitiallyOffBeforeAutomation && isMicActive) {
                toggleMicrophone();
            }
            micWasInitiallyOffBeforeAutomation = false;
            console.log('Automatischer Frequenz-Assistent gestoppt.');
        }

        /**
         * Starts audio recording for a fixed duration.
         */
        async function startRecording() {
            await initAudioContext(); // Ensure AudioContext is running
            if (!audioContext || audioContext.state !== 'running') {
                console.error("AudioContext ist nicht bereit f√ºr Aufnahme.");
                return;
            }

            if (!isMicActive) {
                console.log("Bitte schalten Sie zuerst das Mikrofon ein, um aufzuzeichnen.");
                return;
            }

            recordBtn.disabled = true;
            playBtn.disabled = true;
            micToggleBtn.disabled = true;
            toggleAutomationBtn.disabled = true;
            forceOutputToggle.disabled = true;
            forcePassthroughCheckbox.disabled = true;

            recordBtn.classList.add('recording');
            recordBtn.querySelector('span:first-child').textContent = 'üî¥ Aufnahme l√§uft...';
            recordBtn.setAttribute('title', 'Aufnahme l√§uft...');
            recordBtn.setAttribute('aria-label', 'Audioaufnahme l√§uft, bitte warten.');


            audioChunks = [];
            
            if (recordedBlobUrl) {
                URL.revokeObjectURL(recordedBlobUrl);
                recordedBlobUrl = null;
            }
            recordedBlob = null;
            
            playButtonCurrentBaseText = 'File abspielen';
            playBtn.querySelector('span:first-child').textContent = `‚ñ∂Ô∏è ${playButtonCurrentBaseText}`;


            const destinationNode = audioContext.createMediaStreamDestination();
            micInputGainNode.connect(destinationNode);

            mediaRecorder = new MediaRecorder(destinationNode.stream);

            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
                recordedBlob = new Blob(audioChunks, { type: 'audio/webm' });
                recordedBlobUrl = URL.createObjectURL(recordedBlob);
                console.log('Aufnahme beendet. Blob erstellt:', recordedBlob);
                console.log('Aufnahme beendet. Datei bereit zur Wiedergabe.');
                
                recordBtn.classList.remove('recording');
                recordBtn.querySelector('span:first-child').textContent = '‚è∫Ô∏è 5 Sek. Ton aufzeichnen';
                recordBtn.setAttribute('title', 'Zeichnet 5 Sekunden Audio vom Mikrofon auf.');
                recordBtn.setAttribute('aria-label', 'Audio aufzeichnen f√ºr 5 Sekunden.');
                recordBtn.disabled = false;

                micToggleBtn.disabled = false;
                updateAutomationButtonState();
                forceOutputToggle.disabled = false;
                forcePassthroughCheckbox.disabled = !isMicActive;

                playBtn.disabled = false; 
                playButtonCurrentBaseText = `File abspielen [Aufnahme (${RECORD_PLAY_DURATION_SEC} Sek.)]`;
                playBtn.querySelector('span:first-child').textContent = `‚ñ∂Ô∏è ${playButtonCurrentBaseText}`;
                playBtn.setAttribute('title', `Spielt die ${RECORD_PLAY_DURATION_SEC} Sekunden Aufnahme ab.`);
                playBtn.setAttribute('aria-label', `Abspielen der ${RECORD_PLAY_DURATION_SEC} Sekunden Aufnahme.`);


                micInputGainNode.disconnect(destinationNode);
            };

            mediaRecorder.start();
            console.log(`Aufnahme f√ºr ${RECORD_PLAY_DURATION_SEC} Sekunden gestartet...`);
            console.log('Aufnahme l√§uft...');
            startCountdown(recordCountdownSpan, RECORD_PLAY_DURATION_SEC, () => {
                if (mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                stopCountdown(recordCountdownSpan);
            });
        }

        /**
         * Resets the playback controls and re-enables relevant buttons.
         */
        function resetPlaybackControls() {
            console.log('Wiedergabe beendet (manuell gestoppt oder nat√ºrlich beendet).');
            playBtn.classList.remove('playing');
            
            playBtn.querySelector('span:first-child').textContent = `‚ñ∂Ô∏è ${playButtonCurrentBaseText}`;
            playBtn.setAttribute('title', `Spielt die ${RECORD_PLAY_DURATION_SEC} Sekunden Aufnahme ab.`);
            playBtn.setAttribute('aria-label', `Abspielen der ${RECORD_PLAY_DURATION_SEC} Sekunden Aufnahme.`);
            
            stopCountdown(playCountdownSpan); // Explicitly stop countdown here

            document.body.classList.remove('highlight-background');

            micToggleBtn.disabled = false;
            updateAutomationButtonState();
            forceOutputToggle.disabled = false;
            forcePassthroughCheckbox.disabled = !isMicActive;
            recordBtn.disabled = false;
            playBtn.disabled = !recordedBlob;
        }

        /**
         * Plays the recorded audio.
         */
        async function playRecordedAudio() {
            await initAudioContext(); // Ensure AudioContext is running
            if (!audioContext || audioContext.state !== 'running') {
                console.error("AudioContext ist nicht bereit f√ºr Wiedergabe.");
                return;
            }

            if (!recordedBlob || !recordedBlobUrl) {
                console.log("Bitte zeichnen Sie zuerst etwas auf!");
                return;
            }

            recordBtn.disabled = true;
            playBtn.disabled = true;
            micToggleBtn.disabled = true;
            toggleAutomationBtn.disabled = true;
            forceOutputToggle.disabled = true;
            forcePassthroughCheckbox.disabled = true;

            if (audioPlayer.paused) {
                console.log("Play: Starting playback...");
                audioPlayer.src = recordedBlobUrl;
                audioPlayer.currentTime = 0;
                audioPlayer.play();

                playBtn.classList.add('playing');
                playBtn.querySelector('span:first-child').textContent = '‚èØÔ∏è Abspielen stoppen';
                playBtn.setAttribute('title', 'Stoppt die Audiowiedergabe.');
                playBtn.setAttribute('aria-label', 'Audiowiedergabe stoppen.');

                document.body.classList.add('highlight-background');
                console.log('Wiedergabe gestartet...');
                startCountdown(playCountdownSpan, RECORD_PLAY_DURATION_SEC);
            } else {
                console.log("Stop: Pausing playback...");
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
                resetPlaybackControls(); // This will now correctly stop the countdown
            }
        }

        // Handle when recorded audio playback ends (either naturally or manually stopped)
        audioPlayer.onended = () => {
            console.log("Wiedergabe nat√ºrlich beendet.");
            resetPlaybackControls();
        };

        /**
         * Manages a countdown display.
         * @param {HTMLElement} spanElement - The span element to display the countdown.
         * @param {number} duration - The total duration of the countdown in seconds.
         * @param {Function} [callback] - An optional function to call when the countdown finishes.
         */
        function startCountdown(spanElement, duration, callback) {
            let currentCount = duration - 1;

            if (spanElement === recordCountdownSpan) {
                if (recordCountdownInterval) clearInterval(recordCountdownInterval);
                recordCountdownInterval = null;
            } else if (spanElement === playCountdownSpan) {
                if (playCountdownInterval) clearInterval(playCountdownInterval);
                playCountdownInterval = null;
            }

            if (currentCount >= 0) {
                spanElement.textContent = ` (${currentCount}s)`;
            } else {
                spanElement.textContent = '';
            }

            let timerId = setInterval(() => {
                currentCount--;

                if (currentCount >= 0) {
                    spanElement.textContent = ` (${currentCount}s)`;
                } else {
                    clearInterval(timerId);
                    spanElement.textContent = '';
                    if (spanElement === recordCountdownSpan) {
                        recordCountdownInterval = null;
                    } else if (spanElement === playCountdownSpan) {
                        playCountdownInterval = null;
                    }
                    if (callback) callback();
                }
            }, 1000);

            if (spanElement === recordCountdownSpan) {
                recordCountdownInterval = timerId;
            } else if (spanElement === playCountdownSpan) {
                playCountdownInterval = timerId;
            }
        }

        /**
         * Stops the active countdown for a given span element.
         * @param {HTMLElement} spanElement - The span element whose countdown should be stopped.
         */
        function stopCountdown(spanElement) {
            if (spanElement === recordCountdownSpan && recordCountdownInterval) {
                clearInterval(recordCountdownInterval);
                recordCountdownInterval = null;
                spanElement.textContent = '';
            } else if (spanElement === playCountdownSpan && playCountdownInterval) {
                clearInterval(playCountdownInterval);
                playCountdownInterval = null; 
                spanElement.textContent = '';
            }
        }

        // Event Listeners
        frequencyRange.addEventListener('input', updateFrequencyControls);
        manualFrequencyInput.addEventListener('input', updateFrequencyControls);
        manualFrequencyInput.addEventListener('change', updateFrequencyControls);

        micGainRange.addEventListener('input', () => {
            if (micInputGainNode) {
                micInputGainNode.gain.value = parseFloat(micGainRange.value);
            }
            micGainValueSpan.textContent = parseFloat(micGainRange.value).toFixed(2);
            micGainRange.setAttribute('aria-valuenow', parseFloat(micGainRange.value).toFixed(2));
        });

        sensitivityRange.addEventListener('input', () => {
            OVERLAP_THRESHOLD_DB = parseFloat(sensitivityRange.value);
            sensitivityValueSpan.textContent = `${OVERLAP_THRESHOLD_DB}`;
            sensitivityRange.setAttribute('aria-valuenow', OVERLAP_THRESHOLD_DB);
        });
        playStopBtn.addEventListener('click', async () => {
            await initAudioContext();
            if (!audioContext || audioContext.state !== 'running') return;

            if (isForceOutputActive) {
                console.log('Der Frequenz-Generator ist im "Force Output" Modus deaktiviert.');
                return;
            }
            if (isPlaying && !currentPlayingPresetFrequency) {
                stopOscillator();
            } else if (!currentPlayingPresetFrequency) {
                startOscillator(parseFloat(manualFrequencyInput.value));
            } else {
                console.log('Die Automatisierung spielt bereits eine Frequenz ab. Bitte stoppen Sie diese zuerst, um manuell abzuspielen.');
            }
        });
        micToggleBtn.addEventListener('click', async () => {
            await initAudioContext();
            if (!audioContext || audioContext.state !== 'running') return;

            if (isForceOutputActive) {
                console.log('Das Mikrofon kann im "Force Output" Modus nicht manuell gesteuert werden. Es wird bei Bedarf automatisch gestoppt.');
                return;
            }
            toggleMicrophone();
        });

        // Combined automation button click listener
        toggleAutomationBtn.addEventListener('click', async () => {
            await initAudioContext();
            if (!audioContext || audioContext.state !== 'running') return;

            if (isAutomationActive) {
                stopAutomation();
            } else {
                startAutomation();
            }
        });

        // Debug toggle event listener
        debugToggle.addEventListener('change', async () => {
            debugActive = debugToggle.checked;
            if (debugActive) {
                debugLog.classList.remove('hidden');
                debugLog.textContent = '--- Debug-Log gestartet ---\n';
                lastLogTime = 0;
                
                await initAudioContext();
                if (!audioContext || audioContext.state !== 'running') return;

                if (!isMicActive && !isForceOutputActive) {
                    toggleMicrophone();
                } else if (isMicActive) {
                    startSpectrumVisualization();
                }
            } else {
                debugLog.classList.add('hidden');
                debugLog.textContent = '';
                if (!isAutomationActive && isMicActive) {
                    stopSpectrumVisualization();
                }
            }
            updateValueBoxesVisibility();
        });

        // Freeze toggle event listener
        freezeToggle.addEventListener('change', async () => {
            isLogFrozen = freezeToggle.checked;
            if (isLogFrozen) {
                console.log('Debug-Log eingefroren.');
            } else {
                console.log('Debug-Log fortgesetzt.');
                lastLogTime = 0;

                await initAudioContext();
                if (!audioContext || audioContext.state !== 'running') return;

                if (debugActive && isMicActive) {
                    startSpectrumVisualization();
                }
            }
            updateValueBoxesVisibility();
        });

        // Force Output toggle event listener
        forceOutputToggle.addEventListener('change', async () => {
            await initAudioContext();
            if (!audioContext || audioContext.state !== 'running') return;

            isForceOutputActive = forceOutputToggle.checked;
            applyForceOutputMode(isForceOutputActive);
        });

        // Recording and Playback Event Listeners
        recordBtn.addEventListener('click', startRecording);
        playBtn.addEventListener('click', playRecordedAudio);

        // Force Passthrough Checkbox Listener
        forcePassthroughCheckbox.addEventListener('change', async () => {
            await initAudioContext();
            if (!audioContext || audioContext.state !== 'running') {
                console.log('Audio-Kontext ist noch nicht bereit. Bitte klicken Sie zuerst auf "Mikrofon starten".');
                forcePassthroughCheckbox.checked = false;
                return;
            }
            
            if (!isMicActive) {
                console.log('Bitte schalten Sie Sie zuerst das Mikrofon ein, um Passthrough zu aktivieren.');
                forcePassthroughCheckbox.checked = false;
                return;
            }

            if (forcePassthroughCheckbox.checked) {
                micInputGainNode.connect(audioContext.destination);
                console.log('Force Passthrough (Aux-OUT) aktiviert. Beachten Sie m√∂gliche Echos/Drop-Outs.');
                console.log('Mic Input Gain Node connected to AudioContext Destination (Passthrough).');
            } else {
                micInputGainNode.disconnect(audioContext.destination);
                console.log('Force Passthrough (Aux-OUT) deaktiviert.');
                console.log('Mic Input Gain Node disconnected from AudioContext Destination (Passthrough).');
            }
        });

        // Automation Duration Input Listener
        automationDurationInput.addEventListener('input', () => {
            let value = parseInt(automationDurationInput.value);
            const min = parseInt(automationDurationInput.min);
            const max = parseInt(automationDurationInput.max);

            if (isNaN(value) || value < min) {
                value = min;
            } else if (value > max) {
                value = max;
            }
            automationDurationInput.value = value;
            playbackDurationMs = value * 1000;
            
            dynamicAutomationDescriptionDuration.textContent = value; // Update the description text
            automationDurationInput.setAttribute('aria-valuenow', value);
        });

        automationDurationInput.addEventListener('change', () => {
            let value = parseInt(automationDurationInput.value);
            const min = parseInt(automationDurationInput.min);
            const max = parseInt(automationDurationInput.max);

            if (isNaN(value) || value < min) {
                value = min;
            } else if (value > max) {
                value = max;
            }
            automationDurationInput.value = value;
            playbackDurationMs = value * 1000;
            dynamicAutomationDescriptionDuration.textContent = value; // Update the description text
            automationDurationInput.setAttribute('aria-valuenow', value);
            console.log(`Automation Playback Duration set to: ${value} seconds`);
        });

        /**
         * Generic function to toggle collapsible sections.
         * @param {HTMLElement} headerElement - The header element of the collapsible section.
         * @param {HTMLElement} contentElement - The content element of the collapsible section.
         * @param {HTMLElement} arrowElement - The arrow icon element.
         */
        function setupCollapsibleSection(headerElement, contentElement, arrowElement) {
            if (headerElement && contentElement && arrowElement) {
                headerElement.addEventListener('click', () => {
                    const isHidden = contentElement.classList.toggle('hidden');
                    if (isHidden) {
                        arrowElement.textContent = '‚¨áÔ∏è'; // Down arrow when hidden
                        headerElement.setAttribute('aria-expanded', 'false');
                    } else {
                        arrowElement.textContent = '‚¨ÜÔ∏è'; // Up arrow when visible
                        headerElement.setAttribute('aria-expanded', 'true');
                    }
                });
            } else {
                console.error("One or more elements for a collapsible section not found!");
            }
        }

        // New helper to manage mic gain visualizer state
        function updateMicGainVisualizerState() {
            if (isMicActive && !isForceOutputActive) {
                micGainVisualizer.classList.remove('hidden');
            } else {
                micGainVisualizer.classList.add('hidden');
                micGainBar.style.width = '0%'; // Ensure bar is reset when hidden
            }
        }

        // --- NEU: Funktionen f√ºr Benutzerdefinierte Frequenzen ---
        /**
         * F√ºgt eine neue benutzerdefinierte Frequenz hinzu.
         */
        addCustomFreqBtn.addEventListener('click', () => {
            const name = customFreqNameInput.value.trim();
            const freq = parseFloat(customFreqValueInput.value);

            if (!name) {
                alert('Bitte geben Sie einen Namen f√ºr die Frequenz ein.');
                return;
            }
            if (isNaN(freq) || freq < 0.1 || freq > 20000) {
                alert('Bitte geben Sie eine g√ºltige Frequenz zwischen 0.1 Hz und 20000 Hz ein.');
                return;
            }

            const newCustomFreq = { name: name, freq: freq, category: "custom", customIndex: USER_DEFINED_FREQUENCIES.length };
            USER_DEFINED_FREQUENCIES.push(newCustomFreq);
            saveCustomFrequencies();
            updateAllPresetFrequenciesAndRender(); // Regenerate and re-render all presets
            
            customFreqNameInput.value = '';
            customFreqValueInput.value = '';
            console.log(`Frequenz '${name}' (${freq} Hz) hinzugef√ºgt.`);
        });

        /**
         * L√∂scht eine benutzerdefinierte Frequenz.
         * @param {number} customIndex - Der einzigartige Index der benutzerdefinierten Frequenz im USER_DEFINED_FREQUENCIES Array.
         */
        function deleteCustomFrequency(customIndex) {
            const initialLength = USER_DEFINED_FREQUENCIES.length;
            USER_DEFINED_FREQUENCIES = USER_DEFINED_FREQUENCIES.filter(f => f.customIndex !== customIndex);

            if (USER_DEFINED_FREQUENCIES.length < initialLength) {
                // Re-assign customIndex to maintain sequential order after deletion
                USER_DEFINED_FREQUENCIES.forEach((f, idx) => f.customIndex = idx);
                saveCustomFrequencies();
                updateAllPresetFrequenciesAndRender(); // Regenerate and re-render all presets
                console.log(`Benutzerdefinierte Frequenz mit customIndex ${customIndex} gel√∂scht.`);
                // The checkedPresetIndices are handled by updateAllPresetFrequenciesAndRender already
            }
        }

        /**
         * Exportiert benutzerdefinierte Frequenzen als JSON-Datei.
         */
        exportCustomFrequenciesBtn.addEventListener('click', () => {
            const dataStr = JSON.stringify(USER_DEFINED_FREQUENCIES, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const relMatch = (document.getElementById('aboutAppContent')?.textContent || '').match(/Release:\s*Frequency\s*([0-9.]+)/);
            const rel = relMatch ? relMatch[1] : '0.0.0';
            const now = new Date();
            const ts = now.getFullYear().toString() + String(now.getMonth()+1).padStart(2,'0') +
                       String(now.getDate()).padStart(2,'0') + '-' + String(now.getHours()).padStart(2,'0') +
                       String(now.getMinutes()).padStart(2,'0');
            a.download = `x-frequency-${rel}-${ts}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log('Benutzerdefinierte Frequenzen exportiert.');
        });

        /**
         * Importiert benutzerdefinierte Frequenzen aus einer JSON-Datei.
         */
        importCustomFrequenciesInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (Array.isArray(importedData) && importedData.every(f => typeof f.name === 'string' && typeof f.freq === 'number')) {
                        
                        showConfirmationDialog(`M√∂chten Sie die importierten Frequenzen zur bestehenden Liste hinzuf√ºgen oder die bestehende Liste √ºberschreiben?`, () => {
                            // Add logic for adding
                            const newFrequencies = importedData.map((f, idx) => ({ 
                                name: f.name, 
                                freq: f.freq, 
                                category: "custom", 
                                customIndex: USER_DEFINED_FREQUENCIES.length + idx 
                            }));
                            USER_DEFINED_FREQUENCIES.push(...newFrequencies);
                            saveCustomFrequencies();
                            updateAllPresetFrequenciesAndRender();
                            console.log('Benutzerdefinierte Frequenzen hinzugef√ºgt.');
                            // Clear file input to allow re-importing the same file
                            event.target.value = '';
                        }, () => { // On Cancel of "add" implies "overwrite"
                            // Overwriting
                            USER_DEFINED_FREQUENCIES = importedData.map((f, idx) => ({ 
                                name: f.name, 
                                freq: f.freq, 
                                category: "custom", 
                                customIndex: idx 
                            }));
                            saveCustomFrequencies();
                            updateAllPresetFrequenciesAndRender();
                            console.log('Benutzerdefinierte Frequenzen √ºberschrieben.');
                            // Clear file input
                            event.target.value = '';
                        });

                    } else {
                        alert('Ung√ºltiges Dateiformat. Bitte w√§hlen Sie eine JSON-Datei mit einem Array von Frequenzobjekten (Name, Frequenz).');
                        console.error('Ung√ºltiges Dateiformat f√ºr benutzerdefinierte Frequenzen:', importedData);
                        event.target.value = ''; // Clear file input
                    }
                } catch (jsonError) {
                    alert('Fehler beim Parsen der JSON-Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt.');
                    console.error('JSON-Parse-Fehler:', jsonError);
                    event.target.value = ''; // Clear file input
                }
            };
            reader.readAsText(file);
        });
        // --- ENDE: Funktionen f√ºr Benutzerdefinierte Frequenzen ---


        // Initial setup on window load
        window.onload = () => {
            const resizeCanvas = () => {
                frequencyCanvas.width = frequencyCanvas.offsetWidth;
                frequencyCanvas.height = frequencyCanvas.offsetHeight;
                if (isMicActive && animationFrameId) {
                    drawFrequencySpectrum();
                }
            };
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            loadCustomFrequencies(); // Load custom frequencies first and trigger initial render via updateAllPresetFrequenciesAndRender
            initializePresetRenderers(); // Set up dropdowns initial change listeners

            sensitivityValueSpan.textContent = `${OVERLAP_THRESHOLD_DB}`;
            populateAudioDevices();

            micGainValueSpan.textContent = parseFloat(micGainRange.value).toFixed(2);
            manualFrequencyInput.value = parseFloat(frequencyRange.value).toFixed(2);
            automationDurationInput.value = (playbackDurationMs / 1000).toFixed(0);
            dynamicAutomationDescriptionDuration.textContent = automationDurationInput.value;

            recordBtn.disabled = true;
            playBtn.disabled = !recordedBlob;
            playBtn.querySelector('span:first-child').textContent = `‚ñ∂Ô∏è ${playButtonCurrentBaseText}`;

            forcePassthroughCheckbox.disabled = true;
            
            updateMicGainVisualizerState();

            // Setup and set initial state for collapsible sections
            setupCollapsibleSection(importantFrequenciesHeader, importantFrequenciesContent, importantFrequenciesArrow);
            setupCollapsibleSection(appUsageHeader, appUsageContent, appUsageArrow);
            setupCollapsibleSection(faqHeader, faqContent, faqArrow);
            setupCollapsibleSection(linksHeader, linksContent, linksArrow);
            setupCollapsibleSection(aboutAppHeader, aboutAppContent, aboutAppArrow);

            // Ensure they are hidden on load (and set initial aria-expanded state)
            importantFrequenciesContent.classList.add('hidden');
            importantFrequenciesArrow.textContent = '‚¨áÔ∏è';
            importantFrequenciesHeader.setAttribute('aria-expanded', 'false');

            appUsageContent.classList.add('hidden');
            appUsageArrow.textContent = '‚¨áÔ∏è';
            appUsageHeader.setAttribute('aria-expanded', 'false');

            faqContent.classList.add('hidden');
            faqArrow.textContent = '‚¨áÔ∏è';
            faqHeader.setAttribute('aria-expanded', 'false');

            linksContent.classList.add('hidden');
            linksArrow.textContent = '‚¨áÔ∏è';
            linksHeader.setAttribute('aria-expanded', 'false');

            aboutAppContent.classList.add('hidden');
            aboutAppArrow.textContent = '‚¨áÔ∏è';
            aboutAppHeader.setAttribute('aria-expanded', 'false');

            // Ensure harmony/environment dropdowns are disabled initially
            if (enableHarmonyFreq) harmonyFrequencyDropdown.disabled = !enableHarmonyFreq.checked;
            if (enableEnvironmentFreq) environmentFrequencyDropdown.disabled = !enableEnvironmentFreq.checked;

            // Display browser language
            if (browserLanguageDisplay) {
                const browserLang = navigator.language || 'N/A';
                let displayLang = '';
                if (browserLang.startsWith('de')) {
                    displayLang = 'Deutsch';
                } else if (browserLang.startsWith('en')) {
                    displayLang = 'English';
                } else {
                    displayLang = browserLang; // Display actual browser language if not de/en
                }
                browserLanguageDisplay.textContent = displayLang; // Removed "Voreingestellt:" from JS
            }

            // Event listener for the sort dropdown
            sortDropdown.addEventListener('change', updateAllPresetFrequenciesAndRender);

            // Set initial aria-valuenow for sliders/inputs
            manualFrequencyInput.setAttribute('aria-valuenow', manualFrequencyInput.value);
            frequencyRange.setAttribute('aria-valuenow', frequencyRange.value);
            micGainRange.setAttribute('aria-valuenow', micGainRange.value);
            sensitivityRange.setAttribute('aria-valuenow', sensitivityRange.value);
            automationDurationInput.setAttribute('aria-valuenow', automationDurationInput.value);
            
            // Initial update of automation button and value boxes (after all setup)
            updateAutomationButtonState();
            updateValueBoxesVisibility();
            window.dispatchEvent(new Event("xf:ready"));
        };
    </script>

<script>
// xf-loader-logic (single-pass)
(function(){
  const el   = document.getElementById('appLoader');
  const text = document.getElementById('loaderText');
  const bar  = document.getElementById('loaderBar');
  if(!el || !text || !bar) return;

  const steps = [
    { p: 0.00, msg: 'Module laden‚Ä¶' },
    { p: 0.33, msg: 'Audio vorbereiten‚Ä¶' },
    { p: 0.66, msg: 'UI initialisieren‚Ä¶' }
  ];

  const start = performance.now();
  const total = 1800; // ms bis 90%
  const holdAt = 0.90;
  let finished = false;

  function setMsg(progress){
    let msg = steps[0].msg;
    for (let i=0;i<steps.length;i++){
      if (progress >= steps[i].p) msg = steps[i].msg;
    }
    text.textContent = msg;
  }

  function setBar(p){
    const clamped = Math.max(0, Math.min(1, p));
    bar.style.width = Math.round(clamped*100) + '%';
  }

  function hide(){
    if (finished) return;
    finished = true;
    el.setAttribute('hidden','');
    setTimeout(()=>{ el.remove && el.remove(); }, 700);
  }

  function finishTo100AndHide(){
    const startW = parseFloat(bar.style.width) || 90;
    const startP = startW / 100;
    const dur = 320;
    const t0 = performance.now();
    (function step2(t){
      const k = Math.min(1, (t - t0)/dur);
      const p = startP + (1 - startP)*k;
      setBar(p);
      if (k < 1) requestAnimationFrame(step2);
      else hide();
    })(performance.now());
  }

  // Animate once to 90%
  (function loop(t){
    if (finished) return;
    const k = Math.min(1, (t - start)/total);
    const p = holdAt * k;
    setBar(p);
    setMsg(p);
    if (k < 1) {
      requestAnimationFrame(loop);
    } else {
      setBar(holdAt);
    }
  })(performance.now());

  window.addEventListener('xf:ready', function(){
    text.textContent = 'Fertig.';
    finishTo100AndHide();
  }, { once:true });

  // Safety: niemals l√§nger als 12s
  setTimeout(()=>{
    if (!finished) {
      text.textContent = 'Start‚Ä¶';
      finishTo100AndHide();
    }
  }, 12000);
})();
</script>



<div id="xf-mini-toggle"><button type="button" id="xfMiniBtn" title="Diagnose ein/aus" >‚öôÔ∏é Diagnose</button></div>
<div id="xf-mini-diag" role="region" aria-label="X‚ÄëFrequency Diagnose">
  <h4>Diagnose (leicht) <button id="xfMiniClose" title="Schlie√üen" style="float:right; background:transparent; border:0; color:#bcd7ff; cursor:pointer; font-size:14px">√ó</button></h4>
  <div class="row"><div class="key">Mic Permission</div><div class="val" id="diagMicPerm">‚Äì</div></div>
  <div class="row"><div class="key">Output Device</div><div class="val" id="diagOutDev">‚Äì</div></div>
  <div class="row"><div class="key">Input Device</div><div class="val" id="diagInDev">‚Äì</div></div>
  <div class="row"><div class="key">Input Peak</div><div class="val" id="diagPeak">‚Äì dBFS</div></div>
  <div class="row"><div class="key">Release</div><div class="val" id="diagRelease">‚Äì</div></div>
  <div class="row"><div class="key">Clipping</div><div class="val"> <span id="clipDot" class="clipping-dot" aria-label="clipping"></span> </div></div>
  <div class="log" id="diagLog" aria-live="polite"></div>
</div>


<script id="diag-mini-js-13439">
(function(){
  const $ = sel => document.querySelector(sel);
  const log = (msg) => {
    const el = $("#diagLog"); if(!el) return;
    const t = new Date().toLocaleTimeString();
    el.textContent += `[${t}] ${msg}\n`; el.scrollTop = el.scrollHeight;
  };
  const diag = {
    setMicPerm(s){ const el=$("#diagMicPerm"); if(el) el.textContent = s; },
    setAC(state){ const el=$("#diagACState"); if(el) el.textContent = state; },
    setOutDev(name){ const el=$("#diagOutDev"); if(el) el.textContent = name || "default"; },
    setRelease(txt){ const el=$("#diagRelease"); if(el) el.textContent = txt; },
    clip(on){ const el=$("#clipDot"); if(el) el.style.opacity = on ? 1 : 0; }
  };
  // Sync Input/Output labels with dropdowns if present
  function syncFromDropdowns(){
    try{
      const inSel = document.querySelector('#inputDropdown');
      const outSel = document.querySelector('#outputDropdown');
      if(inSel){ const opt = inSel.options[inSel.selectedIndex]; const name=(opt?.text||opt?.label||opt?.innerText||'').trim(); if(name) { const el=$("#diagInDev"); if(el) el.textContent = name; } }
      if(outSel){ const opt = outSel.options[outSel.selectedIndex]; const name=(opt?.text||opt?.label||opt?.innerText||'').trim(); if(name) { const el=$("#diagOutDev"); if(el) el.textContent = name; } }
    }catch(e){}
  }
  ['inputDropdown','outputDropdown'].forEach(id => {
    const el = document.getElementById(id);
    if(el) el.addEventListener('change', syncFromDropdowns);
  });
  syncFromDropdowns();

  // Open/close panel; on first open, if mic permission not granted, request once
  let diagOpenedOnce = false;
  const btn = $("#xfMiniBtn"), panel = $("#xf-mini-diag"), closeBtn = $("#xfMiniClose");
  const setVisible = (on)=>{ if(panel) panel.style.display = on ? "block" : "none"; };
  if(btn && panel){
    btn.addEventListener("click", async ()=>{
      const willOpen = (panel.style.display === "none" || !panel.style.display);
      setVisible(willOpen);
      if(willOpen && !diagOpenedOnce){
        diagOpenedOnce = true;
        try {
          if(navigator.permissions && navigator.permissions.query){
            const p = await navigator.permissions.query({name:'microphone'});
            if(p.state !== 'granted'){
              await navigator.mediaDevices.getUserMedia({audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }});
            }
          } else {
            await navigator.mediaDevices.getUserMedia({audio:true});
          }
        } catch(e){ /* user may deny; it's fine */ }
        // After any attempt, refresh permission label and device labels
        try {
          if(navigator.permissions && navigator.permissions.query){
            const p2 = await navigator.permissions.query({name:'microphone'});
            diag.setMicPerm(p2.state);
          }
        } catch(e){}
        if(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices){
          try{
            const list = await navigator.mediaDevices.enumerateDevices();
            const out = list.find(d=> d.kind==='audiooutput' && d.label);
            diag.setOutDev(out?.label || 'default');
            const ins = list.filter(d=> d.kind==='audioinput' && d.label);
            const preferredIn = ins.find(d=> /default|microphone/i.test(d.label)) || ins[0];
            if(preferredIn){ const el = document.querySelector("#diagInDev"); if(el) el.textContent = preferredIn.label; }
          }catch(e){}
        }
      }
    });
  }
  if(closeBtn){ closeBtn.addEventListener("click", ()=> setVisible(false)); }
  window.addEventListener("keydown", (e)=>{ if(e.key === "Escape") setVisible(false); });

  // Build analyser for Input Peak (dBFS)
  let micStream = null, analyser = null, workBuf = null;
  async function ensureAnalyser(){
    try {
      if(!AC && window.AudioContext){ AC = new AudioContext(); window.AudioContextInstance = AC; }
      if(!micStream){
        micStream = await navigator.mediaDevices.getUserMedia({audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }});
      }
      if(AC && micStream && !analyser){
        const src = AC.createMediaStreamSource(micStream);
        analyser = AC.createAnalyser();
        analyser.fftSize = 2048;
        src.connect(analyser);
        workBuf = new Float32Array(analyser.fftSize);
      }
    } catch(e){ /* if denied, we simply skip peak display */ }
  }
  function updatePeak(){
    if(!analyser || !workBuf){ return; }
    try {
      analyser.getFloatTimeDomainData(workBuf);
      let peak = 0;
      for(let i=0;i<workBuf.length;i++){
        const v = Math.abs(workBuf[i]);
        if(v > peak) peak = v;
      }
      // Convert to dBFS (approx): 20*log10(peak)
      const db = peak > 0 ? (20*Math.log10(peak)) : -Infinity;
      const txt = (db === -Infinity) ? '‚àí‚àû dBFS' : `${db.toFixed(1)} dBFS`;
      const el = $("#diagPeak"); if(el) el.textContent = txt;
      // Clipping indicator at >= -1 dBFS (~0.891)
      diag.clip(peak >= 0.891);
    } catch(e){}
  }
  // Try to keep analyser running when panel is visible
  setInterval(async ()=>{
    if(document.querySelector('#xf-mini-diag')?.style.display === 'block'){
      await ensureAnalyser();
      updatePeak();
    }
  }, 200);


  const btn = $("#xfMiniBtn"), panel = $("#xf-mini-diag"), closeBtn = $("#xfMiniClose");
  const setVisible = (on)=>{ if(panel) panel.style.display = on ? "block" : "none"; };
  if(btn && panel){
    btn.addEventListener("click", ()=>{ setVisible(panel.style.display === "none" || !panel.style.display); });
  }
  if(closeBtn){ closeBtn.addEventListener("click", ()=> setVisible(false)); }
  window.addEventListener("keydown", (e)=>{ if(e.key === "Escape") setVisible(false); });

  try {
    const li = Array.from(document.querySelectorAll("li")).find(li => li.textContent.trim().startsWith("Release:"));
    if(li){ diag.setRelease(li.textContent.trim().replace(/^Release:\s*/,"")); }
  } catch(e){}

  if(navigator.permissions && navigator.permissions.query){
    navigator.permissions.query({name:"microphone"}).then(p => {
      diag.setMicPerm(p.state);
      p.onchange = () => diag.setMicPerm(p.state);
    }).catch(()=> diag.setMicPerm("unknown"));
  } else { diag.setMicPerm("unknown"); }

  let AC = window.AudioContextInstance || null;
  try { if(!AC && window.AudioContext) { AC = new AudioContext(); window.AudioContextInstance = AC; } } catch(e){}

  let masterGain = window.masterGain || window.gainNode || null;
  if(!masterGain && AC){
    try { masterGain = AC.createGain(); masterGain.gain.value = 0.0; masterGain.connect(AC.destination); window.masterGain = masterGain; } catch(e){}
  }

  function rampTo(target, time=0.02){
    if(!masterGain || !AC) return;
    try {
      const g = masterGain.gain;
      const now = AC.currentTime;
      const cur = g.value;
      g.setValueAtTime(cur, now);
      g.linearRampToValueAtTime(target, now + time);
    } catch(e){}
  }

  const playBtn = document.querySelector('#playButton, #btnPlay, button[data-action="play"]');
  const stopBtn = document.querySelector('#stopButton, #btnStop, button[data-action="stop"]');
  if(playBtn){ playBtn.addEventListener("click", ()=>{ try{ AC && AC.resume && AC.resume(); }catch(e){} rampTo((window.uiVolumeLinear||0.5), 0.03); log("Play ramp"); }, {capture:true}); }
  if(stopBtn){ stopBtn.addEventListener("click", ()=>{ rampTo(0.0, 0.04); log("Stop ramp"); }, {capture:true}); }

  const vol = document.querySelector('#volumeSlider, input[type="range"][name="volume"], input#gain');
  if(vol){
    vol.addEventListener("input", (e)=>{
      const max = parseFloat(e.target.max || "100");
      const v = Math.min(1, Math.max(0, (parseFloat(e.target.value)||0) / (max||100)));
      window.uiVolumeLinear = v;
      rampTo(v, 0.02);
      log(`Gain -> ${v.toFixed(3)}`);
    }, {capture:true});
  }

  setInterval(()=>{
    try {
      const v = masterGain?.gain?.value || 0;
      diag.clip(v >= 0.98);
    } catch(e){}
  }, 150);

  if(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices){
    navigator.mediaDevices.enumerateDevices().then(list=>{
      const out = list.find(d=> d.kind==="audiooutput" && d.label);
      diag.setOutDev(out?.label || "default");
      const ins = list.filter(d=> d.kind==="audioinput" && d.label);
      const preferredIn = ins.find(d=> /default|microphone/i.test(d.label)) || ins[0];
      if(preferredIn){ const el = document.querySelector("#diagInDev"); if(el) el.textContent = preferredIn.label; }
    }).catch(()=>{});
  }
})();
</script>
<script>
window.toggleXfDiag = function(force){
  try {
    var p = document.getElementById('xf-mini-diag');
    if(!p) return;
    var show = (force!==undefined) ? !!force : (p.style.display === 'none' || !p.style.display);
    p.style.display = show ? 'block' : 'none';
  } catch(e){}
};
</script>























<script id="xf-diag-1352">
(function(){
  try {
    const $  = (s)=>document.querySelector(s);
    const $$ = (s)=>Array.from(document.querySelectorAll(s));

    function getVersion(){
      const meta = document.querySelector('meta[name="app:version"]');
      if (meta && meta.content) return meta.content;
      try {
        const name = (location.href.split('/').pop()||'');
        const m = name.match(/Release[-_]?(\d+(?:\.\d+){1,3})/i);
        if (m) return "Frequency " + m[1];
      } catch(e){}
      return "Frequency 1.34.51"; // fallback
    }
    function getBuild(){
      const m = document.querySelector('meta[name="app:build"]');
      return (m && m.content) ? m.content : "";
    }

    const VERSION_TEXT = getVersion();
    const BUILD_TEXT   = getBuild();

    // --- About: set "<strong>Release:</strong> Frequency x.y.z ‚Äî Build: YYYY-MM-DD HH:MM"
    function applyAboutVersion(){
      try {
        const lis = $$("li");
        const target = lis.find(li => /^\s*Release\s*:/i.test(li.textContent||""));
        if (target){
          const buildPart = BUILD_TEXT ? " ‚Äî Build: " + BUILD_TEXT : "";
          target.innerHTML = "<strong>Release:</strong> " + VERSION_TEXT + buildPart;
        }
      } catch(e){}
    }

    // --- Hide any "Clipping" entries in mini diagnose ---
    function purgeClippingFromPanel(root){
      try {
        root = root || document;
        ["#diagClip","#clipDot"].forEach(sel=>{ const el = root.querySelector(sel); if (el) el.style.display="none"; });
        // Heuristic: any node with text "Clipping" hide its cell/row and next value sibling
        $$("*").forEach(node=>{
          try{
            const t = (node.textContent||"").trim().toLowerCase();
            if (t === "clipping" || t === "clipping:" || t === "clip"){
              node.style.display="none";
              if (node.nextElementSibling) node.nextElementSibling.style.display="none";
              const p = node.parentElement;
              if (p && /row|kv|item/i.test(p.className||"")) p.style.display="none";
            }
          }catch(_){}
        });
      } catch(_){}
    }

    // --- Mini Diagnose with live peak while open ---
    function applyMiniDiag(){
      const panel   = $("#xf-mini-diag");
      const btn     = $("#xfMiniBtn");
      const closeBtn= $("#xfMiniClose");
      if (!btn) return;

      const diagRel = $("#diagRelease");
      if (diagRel) diagRel.textContent = VERSION_TEXT;

      // shared audio state
      let AC = window.AudioContextInstance || null;
      let micStream = null, analyser = null, workBuf = null, meterTimer = null;

      function prevent(ev){ try{ ev.preventDefault(); ev.stopImmediatePropagation(); ev.stopPropagation(); }catch(_){ } }

      async function ensureAnalyser(){
        try{
          if (!AC){
            AC = (window.AudioContext? new AudioContext() : (window.webkitAudioContext? new webkitAudioContext(): null));
            if (!AC) return false;
            window.AudioContextInstance = AC;
          }
          if (!micStream){
            try {
              micStream = await navigator.mediaDevices.getUserMedia({
                audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false },
                video:false
              });
            } catch(e){ return false; }
          }
          if (!analyser){
            const src = AC.createMediaStreamSource(micStream);
            analyser = AC.createAnalyser();
            analyser.fftSize = 2048;
            src.connect(analyser);
            workBuf = new Float32Array(analyser.fftSize);
          }
          return true;
        } catch(_){ return false; }
      }

      function startMeter(){
        const peakEl = $("#diagPeak");
        if (meterTimer) return;
        meterTimer = setInterval(()=>{
          try{
            if (!analyser || !workBuf) return;
            analyser.getFloatTimeDomainData(workBuf);
            let peak=0; for (let i=0;i<workBuf.length;i++){ const v=Math.abs(workBuf[i]); if (v>peak) peak=v; }
            const db = peak>0? 20*Math.log10(peak) : -Infinity;
            if (peakEl) peakEl.textContent = (db===-Infinity? "‚àí‚àû dBFS" : db.toFixed(1)+" dBFS");
          }catch(_){}
        }, 200);
      }

      function stopMeter(){
        if (meterTimer){ clearInterval(meterTimer); meterTimer=null; }
        try{
          if (micStream){ micStream.getTracks().forEach(t=>t.stop()); }
        }catch(_){}
        micStream = null; analyser = null; workBuf = null;
      }

      async function refreshMiniDiag(){
        try {
          // Permission
          const permEl = $("#diagMicPerm");
          if (navigator.permissions && navigator.permissions.query){
            try{
              const p = await navigator.permissions.query({name:"microphone"});
              if (permEl) permEl.textContent = p.state;
            }catch{ if (permEl) permEl.textContent = "unknown"; }
          }
          // Devices
          const outEl = $("#diagOutDev");
          const inEl  = $("#diagInDev");
          try {
            try { await navigator.mediaDevices.getUserMedia({audio:true, video:false}); } catch(_){}
            const list = await navigator.mediaDevices.enumerateDevices();
            const out = list.find(d=> d.kind==='audiooutput' && d.label);
            if (outEl) outEl.textContent = out?.label || "default";
            const ins = list.filter(d=> d.kind==='audioinput' && d.label);
            const pref = ins.find(d=> /default|microphone|mikrofon/i.test(d.label)) || ins[0];
            if (inEl && pref) inEl.textContent = pref.label;
          } catch(_){}
        } catch(_){}
      }

      btn.addEventListener("click", async function(ev){
        prevent(ev);
        const isVisible = panel && getComputedStyle(panel).display !== "none";
        const willOpen = !isVisible;
        if (panel) panel.style.display = willOpen ? "block" : "none";
        if (willOpen){
          purgeClippingFromPanel(panel);
          await refreshMiniDiag();
          if (await ensureAnalyser()) startMeter();
        } else {
          stopMeter();
        }
      }, true);

      if (closeBtn){
        closeBtn.addEventListener("click", function(ev){
          prevent(ev);
          if (panel) panel.style.display="none";
          stopMeter();
        });
      }
      window.addEventListener("keydown", (e)=>{
        if (e.key==="Escape" && panel && getComputedStyle(panel).display !== "none"){
          panel.style.display="none";
          stopMeter();
        }
      });

      // Also purge Clipping on load in case the panel is initially visible
      purgeClippingFromPanel(panel||document);
    }

    function init(){
      applyAboutVersion();
      applyMiniDiag();
    }
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
    else init();
  } catch(e){ /* noop */ }
})();
</script>











<style id="xf-playfix-css">
  .xf-dup { display: none !important; }
</style>
<script id="xf-playfix-ovl17">
(function(){
  try{
    function findPlayButton(){
      return document.getElementById('playBtn')
          || document.querySelector('#playButton, #btnPlay, button[data-action="play"]');
    }
    function getAudioEl(){
      var el = document.getElementById('audioPlayer');
      if (el) return el;
      if (!window._xfOverlayAudio){ window._xfOverlayAudio = new Audio(); }
      return window._xfOverlayAudio;
    }

    function pruneDuplicates(btn, iconEl, labelEl){
      try{
        // Hide any extra spans/i with label-like text
        var labelRegex = /(File abspielen|\[Aufnahme)|(Abspielen stoppen)/i;
        Array.from(btn.querySelectorAll('span,i')).forEach(function(el){
          if (el === iconEl || el === labelEl) return;
          if (el.querySelector && el.querySelector('svg')) return;
          var t = (el.textContent||'').trim();
          if (t && labelRegex.test(t)){
            el.classList.add('xf-dup');
            el.textContent = ''; // for good measure
          }
        });
        // Clear stray text nodes anywhere under the button except inside icon/label
        var walker = document.createTreeWalker(btn, NodeFilter.SHOW_TEXT, null, false);
        var toClear = [];
        while (walker.nextNode()){
          var n = walker.currentNode;
          if (iconEl.contains(n) || labelEl.contains(n)) continue;
          if ((n.nodeValue||'').trim().length>0) toClear.push(n);
        }
        toClear.forEach(function(n){ n.nodeValue=''; });
      }catch(_){}
    }

    function scanIcon(btn){
      var icon = btn.querySelector('.xf-icon');
      if (icon) return icon;
      var cand = Array.from(btn.querySelectorAll('span,i')).find(function(s){
        if (s.classList && s.classList.contains('xf-labeltext')) return false;
        if (s.querySelector && s.querySelector('svg')) return true;
        var t = (s.textContent||'').trim();
        return t === '‚ñ∂' || t === '‚èØÔ∏è';
      });
      if (!cand){
        cand = document.createElement('span');
        btn.insertBefore(cand, btn.firstChild || null);
      }
      cand.classList.add('xf-icon');
      return cand;
    }

    function scanOrCreateLabel(btn){
      var lbl = btn.querySelector('.xf-labeltext');
      if (lbl) return lbl;
      var cands = Array.from(btn.querySelectorAll('span,i')).filter(function(s){
        return !(s.querySelector && s.querySelector('svg')) && !(s.classList && s.classList.contains('xf-icon'));
      });
      lbl = cands.find(function(s){
        var t = (s.textContent||'').trim();
        return /File abspielen|Abspielen stoppen/i.test(t);
      }) || cands.pop();
      if (!lbl){
        lbl = document.createElement('span');
        btn.appendChild(lbl);
      }
      lbl.classList.add('xf-labeltext');
      return lbl;
    }

    function ensureStructure(btn){
      var icon = scanIcon(btn);
      var label = scanOrCreateLabel(btn);
      if (!btn.dataset.xfIdleIconSnapshot){
        // Save EXACT idle icon outerHTML for pixel-identical restore
        btn.dataset.xfIdleIconSnapshot = icon.outerHTML;
      }
      pruneDuplicates(btn, icon, label);
      return {icon, label};
    }

    function restoreIdleIcon(btn, currentIcon){
      try{
        var snap = btn.dataset.xfIdleIconSnapshot;
        if (!snap) return currentIcon;
        // Replace current icon element with snapshot
        var tmp = document.createElement('span');
        tmp.innerHTML = snap;
        var restored = tmp.firstElementChild;
        if (!restored){ return currentIcon; }
        currentIcon.replaceWith(restored);
        restored.classList.add('xf-icon'); // mark for our selectors (no visual impact)
        return restored;
      }catch(_){ return currentIcon; }
    }

    function setPlayIcon(iconEl){
      // Use emoji ‚èØÔ∏è during play; style blue (emoji ignores color in some OS, but try)
      if (!(iconEl.querySelector && iconEl.querySelector('svg'))){
        iconEl.textContent = '‚èØÔ∏è';
      } else {
        iconEl.innerHTML = ''; iconEl.textContent = '‚èØÔ∏è';
      }
      try{
        iconEl.style.color = '#3b82f6';
        iconEl.classList.add('text-blue-500','fill-blue-500');
      }catch(_){}
    }

    function urlFromAudioTags(){
      try {
        var a = document.querySelector('audio[src^="blob:"], audio source[src^="blob:"]');
        if (a){
          var src = a.getAttribute('src');
          if (!src && a.tagName.toLowerCase() === 'audio') src = a.currentSrc || a.src;
          if (src && /^blob:/.test(src)) return src;
        }
      } catch(_){}
      return null;
    }
    function hasRecording(){
      try {
        return !!(window.recordedBlobUrl || (window.recordedBlob instanceof Blob) ||
                 (Array.isArray(window.recordedChunks) && window.recordedChunks.length) ||
                 (Array.isArray(window.__xf_rec_chunks) && window.__xf_rec_chunks.length) ||
                 urlFromAudioTags());
      } catch(_){ return false; }
    }
    function chunksSig(arr){
      try{
        var n = arr.length;
        var last = arr[n-1];
        var sz = last && last.size ? last.size : 0;
        var typ = last && last.type ? last.type : '';
        return n+':'+sz+':'+typ;
      }catch(_){ return ''; }
    }
    function ensureFreshRecordedUrl(forceRebuildIfString){
      var made = false;
      try {
        if (Array.isArray(window.recordedChunks) && window.recordedChunks.length){
          var sig = chunksSig(window.recordedChunks);
          if (sig && sig !== window.__xf_last_sig_rc){
            window.__xf_last_sig_rc = sig;
            if (window.recordedBlobUrl && /^blob:/.test(window.recordedBlobUrl)) {
              try { URL.revokeObjectURL(window.recordedBlobUrl); } catch(_) {}
            }
            var b = new Blob(window.recordedChunks, {type: window.recordedChunks[0].type || 'audio/webm'});
            window.recordedBlobUrl = URL.createObjectURL(b);
            made = true;
          }
        } else if (window.recordedBlob instanceof Blob){
          var sigb = 'blob:'+(window.recordedBlob.size||0)+':'+(window.recordedBlob.type||'');
          if (sigb !== window.__xf_last_sig_rb || forceRebuildIfString){
            window.__xf_last_sig_rb = sigb;
            if (window.recordedBlobUrl && /^blob:/.test(window.recordedBlobUrl)) {
              try { URL.revokeObjectURL(window.recordedBlobUrl); } catch(_) {}
            }
            window.recordedBlobUrl = URL.createObjectURL(window.recordedBlob);
            made = true;
          }
        }
      }catch(_){}
      try {
        if (Array.isArray(window.__xf_rec_chunks) && window.__xf_rec_chunks.length){
          var sig2 = chunksSig(window.__xf_rec_chunks);
          if (sig2 && sig2 !== window.__xf_last_sig_xf){
            window.__xf_last_sig_xf = sig2;
            if (window.recordedBlobUrl && /^blob:/.test(window.recordedBlobUrl)) {
              try { URL.revokeObjectURL(window.recordedBlobUrl); } catch(_) {}
            }
            var b2 = new Blob(window.__xf_rec_chunks, {type: window.__xf_rec_chunks[0].type || 'audio/webm'});
            window.recordedBlobUrl = URL.createObjectURL(b2);
            made = true;
          }
        }
      }catch(_){}
      if (!made && (!window.recordedBlobUrl || forceRebuildIfString)){
        var domUrl = urlFromAudioTags();
        if (domUrl) { window.recordedBlobUrl = domUrl; made = true; }
      }
      if (made){
        try{ document.dispatchEvent(new CustomEvent('recorded-blob-changed')); }catch(_){}
      }
      return !!window.recordedBlobUrl;
    }

    (function hookMR(){
      try {
        if (window.__xf_mr_hooked || !window.MediaRecorder) return;
        window.__xf_mr_hooked = true;
        var NativeMR = window.MediaRecorder;
        window.MediaRecorder = function(stream, options){
          var mr = new NativeMR(stream, options);
          try{
            if (!mr.__xf_patched){
              var chunks = [];
              mr.addEventListener('dataavailable', function(e){
                try { if (e && e.data && e.data.size) chunks.push(e.data); } catch(_){}
              });
              mr.addEventListener('stop', function(){
                try {
                  window.__xf_rec_chunks = chunks.slice();
                  if (chunks.length){
                    if (window.recordedBlobUrl && /^blob:/.test(window.recordedBlobUrl)){
                      try{ URL.revokeObjectURL(window.recordedBlobUrl); }catch(_){}
                    }
                    var blob = new Blob(chunks, {type: chunks[0].type || 'audio/webm'});
                    window.recordedBlobUrl = URL.createObjectURL(blob);
                    document.dispatchEvent(new CustomEvent('recorded-blob-changed'));
                  }
                } catch(_){}
              });
              mr.__xf_patched = true;
            }
          }catch(_){}
          return mr;
        };
        window.MediaRecorder.prototype = NativeMR.prototype;
      } catch(_){}
    })();

    var countdownTimer = null;
    var onTimeUpdate = null;
    var onLoadedMeta = null;
    function clearCountdown(audioEl){
      if (countdownTimer){ try{ clearInterval(countdownTimer); }catch(_){ } countdownTimer=null; }
      try{
        if (onTimeUpdate){ audioEl.removeEventListener('timeupdate', onTimeUpdate); }
        if (onLoadedMeta){ audioEl.removeEventListener('loadedmetadata', onLoadedMeta); }
      }catch(_){}
      onTimeUpdate = onLoadedMeta = null;
    }
    function remainingSeconds(audioEl){
      var dur = audioEl && isFinite(audioEl.duration) ? audioEl.duration : 5;
      var rem = dur - (audioEl.currentTime||0);
      var n = Math.max(0, Math.ceil(rem - 1.0));
      return n;
    }

    function setup(){
      var playBtn = findPlayButton();
      var audioEl = getAudioEl();
      if (!playBtn || !audioEl) return;
      var parts = ensureStructure(playBtn);
      var iconEl = parts.icon, labelEl = parts.label;

      function setIdle(){
        try{ audioEl.pause(); }catch(_){}
        try{ audioEl.currentTime = 0; }catch(_){}
        playBtn.classList.remove('playing');
        clearCountdown(audioEl);
        iconEl = restoreIdleIcon(playBtn, iconEl); // exact original idle icon
        labelEl.textContent = hasRecording() ? 'File abspielen [Aufnahme (5 Sek)]' : 'File abspielen';
        pruneDuplicates(playBtn, iconEl, labelEl);
      }

      function startCountdown(){
        clearCountdown(audioEl);
        function update(){
          if (!playBtn.classList.contains('playing')) return;
          setPlayIcon(iconEl);
          labelEl.textContent = 'Abspielen stoppen (' + remainingSeconds(audioEl) + 's)';
          pruneDuplicates(playBtn, iconEl, labelEl);
        }
        update();
        countdownTimer = setInterval(update, 250);
        onLoadedMeta = update;
        onTimeUpdate = update;
        audioEl.addEventListener('loadedmetadata', onLoadedMeta);
        audioEl.addEventListener('timeupdate', onTimeUpdate);
      }

      async function start(){
        ensureFreshRecordedUrl(false);
        if (!window.recordedBlobUrl) return false;
        async function doPlay(){
          audioEl.pause();
          audioEl.src = '';
          audioEl.load();
          audioEl.src = window.recordedBlobUrl;
          audioEl.currentTime = 0;
          await audioEl.play();
        }
        try{
          await doPlay();
        }catch(e1){
          try{
            ensureFreshRecordedUrl(true);
            if (!window.recordedBlobUrl) throw e1;
            await doPlay();
          }catch(e2){
            setIdle();
            return true;
          }
        }
        playBtn.classList.add('playing');
        startCountdown();
        return true;
      }

      function stopNow(){ setIdle(); return true; }

      setIdle();

      playBtn.addEventListener('click', function(ev){
        try{
          ev.preventDefault(); ev.stopImmediatePropagation(); ev.stopPropagation();
          var wantsStop = playBtn.classList.contains('playing');
          if (wantsStop){ stopNow(); } else { start(); }
        }catch(_){}
      }, true);

      // Observer to keep things tidy & icon identical after DOM mutations
      try{
        var mo = new MutationObserver(function(){
          var parts2 = ensureStructure(playBtn);
          iconEl = parts2.icon; labelEl = parts2.label;
          pruneDuplicates(playBtn, iconEl, labelEl);
        });
        mo.observe(playBtn, {childList:true, subtree:true, characterData:true, attributes:true});
      }catch(_){}

      audioEl.addEventListener('ended', function(){ setIdle(); });
      document.addEventListener('recorded-blob-changed', function(){ setIdle(); });
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', setup);
    } else { setup(); }
  }catch(e){ /* noop */ }
})();
</script>

<script id="xf-ovl19">
(function(){
  try{
    var playBtn = document.getElementById('playBtn');
    var recordBtn = document.getElementById('recordBtn');
    var audio = document.getElementById('audioPlayer') || window._xfOverlayAudio || null;
    if (!playBtn || !recordBtn) return;

    
    function hardStopPlayback(){
      try{
        // pause known audio handles
        var list = Array.prototype.slice.call(document.querySelectorAll('audio'));
        for (var i=0;i<list.length;i++){
          try{ list[i].pause(); }catch(_){}
          try{ list[i].currentTime = 0; }catch(_){}
          try{ list[i].src = ''; list[i].load(); }catch(_){}
        }
        // also try the known overlay audio handle
        if (window._xfOverlayAudio){
          try{ window._xfOverlayAudio.pause(); window._xfOverlayAudio.currentTime = 0; window._xfOverlayAudio.src=''; window._xfOverlayAudio.load(); }catch(_){}
        }
        // Best-effort: dispatch an app-level hint
        try{ document.dispatchEvent(new CustomEvent('xf-force-stop-playback')); }catch(_){}
      }catch(_){}
    }
var reLabel = /(File abspielen|Abspielen stoppen|\[Aufnahme|\(5\s*Sek)/i;

    function qIcon(){
      var ic = playBtn.querySelector('.xf-icon');
      if (!ic){
        ic = document.createElement('span');
        ic.className = 'xf-icon text-blue-600 fill-blue-600';
        var label = playBtn.querySelector('.xf-labeltext');
        if (label){ playBtn.insertBefore(ic, label); }
        else { playBtn.insertBefore(ic, playBtn.firstChild || null); }
      }
      return ic;
    }
    function qLabel(){
      var lb = playBtn.querySelector('.xf-labeltext');
      if (!lb){
        // pick first non-svg span/i
        var cands = playBtn.querySelectorAll('span,i');
        for (var i=0;i<cands.length;i++){
          var el = cands[i];
          if (el.classList && el.classList.contains('xf-icon')) continue;
          if (el.querySelector && el.querySelector('svg')) continue;
          lb = el; break;
        }
        if (!lb){ lb = document.createElement('span'); playBtn.appendChild(lb); }
        lb.classList.add('xf-labeltext');
      }
      return lb;
    }
    function setBluePlayIcon(ic){
      if(!ic) return;
      ic.innerHTML='';
      ic.textContent='‚ñ∂';
      ic.style.color='#1d4ed8'; // blue-700
      if (ic.classList){ ic.classList.add('text-blue-600','fill-blue-600'); }
    }
    function isPlaying(){ return playBtn.classList && playBtn.classList.contains('playing'); }

    function cleanPlayButton(){
      var ic = qIcon();
      var lb = qLabel();
      // Ensure icon contains only symbol, not label text
      var t = (ic.textContent||'').trim();
      if (reLabel.test(t) || t.length>2){ setBluePlayIcon(ic); }
      if (!ic.textContent || !ic.textContent.trim()){ setBluePlayIcon(ic); }

      // Remove duplicate label-like spans
      var nodes = playBtn.querySelectorAll('span,i');
      for (var i=0;i<nodes.length;i++){
        var el = nodes[i];
        if (el===ic || el===lb) continue;
        if (el.querySelector && el.querySelector('svg')) continue;
        var txt = (el.textContent||'').trim();
        if (txt && (txt===(lb.textContent||'').trim() || reLabel.test(txt))){
          el.textContent=''; el.classList.add('xf-dup');
        }
      }
      // Clear root text nodes
      var kids = playBtn.childNodes;
      for (var k=0;k<kids.length;k++){
        var n = kids[k];
        if (n.nodeType===3 && (n.nodeValue||'').trim().length>0){ n.nodeValue=''; }
      }
    }

    function setPlayView1(){
      var ic = qIcon(), lb = qLabel();
      setBluePlayIcon(ic);
      lb.textContent = 'File abspielen';
      playBtn.classList.remove('playing');
      if (audio){ try{ audio.pause(); audio.currentTime = 0; }catch(_){ } }
      cleanPlayButton();
    }
    function setPlayView2(){
      var ic = qIcon(), lb = qLabel();
      setBluePlayIcon(ic);
      lb.textContent = 'File abspielen [Aufnahme (5 Sek)]';
      playBtn.classList.remove('playing');
      cleanPlayButton();
    }

    // Initial cleanup
    setTimeout(cleanPlayButton, 0);

    // --- Exception A --- (immediate View 1 on record start)
    ['mousedown','touchstart','keydown','click'].forEach(function(evt){
      recordBtn.addEventListener(evt, function(){ setPlayView1(); }, true);
    });

    // When recording ends -> View 2 (poll for .recording toggle)
    var lastRec = recordBtn.classList.contains('recording');
    setInterval(function(){
      var now = recordBtn.classList.contains('recording');
      if (lastRec && !now){ setPlayView2(); }
      lastRec = now;
    }, 200);

    // --- Exception B --- (stop playback first if recording during play)
    ['click','keydown','touchstart','mousedown'].forEach(function(evt){
      recordBtn.addEventListener(evt, function(){
        if (isPlaying()){ hardStopPlayback(); setPlayView1(); }
      }, true);
    });

    // Keep tidy if app mutates the button
    try{
      var deb=null;
      var mo = new MutationObserver(function(){
        if (deb) return;
        deb = setTimeout(function(){ deb=null; cleanPlayButton(); }, 60);
      });
      mo.observe(playBtn, {childList:true, subtree:true, characterData:true});
    }catch(_){}

    // Also tidy after blob change (new recording)
    document.addEventListener('recorded-blob-changed', function(){ setPlayView2(); });

    // Safety: on window focus
    window.addEventListener('focus', cleanPlayButton);

  }catch(e){ /* noop */ }
})();
</script>

<script id="xf-ovl21">
(function(){
  try{
    // Collect AudioContexts (new + future)
    if (!window.__xf_audioContexts) window.__xf_audioContexts = [];
    function _registerCtx(ctx){
      try{
        if (ctx && window.__xf_audioContexts.indexOf(ctx) === -1){
          window.__xf_audioContexts.push(ctx);
        }
      }catch(_){}
      return ctx;
    }
    try{
      if (!window.__xf_ac_hooked && (window.AudioContext || window.webkitAudioContext)){
        window.__xf_ac_hooked = true;
        var NativeAC = window.AudioContext;
        if (NativeAC){
          var AC = function(){
            var ctx = new (Function.prototype.bind.apply(NativeAC, [null].concat([].slice.call(arguments))))();
            return _registerCtx(ctx);
          };
          AC.prototype = NativeAC.prototype;
          window.AudioContext = AC;
        }
        var NativeWAC = window.webkitAudioContext;
        if (NativeWAC){
          var WAC = function(){
            var ctx = new (Function.prototype.bind.apply(NativeWAC, [null].concat([].slice.call(arguments))))();
            return _registerCtx(ctx);
          };
          WAC.prototype = NativeWAC.prototype;
          window.webkitAudioContext = WAC;
        }
      }
    }catch(_){}

    // Provide global stop/mute helpers
    window.__xf_suspendAllContexts = function(){
      try{
        (window.__xf_audioContexts||[]).forEach(function(ctx){
          try{
            if (ctx && typeof ctx.state === 'string' && ctx.state === 'running'){
              ctx.__xf_was_running = true;
              ctx.suspend();
            }
          }catch(_){}
        });
      }catch(_){}
    };
    window.__xf_resumeSuspendedContexts = function(){
      try{
        (window.__xf_audioContexts||[]).forEach(function(ctx){
          try{
            if (ctx && ctx.__xf_was_running && ctx.state !== 'closed'){
              ctx.resume();
            }
            if (ctx) ctx.__xf_was_running = false;
          }catch(_){}
        });
      }catch(_){}
    };

    // Wire into existing handlers: record start/stop
    var recordBtn = document.getElementById('recordBtn');
    if (recordBtn){
      ['click','mousedown','touchstart','keydown'].forEach(function(evt){
        recordBtn.addEventListener(evt, function(){
          // stop any <audio> and suspend all contexts immediately
          try {
            var list = Array.prototype.slice.call(document.querySelectorAll('audio'));
            for (var i=0;i<list.length;i++){ try{ list[i].pause(); }catch(_){}
              try{ list[i].currentTime=0; }catch(_){}
              try{ list[i].src=''; list[i].load(); }catch(_){}
            }
          }catch(_){}
          if (window._xfOverlayAudio){
            try{ _xfOverlayAudio.pause(); _xfOverlayAudio.currentTime=0; _xfOverlayAudio.src=''; _xfOverlayAudio.load(); }catch(_){}
          }
          window.__xf_suspendAllContexts();
        }, true);
      });

      // Poll for recording end to resume contexts
      var lastRec = recordBtn.classList.contains('recording');
      setInterval(function(){
        var now = recordBtn.classList.contains('recording');
        if (lastRec && !now){
          // recording ended
          window.__xf_resumeSuspendedContexts();
        }
        lastRec = now;
      }, 200);
    }
  }catch(e){ /* noop */ }
})();
</script>



<script id="xf-speech-label-color">
(function(){
  try{
    function tint(){
      var root = document.getElementById('speechFrequencyTestContainer');
      if (!root) return; // do nothing if container not found
      var label = root.querySelector('label');
      if (!label) return;
      // apply Tailwind class; do not touch text or structure
      try{ label.classList.add('text-blue-600'); }catch(_){}
    }
    if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', tint); } else { tint(); }
  }catch(e){ /* noop */ }
})();
</script>

<script id="xf-version-autodetect">
(function(){
  try{
    function detectVersion(){
      try{
        var m = (location.pathname || '').match(/Release-(\d+\.\d+\.\d+)/);
        if (m && m[1]) return m[1];
      }catch(e){}
      try{
        var meta = document.querySelector('meta[name="app:version"]');
        if (meta){
          var c = meta.getAttribute('content') || '';
          var m2 = c.match(/(\d+\.\d+\.\d+)/);
          if (m2 && m2[1]) return m2[1];
        }
      }catch(e){}
      try{
        var m3 = (document.title || '').match(/Release-(\d+\.\d+\.\d+)/);
        if (m3 && m3[1]) return m3[1];
      }catch(e){}
      return null;
    }

    function applyVersion(ver){
      if (!ver) return;
      var text = 'Frequency ' + ver;
      try{ window.VERSION_TEXT = text; }catch(e){}
      try{
        var meta = document.querySelector('meta[name="app:version"]');
        if (meta){ meta.setAttribute('content', text); }
      }catch(e){}
      try{
        var scope = document.getElementById('aboutAppContent') || document;
        var candidates = scope.querySelectorAll('li, p, div, span');
        for (var i=0;i<candidates.length;i++){
          var n = candidates[i];
          var t = n.textContent || '';
          if (/^\s*Release:\s*/i.test(t)){
            n.innerHTML = n.innerHTML.replace(/Frequency\s*\d+\.\d+\.\d+/, text);
            break;
          }
        }
      }catch(e){}
    }

    function init(){
      var ver = detectVersion();
      applyVersion(ver);
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
    window.addEventListener('load', init);
  }catch(e){}
})();
</script>
</body>
</html>
