<!DOCTYPE html>
<html lang="de">
<head>
  <meta name="app:build-iso" content="2025-09-02T00:07:13+02:00">
  <meta name="app:build" content="2025-09-02 00:07">
  <meta name="app:version" content="Frequency 1.34.58">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-Frequency – Dein Frequenz-Assistent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #334155; /* Darker text */
            transition: background-color 0.5s ease-in-out; /* Smooth transition for background changes */
        }
        body.highlight-background {
            background-color: #ffe6e6; /* Light red for highlighting */
        }
        .container {
            max-width: 90%;
            margin: 0 auto;
            padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 1.5rem; /* More rounded */
            background-color: #ffffff;
            border: 1px solid #e2e8f0; /* Light border */
        }
        /* General styling for range inputs, adjusted to be more flexible */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%; /* Make them fill container width */
            height: 10px;
            background: #cbd5e1; /* Light gray track */
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: #3b82f6; /* Blue thumb */
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #60a5fa; /* Lighter blue border */
        }

        input[type="range"]::-moz-range-thumb {
            width: 25px;
            height: 25px;
            background: #3b82f6; /* Blue thumb */
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #60a5fa; /* Lighter blue border */
        }

        button {
            transition: background-color 0.2s, transform 0.1s;
        }
        button:hover {
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
        }
        canvas {
            background-color: #e2e8f0; /* Light background for canvas */
            border-radius: 0.75rem;
        }
        .loading-overlay { /* message-box-overlay removed */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            border-radius: 1.5rem;
            z-index: 10;
            text-align: center;
        }
        /* .message-box removed */
        #debugLog {
            background-color: #1f2937; /* Dark gray for log background */
            color: #d1d5db; /* Light gray text */
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            padding: 0.75rem;
            border-radius: 0.5rem;
            height: 200px;
            overflow-y: scroll;
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
            margin-bottom: 16px; /* Explicit 4mm / 16px margin */
        }
        .subtitle { /* This class is now unused with the new banner approach */
            text-align: right;
            color: #ef4444; /* Red color */
            font-size: 0.85rem;
            margin-top: -1.5rem; /* Pull it up a bit */
            margin-bottom: 1rem;
            font-weight: 600;
        }
        /* Styles for Record/Play buttons within Debug-Bereich */
        .debug-controls-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #475569; /* Darker border for debug section separator */
            width: 100%;
            align-items: center;
        }
        .debug-controls-section button {
            width: 100%; /* Make buttons full width in this section */
            font-size: 1.1rem; /* Slightly larger font */
            padding: 0.9rem 1.8rem; /* More padding */
            border-radius: 1rem; /* More rounded */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px; /* More space between icon and text */
            font-weight: 600; /* Bolder text */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); /* Subtle shadow */
        }
        .debug-controls-section button.recording {
            background-color: #dc2626; /* Red for recording */
            animation: pulse-red 1.5s infinite;
        }
        .debug-controls-section button.playing {
            background-color: #0ea5e9; /* Light blue for playing */
            animation: pulse-blue 1.5s infinite;
        }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
        }
        @keyframes pulse-blue {
            0% { box-shadow: 0 0 0 0 rgba(14, 165, 233, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(14, 165, 233, 0); }
            100% { box-shadow: 0 0 0 0 rgba(14, 165, 233, 0); }
        }
        .countdown {
            margin-left: 8px;
            font-weight: bold;
            color: #ffffff; /* Ensure countdown text is visible on colored buttons */
        }

        /* Specific styles for mic-gain-slider-row to match X-Gain 1.0 look */
        .mic-gain-slider-group {
            display: flex;
            flex-direction: column; /* Stack label/value and slider vertically */
            align-items: flex-start; /* Left-align content within this group */
            gap: 5px; /* Small gap between label group and slider */
            margin-bottom: 1rem;
            width: 100%; /* Take full width of parent to control content */
        }

        .mic-gain-label-row { /* New row for label and value */
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Left-align label and value */
            gap: 10px;
            width: 100%; /* Take full width of its parent */
        }
        .mic-gain-label-row label {
            font-size: 1.125rem; /* text-lg */
            font-weight: 500; /* font-medium */
            color: #6d28d9; /* Adjusted from text-purple-700 to match label color for clarity */
        }
        .mic-gain-label-row #micGainValue {
            font-size: 1.5rem; /* text-2xl */
            font-weight: bold; /* font-bold */
            color: #8b5cf6; /* text-purple-600 */
            width: 4rem; /* w-16 or w-24, using a fixed width for compact look */
            text-align: left; /* Aligned to left for compact look as in X-Gain */
        }
        .mic-gain-slider-group input[type="range"]#micGainRange {
            width: 100%; /* Make slider take full width of its parent group */
            /* Removed mx-4 and other horizontal margins, let parent handle spacing */
        }

        /* Adjust overall container for slider section to be narrower for this specific slider */
        /* Removed max-width and auto margins to allow content to align left */
        .mic-gain-slider-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Left-align the entire section's content */
            width: 100%;
        }


        /* Microphone Gain Visualizer Styles */
        .mic-gain-visualizer {
            width: 90%; /* Adjust width to fit within the container */
            height: 25px; /* Slightly taller */
            background-color: #cfd8dc; /* Slightly darker grey for contrast */
            border-radius: 12px; /* More rounded */
            margin: 1rem auto; /* Center it and add some vertical spacing */
            overflow: hidden; /* Ensure the bar stays within bounds */
            display: flex; /* Use flexbox to align the bar inside */
            align-items: center;
            border: 1px solid #b0bec5; /* Subtle border */
        }

        .mic-gain-bar {
            height: 100%;
            width: 0%; /* Initial width */
            background: linear-gradient(to right, #a78bfa, #8b5cf6); /* Purple gradient */
            border-radius: 12px; /* Match container */
            transition: width 0.1s ease-out; /* Slightly slower transition for smoother feel */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Subtle shadow for depth */
        }

        /* Styles for Ist-Wert/Zielwert boxes */
        .value-display-box {
            background-color: #1f2937; /* Dark background matching debug log */
            color: #d1d5db; /* Light text matching debug log */
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem; /* Slightly larger for readability */
            padding: 0.6rem 0.75rem; /* Adjusted padding */
            border-radius: 0.5rem;
            display: flex; /* Use flexbox for label and value alignment */
            justify-content: space-between; /* Space out label and value */
            align-items: center;
            width: 100%; /* Take full width within its flex-item */
            box-sizing: border-box; /* Include padding in width */
        }
        .value-display-box span.label {
            font-weight: bold;
            margin-right: 0.5rem;
            color: #9ca3af; /* Slightly lighter gray for label */
        }
        .value-display-box span.value {
            color: #a78bfa; /* Purple color for the value */
            font-size: 1.1rem; /* Prominent value */
        }

        /* New class for the value boxes container to ensure 4mm gap */
        .value-boxes-container {
            margin-top: 16px; /* 4mm vertical gap from debug log */
            display: flex;
            flex-direction: column; /* Default to column on small screens */
            gap: 16px; /* 4mm gap between boxes */
        }

        @media (min-width: 640px) { /* Tailwind's 'sm' breakpoint */
            .value-boxes-container {
                flex-direction: row; /* Row on larger screens */
            }
        }

        /* Custom styles for lists to ensure proper bullet point indentation */
        .list-outside-indent {
            list-style-position: outside;
            padding-left: 1.5rem; /* Adjust this value as needed for desired indentation */
        }

        /* Styles for collapsible section */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none; /* Prevent text selection on double click */
        }

        .toggle-icon {
            font-size: 1.5rem; /* Make icon a bit larger */
            line-height: 1; /* Adjust line height to prevent extra space */
            margin-left: 0.5rem; /* Space between title and icon */
        }
        /* Specific styling for emphasized text within FAQ */
        .faq-emphasis {
            font-weight: bold;
            color: #9c9c72; /* The new, calmer olive green */
        }

        /* Styles for the new banner */
        .banner {
            background-image: url('https://clipart.designo.ch/banner/imgbannerxfrequency.jpg');
            background-size: cover;
            background-position: center;
            height: 150px; /* Fixed height to ensure image visibility */
            color: #E2E8F0; /* Light text for contrast over dark image */
            padding: 1rem;
            border-radius: 1rem;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative; /* Needed for absolute positioning of text if desired */
            overflow: hidden; /* Ensure image doesn't spill */
        }
        .banner-title {
            font-size: 2.5rem; /* text-4xl */
            font-weight: 800; /* Extra bold */
            color: #ffffff; /* White for better contrast on image */
            line-height: 1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Text shadow for readability */
            z-index: 1; /* Ensure text is above background */
        }
        .banner-slogan {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* Semi-bold */
            color: #e0e0e0; /* Slightly off-white for slogan */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7); /* Text shadow for readability */
            z-index: 1; /* Ensure text is above background */
            margin-top: 0.5rem; /* Small gap between title and slogan */
        }

        /* Style for the delete icon */
        .delete-icon {
            cursor: pointer;
            color: #ef4444; /* Red color */
            margin-left: 0.5rem;
            font-weight: bold;
            font-size: 1rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.5rem; /* Make it a square */
            height: 1.5rem;
            border-radius: 0.25rem; /* Slightly rounded corners */
            transition: background-color 0.2s ease;
        }

        .delete-icon:hover {
            background-color: #fca5a5; /* Lighter red on hover */
            color: #b91c1c; /* Darker red for icon on hover */
        }

        /* Style for file input label */
        .file-input-label {
            background-color: #f97316; /* Orange-600 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            font-size: 1.125rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s, transform 0.1s;
        }
        .file-input-label:hover {
            background-color: #ea580c; /* Orange-700 */
            transform: translateY(-1px);
        }
        .file-input-label.disabled {
            background-color: #a3a3a3; /* Gray for disabled */
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
        }

        /* Flex container for language dropdown and display for responsive wrap */
        .language-display-container {
            display: flex;
            flex-wrap: wrap; /* Allows items to wrap to the next line */
            align-items: center;
            gap: 0.5rem; /* Small gap between elements */
        }

        /* Ensure "Voreingestellt:" and the language text can break */
        .browser-language-wrapper {
            display: flex; /* Use flex to align "Voreingestellt:" and its value */
            flex-wrap: wrap; /* Allow wrapping within this wrapper if needed */
            gap: 0.25rem; /* Smaller gap for the inline elements */
        }
        
        .browser-language-wrapper span {
            white-space: normal; /* Allow text to wrap naturally */
        }
        .browser-language-wrapper .text-gray-800 {
            white-space: nowrap; /* Keep the actual language value on one line */
        }

        @media (max-width: 640px) { /* Adjust for smaller screens like mobile */
            .language-display-container {
                flex-direction: column; /* Stack dropdown and display vertically */
                align-items: flex-start; /* Align stacked items to the left */
            }
            .browser-language-wrapper {
                margin-top: 0.5rem; /* Add some space above the wrapped language text */
            }
        }
    </style>
    <!-- Open Graph Protocol Meta Tags for Social Media Sharing -->
    <meta property="og:title" content="X-Frequency – Dein Frequenz-Assistent">
    <meta property="og:description" content="Ein innovatives Tool zur Erforschung und Anwendung von Audiofrequenzen für Wohlbefinden und technische Analyse. Automatische Frequenzerkennung und Wiedergabe.">
    <meta property="og:image" content="https://clipart.designo.ch/banner/imgpromoxfrequency.jpg">
    <meta property="og:url" content="https://x-event.designo.ch/frequency">
    <meta property="og:type" content="website">
    <meta property="og:locale" content="de_CH">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-3ZK9H57DJ2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('config', 'G-3ZK9H57DJ2');
    </script>

    <style>
    /* faq-polish-13427 */
    #faqContent .list-outside-indent { list-style-position: outside; padding-left: 1.15rem; }
    #faqContent p { margin: .35rem 0 .25rem 0; }
    #faqContent ul.list-disc li { margin: .25rem 0; }
    </style>
    

    <style>
    /* xf-loader-13430 */
    #appLoader{position:fixed;inset:0;background:radial-gradient(1200px 800px at 50% -20%,rgba(80,80,120,.18),transparent),linear-gradient(#0e0f12,#111318);display:flex;align-items:center;justify-content:center;z-index:9999;transition:opacity .35s ease}
    #appLoader[hidden]{opacity:0;pointer-events:none}
    #appLoader .card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);backdrop-filter:blur(6px);padding:18px 20px;border-radius:14px;min-width:260px;box-shadow:0 6px 26px rgba(0,0,0,.35);color:#e9eef5;text-align:center}
    #appLoader .title{font-weight:600;letter-spacing:.2px;margin-bottom:10px}
    #appLoader .bar{height:6px;background:rgba(255,255,255,.15);border-radius:999px;overflow:hidden;margin-top:8px}
    #appLoader .bar span{display:block;height:100%;width:10%;background:linear-gradient(90deg,#7aa2ff,#61d2ff);border-radius:999px;transition:width .25s ease}
    #appLoader .msg{font-size:.95rem;opacity:.9;margin-top:10px}
    @media (prefers-reduced-motion: reduce){#appLoader{transition:none}#appLoader .bar span{transition:none}}
    </style>
    

<style id="diag-mini-13439">
#xf-mini-diag{pointer-events:auto; position:fixed; right:14px; bottom:58px; background:rgba(12,18,38,.92); border:1px solid rgba(255,255,255,.1);
  padding:10px 12px; border-radius:10px; font-size:13px; line-height:1.35; color:#dfe9f7; box-shadow:0 8px 30px rgba(0,0,0,.35); width: min(340px, 92vw); display:none; z-index:9999}
#xf-mini-diag h4{margin:0 0 6px 0; font-size:13px; color:#bcd7ff}
#xf-mini-diag .row{display:flex; justify-content:space-between; gap:8px; margin:3px 0}
#xf-mini-diag .key{opacity:.75}
#xf-mini-diag .val{font-weight:600}
#xf-mini-diag .log{max-height:160px; overflow:auto; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.08); padding:6px; border-radius:8px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px}
#xf-mini-toggle{position:fixed; right:14px; bottom:14px; z-index:2147483000; pointer-events:auto}
#xf-mini-toggle button{pointer-events:auto; background:#0d1b36; border:1px solid #27426b; color:#cfe6ff; border-radius:999px; padding:8px 12px; cursor:pointer}
#xf-mini-toggle button:hover{background:#112244}
.clipping-dot{display:inline-block; width:8px; height:8px; border-radius:50%; background:#ef5350; margin-left:6px; vertical-align:middle; opacity:0; transition:opacity .15s ease}
[title]{pointer-events:auto}
</style>

</head>
<body class="min-h-screen flex items-center justify-center p-4">
  <div id="appLoader" role="status" aria-live="polite">
    <div class="card" role="group" aria-label="App wird geladen">
      <div class="title">X‑Frequency lädt…</div>
      <div class="bar"><span id="loaderBar" style="width:12%"></span></div>
      <div class="msg" id="loaderText">Module laden…</div>
    </div>
  </div>

    <div class="container relative w-full lg:w-2/3 xl:w-1/2">
        <!-- NEW: Banner with image, title, and slogan -->
        <div class="banner" role="banner" aria-label="X-Frequency App Banner mit Hintergrundbild">
            <h1 class="banner-title">X-Frequency 🎶</h1>
            <p class="banner-slogan">Dein Frequenz-Assistent</p>
        </div>

        <!-- Loading Overlay -->
        <div id="loadingOverlay" class="loading-overlay hidden" role="status" aria-live="polite">
            <p class="text-blue-600 font-semibold">Lade Audio-Kontext und Mikrofon... Bitte warten.</p>
        </div>

        <div class="mb-6 bg-blue-50 p-4 rounded-xl border border-blue-200">
            <h2 class="text-xl font-semibold mb-3 text-blue-700">🔊 Frequenz-Generator</h2>
            <div class="flex flex-col sm:flex-row items-center justify-between mb-4">
                <label for="manualFrequencyInput" class="text-lg font-medium whitespace-nowrap mr-2">Manuelle Frequenz:</label>
                <input type="number" id="manualFrequencyInput" min="20" max="20000" step="0.01" value="440.00"
                    class="text-2xl font-bold text-blue-600 w-32 text-right p-1 border border-blue-300 rounded-md bg-blue-50"
                    aria-label="Manuelle Frequenzeingabe in Hertz" title="Geben Sie eine Frequenz zwischen 20 Hz und 20000 Hz ein.">
                <input type="range" id="frequencyRange" min="20" max="20000" value="440" class="flex-grow mx-4"
                    aria-label="Frequenz-Schieberegler" title="Frequenz manuell einstellen"
                    aria-valuemin="20" aria-valuemax="20000" aria-valuenow="440">
                <span class="text-lg font-medium text-blue-700"> Hz</span>
            </div>
            <div class="grid grid-cols-1 gap-4">
                <button id="playStopBtn" class="bg-blue-600 text-white py-3 px-6 rounded-xl font-semibold text-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
                    aria-label="Frequenz abspielen oder stoppen" title="Startet oder stoppt die manuelle Frequenzwiedergabe">
                    Manuell abspielen
                </button>
            </div>
        </div>

        <div class="mb-6 bg-purple-50 p-4 rounded-xl border border-purple-200">
            <h2 class="text-xl font-semibold mb-3 text-purple-700">🎤 Frequenz-Analyse (Mikrofon)</h2>
            <div class="flex flex-col sm:flex-row items-center justify-between mb-4">
                <label for="sensitivityRange" class="text-lg font-medium whitespace-nowrap mr-2">Erkennungs-Empfindlichkeit:</label>
                <span id="sensitivityValue" class="text-2xl font-bold text-purple-600 w-24 text-right"
                    aria-live="polite" aria-label="Aktueller Wert der Erkennungs-Empfindlichkeit in Dezibel">
                    -55
                </span>
                <input type="range" id="sensitivityRange" min="-90" max="-20" value="-55" class="flex-grow mx-4"
                    aria-label="Schieberegler für Erkennungs-Empfindlichkeit" title="Stellt die Empfindlichkeit der Frequenzerkennung ein (in dB)"
                    aria-valuemin="-90" aria-valuemax="-20" aria-valuenow="-55">
                <span class="text-lg font-medium text-purple-700"> dB</span>
            </div>
            <canvas id="frequencyCanvas" class="w-full h-64 border border-purple-300"
                aria-label="Frequenzspektrum-Visualisierung" role="img" title="Zeigt das aktuelle Audiofrequenzspektrum an."></canvas>
            <div id="messageWrapper" class="min-h-[80px] text-center mt-4 mb-2 flex flex-col justify-center items-center" aria-live="polite">
                <p id="overlapMessage" class="text-red-600 font-bold text-lg hidden" aria-atomic="true">Frequenzüberschneidung erkannt! 🚨</p>
                <p id="currentPlayingPreset" class="text-green-700 font-semibold text-base hidden" aria-atomic="true">Spiele: <span id="currentPlayingPresetName"></span> (<span id="currentPlayingPresetFreq"></span> Hz)</p>
            </div>
            <p id="micPermissionWarning" class="mt-4 text-center text-orange-600 text-sm hidden" role="alert" aria-atomic="true">
                ⚠️ Mikrofonzugriff verweigert. Bitte erlauben Sie den Zugriff in Ihren Browsereinstellungen.
            </p>
        </div>

        <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-xl font-semibold text-gray-700">✨ Frequenz-Assistenten & Kategorien</h2>
                <div class="flex items-center gap-2">
                    <span class="text-lg text-gray-700" aria-hidden="true">⇅</span>
                    <select id="sortDropdown" class="rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-1 px-2 text-sm"
                        aria-label="Sortieroptionen für Frequenzen" title="Wählen Sie die Sortierreihenfolge für die Frequenzlisten.">
                        <option value="thematic">Thematisch</option>
                        <option value="alphabetical">Alphabetisch (A-Z)</option>
                        <option value="frequency_asc">Frequenz (Aufsteigend)</option>
                        <option value="frequency_desc">Frequenz (Absteigend)</option>
                    </select>
                </div>
            </div>

            <div class="mb-6 bg-yellow-50 p-4 rounded-xl border border-yellow-200">
                <h2 class="text-xl font-semibold mb-3 text-yellow-700">Automatischer Frequenz-Assistent</h2>
                <p class="text-sm text-gray-600 mb-4">Wählen Sie Frequenzen, die die App überwachen und automatisch für <span id="dynamicAutomationDescriptionDuration" aria-live="polite" aria-label="Eingestellte minimale Wiedergabedauer für die Automatisierung">10</span> Sekunden abspielen soll, wenn eine Überschneidung erkannt wird, oder so lange, bis eine neue Überschneidung festgestellt wird.</p>
                <div id="presetFrequenciesContainer" class="flex flex-col gap-3 mb-4" role="group" aria-label="Vordefinierte Standardfrequenzen">
                    <!-- Preset checkboxes will be dynamically inserted here -->
                </div>
            </div>

            <div class="mb-6 bg-indigo-50 p-4 rounded-xl border border-indigo-200">
                <h2 class="text-xl font-semibold mb-3 text-indigo-700">Mystische Frequenzen für Muster in der Natur</h2>
                <p class="text-sm text-gray-600 mb-4">Diese Frequenzen sind mit Konzepten von Wasserstruktur, Zell-Harmonie und geometrischen Mustern in der Natur verbunden.</p>
                <div id="mysticalFrequenciesContainer" class="flex flex-col gap-3 mb-4" role="group" aria-label="Mystische Frequenzen">
                    <!-- Mystical preset checkboxes will be dynamically inserted here -->
                </div>
            </div>
            
            <div class="mb-6 bg-orange-50 p-4 rounded-xl border border-orange-200">
                <h3 class="text-xl font-semibold mb-3 text-orange-700">Weitere Harmonie-Frequenzen</h3>
                <p class="text-sm text-gray-600 mb-4">Zusätzliche Frequenzen zur Harmonisierung und zur Förderung des Wohlbefindens.</p>
                <div class="flex items-center gap-2 mb-3">
                    <input type="checkbox" id="enableHarmonyFreq" class="form-checkbox h-4 w-4 text-orange-600 rounded"
                        aria-label="Harmonie-Frequenz auswählen aktivieren/deaktivieren" title="Aktivieren Sie diese Option, um eine Harmonie-Frequenz auszuwählen.">
                    <label for="enableHarmonyFreq" class="text-gray-700 text-sm">Harmonie-Frequenz auswählen</label>
                </div>
                <select id="harmonyFrequencyDropdown" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-orange-300 focus:ring focus:ring-orange-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-2 px-3" disabled
                    aria-label="Dropdown für Harmonie-Frequenzen" title="Wählen Sie eine Harmonie-Frequenz aus.">
                    <option value="">Bitte wählen Sie eine Frequenz</option>
                    <!-- Options dynamically loaded by JS -->
                </select>
            </div>

            <div class="mb-6 bg-emerald-50 p-4 rounded-xl border border-emerald-200">
                <h3 class="text-xl font-semibold mb-3 text-emerald-700">Frequenzen für Umweltanalyse</h3>
                <p class="text-sm text-gray-600 mb-4">Frequenzen, die mit Umweltphänomenen und natürlichen Mustern in Verbindung stehen.</p>
                <div class="flex items-center gap-2 mb-3">
                    <input type="checkbox" id="enableEnvironmentFreq" class="form-checkbox h-4 w-4 text-emerald-600 rounded"
                        aria-label="Umwelt-Frequenz auswählen aktivieren/deaktivieren" title="Aktivieren Sie diese Option, um eine Umwelt-Frequenz auszuwählen.">
                    <label for="enableEnvironmentFreq" class="text-gray-700 text-sm">Umwelt-Frequenz auswählen</label>
                </div>
                <select id="environmentFrequencyDropdown" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-emerald-300 focus:ring focus:ring-emerald-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-2 px-3" disabled
                    aria-label="Dropdown für Umwelt-Frequenzen" title="Wählen Sie eine Umwelt-Frequenz aus.">
                    <option value="">Bitte wählen Sie eine Frequenz</option>
                    <!-- Options dynamically loaded by JS -->
                </select>
            </div>

            <!-- NEU: Benutzerdefinierte Frequenzen -->
            <div class="mb-6 bg-rose-50 p-4 rounded-xl border border-rose-200">
                <h3 class="text-xl font-semibold mb-3 text-rose-700">Benutzerdefinierte Frequenzen</h3>
                <p class="text-sm text-gray-600 mb-4">Hier können Sie eigene Frequenzen hinzufügen, verwalten und speichern.</p>
                
                <!-- Checkboxen oben -->
                <div id="customFrequenciesContainer" class="flex flex-col gap-3 mb-4" role="group" aria-label="Benutzerdefinierte Frequenzen Liste">
                    <!-- Custom preset checkboxes will be dynamically inserted here -->
                </div>

                <!-- Eingabefelder unten -->
                <div class="flex flex-col sm:flex-row gap-4 mb-4 items-center">
                    <input type="text" id="customFreqNameInput" placeholder="Name der Frequenz"
                        class="flex-1 p-2 border border-rose-300 rounded-md bg-rose-50 text-rose-800 placeholder-rose-400"
                        aria-label="Name der benutzerdefinierten Frequenz" title="Geben Sie einen Namen für Ihre Frequenz ein.">
                    <input type="number" id="customFreqValueInput" min="0.1" max="20000" step="0.01" placeholder="Frequenz (Hz)"
                        class="flex-1 p-2 border border-rose-300 rounded-md bg-rose-50 text-rose-800 placeholder-rose-400"
                        aria-label="Wert der benutzerdefinierten Frequenz in Hertz" title="Geben Sie eine Frequenz zwischen 0.1 Hz und 20000 Hz ein.">
                    <button id="addCustomFreqBtn" class="bg-rose-600 text-white py-2 px-4 rounded-xl font-semibold text-base hover:bg-rose-700 focus:outline-none focus:ring-4 focus:ring-rose-300 w-full sm:w-auto"
                        aria-label="Benutzerdefinierte Frequenz hinzufügen" title="Fügt die eingegebene Frequenz zur Liste hinzu.">
                        Hinzufügen
                    </button>
                </div>
            </div>



            <div class="grid grid-cols-1 gap-4 mt-4">
                <button id="toggleAutomationBtn" class="bg-yellow-600 text-white py-3 px-6 rounded-xl font-semibold text-lg hover:bg-yellow-700 focus:outline-none focus:ring-4 focus:ring-yellow-300" disabled
                    aria-label="Automatisches Mithören starten oder stoppen" title="Startet oder stoppt die automatische Frequenzerkennung und -wiedergabe.">
                    Automatisches Mithören starten
                </button>
            </div>
        </div>

        <div class="mb-6 bg-blue-100 p-4 rounded-xl border border-blue-300">
            <h2 class="text-xl font-semibold mb-3 text-blue-800">🐛 Diagnose Panel</h2>



			
			
            <div class="flex items-center mb-4">
                <input type="checkbox" id="debugToggle" class="form-checkbox h-4 w-4 text-blue-600 rounded mr-2"
                    aria-label="Debug-Log aktivieren" title="Aktiviert oder deaktiviert das Debug-Log für Systeminformationen.">
                <label for="debugToggle" class="text-blue-800 font-medium mr-4">Debug-Log aktivieren</label>

                <input type="checkbox" id="freezeToggle" class="form-checkbox h-4 w-4 text-blue-600 rounded mr-2"
                    aria-label="Debug-Log einfrieren" title="Friert das Debug-Log ein, um die aktuelle Ansicht zu behalten.">
                <label for="freezeToggle" class="text-blue-800 font-medium">Log einfrieren</label>
            </div>
			
			
             <div id="speechFrequencyTestContainer" class="flex flex-col gap-3 mb-4" role="group" aria-label="Sprechfrequenz Test-Optionen">
                 <!-- Checkbox will be dynamically inserted here -->
             </div>			
			
			
            <div class="flex items-center mb-4 mt-2">
                <input type="checkbox" id="forceOutputToggle" class="form-checkbox h-4 w-4 text-red-600 rounded mr-2"
                    aria-label="Force Output Testmodus aktivieren" title="Aktiviert den Testmodus, um eine ausgewählte Frequenz kontinuierlich auszugeben.">
                <label for="forceOutputToggle" class="text-red-800 font-medium">Force Output (Testmodus)</label>
            </div>
            <pre id="debugLog" class="hidden" role="log" aria-live="polite" aria-label="Debug-Log Ausgaben"></pre>

            <div class="value-boxes-container">
                <div id="currentFreqDisplay" class="value-display-box flex-1 hidden" aria-live="polite">
                    <span class="label">Ist-Wert:</span>
                    <span class="value" id="currentFreqValue" aria-label="Aktuelle gemessene Frequenz">N/A</span>
                </div>
                <div id="targetFreqDisplay" class="value-display-box flex-1 hidden" aria-live="polite">
                    <span class="label">Zielwert:</span>
                    <span class="value" id="targetFreqValue" aria-label="Ziel-Frequenz für die Automatisierung">N/A</span>
                </div>
            </div>

            <div class="debug-controls-section">
                <h3 class="text-lg font-semibold text-blue-800">Audio-Aufnahme & Wiedergabe</h3>
                <button id="micToggleBtn" class="bg-green-600 text-white py-3 px-6 rounded-xl font-semibold text-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300"
                    aria-label="Mikrofon starten oder stoppen" title="Aktiviert oder deaktiviert den Mikrofonzugriff für die Frequenzanalyse.">
                    Mikrofon starten
                </button>
                <p id="micStatus" class="mt-2 text-sm text-gray-600 text-center" aria-live="polite" aria-atomic="true">Mikrofon-Status: Inaktiv</p>

                <button id="recordBtn" disabled aria-label="Audio aufzeichnen" title="Zeichnet 5 Sekunden Audio vom Mikrofon auf.">
                    <span>⏺️ 5 Sek. Ton aufzeichnen</span>
                    <span id="recordCountdown" class="countdown" aria-live="polite"></span>
                </button>
                <button id="playBtn" disabled aria-label="Aufgenommenes Audio abspielen" title="Spielt die zuletzt aufgenommene Audiodatei ab.">
                    <span>▶️ File abspielen</span>
                    <span id="playCountdown" class="countdown" aria-live="polite"></span>
                </button>
                <div class="flex items-center mt-2">
                    <input type="checkbox" id="forcePassthroughCheckbox" class="form-checkbox h-4 w-4 text-purple-600 rounded mr-2" disabled
                        aria-label="Force Passthrough (Aux-OUT) aktivieren" title="Gibt Live-Mikrofon-Audio direkt über den Audio-Ausgang aus.">
                    <label for="forcePassthroughCheckbox" class="text-purple-800 font-medium">Force Passthrough (Aux-OUT)</label>
                </div>
                <p class="text-sm text-gray-600 mt-1">Hinweis: Live-Audio vom Mikrofon wird über Aux-OUT ausgegeben. Es können Echos oder Drop-Outs auftreten.</p>
            </div>
        </div>

        <div class="mb-6 bg-gray-100 p-4 rounded-xl border border-gray-300">
            <h2 class="text-xl font-semibold mb-3 text-gray-700">⚙️ Einstellungen</h2>

            <!-- NEU: Sub-DIV für Mikrofon-Gain -->
            <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Mikrofon-Gain</h3>
                <p class="text-sm text-gray-600 mb-4">Stellen Sie die Lautstärke des Mikrofoneingangs ein. Ein höherer Gain-Wert erhöht die Empfindlichkeit des Mikrofons.</p>
                <div class="mic-gain-slider-group">
                    <div class="mic-gain-label-row">
                        <label for="micGainRange">Gain-Wert:</label>
                        <span id="micGainValue" aria-live="polite" aria-label="Aktueller Mikrofon-Gain Wert">1.00</span>
                    </div>
                    <input type="range" id="micGainRange" min="0" max="100" step="0.01" value="1" disabled
                        aria-label="Mikrofon-Gain-Regler" title="Stellt die Lautstärke des Mikrofoneingangs ein."
                        aria-valuemin="0" aria-valuemax="100" aria-valuenow="1">
                </div>
                <div id="micGainVisualizer" class="mic-gain-visualizer hidden" role="progressbar" aria-label="Mikrofon-Gain-Pegelanzeige" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div class="mic-gain-bar"></div>
                </div>
            </div>

            <!-- NEU: Sub-DIV für Automatisierungsdauer -->
            <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Automatisierungsdauer</h3>
                <p class="text-sm text-gray-600 mb-4">Legen Sie die minimale Dauer fest, für die ein automatisch erkannter Ton abgespielt wird, bevor die App nach einer neuen Überschneidung sucht.</p>
                <div class="flex items-center">
                    <label for="automationDurationInput" class="text-lg font-medium text-gray-700 whitespace-nowrap mr-2">Min. Wiedergabedauer:</label>
                    <input type="number" id="automationDurationInput" min="1" max="600" step="1" value="10"
                        class="text-2xl font-bold text-gray-600 w-24 text-right p-1 border border-gray-300 rounded-md bg-gray-50"
                        aria-label="Minimale Wiedergabedauer für Automatisierung in Sekunden" title="Legen Sie die minimale Dauer fest, für die ein automatisch erkannter Ton abgespielt wird."
                        aria-valuemin="1" aria-valuemax="600" aria-valuenow="10">
                    <span id="automationDurationValue" class="text-xl font-bold text-gray-600 w-16 text-left">&nbsp;Sek.</span>
                </div>
            </div>

            <!-- NEU: Sub-DIV für Frequenzen Import/Export -->
            <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Frequenzen Import/Export</h3>
                <p class="text-sm text-gray-600 mb-4">Verwalten Sie Ihre benutzerdefinierten Frequenzen, indem Sie diese als JSON-Dateien exportieren oder importieren.</p>
                <div class="flex flex-col sm:flex-row gap-4 justify-between">
                    <button id="exportCustomFrequenciesBtn" class="bg-indigo-600 text-white py-2 px-4 rounded-xl font-semibold text-base hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 w-full sm:w-auto"
                        aria-label="Benutzerdefinierte Frequenzen exportieren" title="Exportiert alle benutzerdefinierten Frequenzen als JSON-Datei.">
                        Exportieren Frequenzen
                    </button>
                    <label for="importCustomFrequenciesInput" class="file-input-label w-full sm:w-auto">
                        <span title="Importiere benutzerdefinierte Frequenzen">Importieren Frequenzen</span>
                        <input type="file" id="importCustomFrequenciesInput" accept=".json" class="hidden"
                            aria-label="Benutzerdefinierte Frequenzen importieren" title="Importiert benutzerdefinierte Frequenzen aus einer JSON-Datei.">
                    </label>
                </div>
            </div>
            
            <!-- NEU: Sub-DIV für Audio-Hardware -->
            <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Audio-Hardware</h3>
                <p class="text-sm text-gray-600 mb-4">Diese Übersicht zeigt die von Ihrem System erkannten Audio-Geräte. Die tatsächliche Auswahl der aktiven Ein- und Ausgabegeräte (Mikrofon und Lautsprecher) erfolgt in den Audio-Einstellungen Ihres Betriebssystems oder Browsers. Bei Änderungen der Hardware-Konfiguration ist ein Neuladen der Seite erforderlich.</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <div class="flex-1">
                        <label for="inputDropdown" class="block text-lg font-medium text-gray-700 mb-2">Aktives Eingabegerät:</label>
                        <select id="inputDropdown" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-2 px-3" disabled
                            aria-label="Anzeige des aktiven Audio-Eingabegeräts" title="Zeigt das aktuell im System/Browser ausgewählte Audio-Eingabegerät an.">
                            <option>Lade Eingabegeräte...</option>
                        </select>
                    </div>
                    <div class="flex-1">
                        <label for="outputDropdown" class="block text-lg font-medium text-gray-700 mb-2">Aktives Ausgabegerät:</label>
                        <select id="outputDropdown" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-2 px-3" disabled
                            aria-label="Anzeige des aktiven Audio-Ausgabegeräts" title="Zeigt das aktuell im System/Browser ausgewählte Audio-Ausgabegerät an.">
                            <option>Lade Ausgabegeräte...</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- NEU: Sub-DIV für Spracheinstellungen -->
            <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Spracheinstellungen</h3>
                <p class="text-sm text-gray-600 mb-4">Wählen Sie die Anzeigesprache der App, um die Benutzeroberfläche anzupassen.</p>
                <div class="flex items-center gap-2 language-display-container">
                    <label for="languageDropdown" class="block text-base font-medium text-gray-700">Language / Sprache / Idioma / 语言:</label>
                    <select id="languageDropdown" class="block rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 bg-gray-200 text-gray-700 py-2 px-3"
                        aria-label="Sprache auswählen" title="Wählen Sie die Anzeigesprache der App.">
                        <option value="de">Deutsch</option>
                        <option value="en">English</option>
                        <option value="ar">العربية (Arabisch)</option>
                        <option value="zh">中文 (Mandarin)</option>
                        <option value="fr">Français (Französisch)</option>
                        <option value="hi">हिन्दी (Hindi)</option>
                        <option value="ja">日本語 (Japanisch)</option>
                        <option value="pt-BR">Português (Brasilien)</option>
                        <option value="ru">Русский (Russisch)</option>
                        <option value="es">Español (Spanisch)</option>
                    </select>
                    <div class="browser-language-wrapper text-base text-gray-800 whitespace-nowrap sm:ml-4"
                        aria-live="polite" aria-label="Voreingestellte Browsersprache">
                        <span>Voreingestellt:</span> <span id="browserLanguageDisplay">Deutsch</span>
                    </div>
                </div>
            </div>
        </div>


        <div class="mb-6 bg-gray-50 p-4 rounded-xl border border-gray-200">
            <div id="importantFrequenciesHeader" class="collapsible-header" role="button" aria-expanded="false" aria-controls="importantFrequenciesContent"
                title="Klicken Sie, um wichtige Frequenzen (Beispiele) anzuzeigen oder auszublenden.">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">💡 Wichtige Frequenzen (Beispiele)</h2>
                <span id="importantFrequenciesArrow" class="toggle-icon" aria-hidden="true">⬇️</span>
            </div>
            <div id="importantFrequenciesContent" class="hidden">
                <ul class="list-disc text-gray-600 text-sm space-y-2 list-outside-indent">
                    <li><span class="font-normal">Schumann-Resonanz (Erde - Grundwelle):</span> 7.83 Hz</li>
                    <li><span class="font-normal">Schumann-Resonanz (Erde - 2. Harmonie):</span> 14.1 Hz</li>
                    <li><span class="font-normal">Schumann-Resonanz (Erde - 3. Harmonie):</span> 20.3 Hz</li>
                    <li><span class="font-normal">Solfeggio Mi (DNA-Reparatur):</span> 528 Hz</li>
                    <li><span class="font-normal">Solfeggio Fa (Herzfrequenz Harmonisierung):</span> 639 Hz</li>
                    <li><span class="font-normal">Heilende Wasserfrequenz:</span> 432 Hz</li>
                    <li><span class="font-normal">Ganzkörper-Entspannung (Delta-Wellen):</span> 4 Hz</li>
                </ul>
            </div>
        </div>

        <div class="mb-6 bg-green-50 p-4 rounded-xl border border-green-200">
            <div id="appUsageHeader" class="collapsible-header" role="button" aria-expanded="false" aria-controls="appUsageContent"
                title="Klicken Sie, um Anwendungsbeispiele der App anzuzeigen oder auszublenden.">
                <h2 class="text-xl font-semibold mb-3 text-green-700">✅ Wofür diese App verwendet werden kann</h2>
                <span id="appUsageArrow" class="toggle-icon" aria-hidden="true">⬇️</span>
            </div>
            <div id="appUsageContent" class="hidden">
                <ul class="list-disc text-gray-600 text-sm space-y-2 list-outside-indent">
                    <li><span class="font-bold">Entspannung und Meditation:</span> Einsatz von beruhigenden Frequenzen zur Förderung von Ruhe und innerer Balance.</li>
                    <li><span class="font-bold">Unterstützung bei Schlafstörungen:</span> Nutzung spezifischer Frequenzen zur Verbesserung der Schlafqualität durch gezielte Klanganwendungen.</li>
                    <li><span class="font-bold">Konzentration und Produktivität:</span> Schaffung einer optimalen akustischen Umgebung, die Fokus und Lernfähigkeit unterstützt.</li>
                    <li><span class="font-bold">Naturbeobachtung und Umweltanalyse:</span> Identifizierung und Analyse von Tierstimmen oder spezifischen Umweltfrequenzen.</li>
                    <li><span class="font-bold">Klangtherapie und Wohlbefinden:</span> Ergänzende Anwendung zur Förderung des körperlichen und geistigen Wohlbefindens (kein Ersatz für medizinische Behandlung).</li>
                    <li><span class="font-bold">Lern- und Lehrmittel:</span> Praktische Demonstration von Frequenzen, Schallwellen und deren Auswirkungen in Bildungseinrichtungen.</li>
                    <li><span class="font-bold">Akustische Optimierung:</span> Analyse der Raumakustik und Hilfestellung bei der optimalen Platzierung von Lautsprechern.</li>
                    <li><span class="font-bold">Kreative Soundexploration:</span> Experimentieren mit Frequenzen zur Erzeugung einzigartiger Soundeffekte und Texturen für musikalische oder künstlerische Projekte.</li>
                    <li><span class="font-bold">Persönliche Energie-Harmonisierung:</span> Unterstützung des Energieflusses im Körper durch gezielte Frequenzeinwirkung und Resonanz.</li>
                    <li><span class="font-bold">Frequenzen und Wasser:</span> Wissenschaftliche Forschung und Experimente zur Beeinflussung von Wasserstrukturen durch spezifische Frequenzen.</li>
                    <li><span class="font-bold">Konzert & Bühnenprojektion:</span> Integration in Kunst- und Bühnenprojekte: Nutzung von Frequenzen zur Steuerung von Wasserspielen, Lichteffekten und holographischen Projektionen bei Konzerten oder Performances.</li>
                </ul>
            </div>
        </div>

        <div class="mb-6 bg-yellow-50 p-4 rounded-xl border border-yellow-200">
            <div id="faqHeader" class="collapsible-header" role="button" aria-expanded="false" aria-controls="faqContent"
                title="Klicken Sie, um häufig gestellte Fragen anzuzeigen oder auszublenden.">
                <h2 class="text-xl font-semibold mb-3 text-yellow-700">❓ Häufig gestellte Fragen (FAQ)</h2>
                <span id="faqArrow" class="toggle-icon" aria-hidden="true">⬇️</span>
            </div>
            <div id="faqContent" class="hidden">
                <ul class="list-disc text-gray-600 text-sm space-y-3 list-outside-indent">
                    <li>
                        <span class="font-bold">1. Weshalb funktioniert das "automatische Mithören" nur mit einem Full-Range-Vibration-Lautsprecher, bzw. einem Körperschall Lautsprecher oder mit angeschlossenem Kopfhörer?</span><br>
                        Das "automatische Mithören" der X-Frequency App ist darauf ausgelegt, Frequenzen aus dem <span class="faq-emphasis">akustischen Raum</span> zu erfassen. Wenn du normale Lautsprecher verwendest, geben diese den Ton ab, und das Mikrofon deines Geräts würde diesen Ton sofort wieder aufnehmen. Das erzeugt eine <span class="faq-emphasis">Rückkopplungsschleife</span> oder ein Echo, das die Messung verfälschen und sogar zu unangenehmen Pfeifgeräuschen führen kann.
                        Ein <span class="faq-emphasis">Full-Range-Vibration-Lautsprecher</span> oder ein <span class="faq-emphasis">Körperschalllautsprecher</span> sendet die Frequenzen direkt in einen Gegenstand (z.B. einen Tisch oder ein Glas Wasser), ohne sie direkt in die Luft abzustrahlen. Dadurch kann das Mikrofon die Umgebungsgeräusche klarer erfassen. Bei <span class="faq-emphasis">Kopfhörern</span> wird der Ton direkt an deine Ohren geleitet und stört das Mikrofon nicht, sodass eine saubere Analyse der Umgebung möglich ist.
                    </li>
                    <li>
                        <span class="font-bold">2. Weshalb kann ich z.B. "Tiefe Erdung (1.2 Hz)" nicht hören?</span><br>
                        Frequenzen wie "Tiefe Erdung" (1.2 Hz) liegen im sogenannten <span class="faq-emphasis">Infraschallbereich</span>. Das menschliche Ohr kann Töne in der Regel nur im Frequenzbereich von etwa <span class="faq-emphasis">20 Hz bis 20.000 Hz</span> wahrnehmen. Frequenzen unter 20 Hz werden als Infraschall bezeichnet und sind für uns nicht hörbar, obwohl sie physikalisch vorhanden sind und manchmal als Druck oder Vibration empfunden werden können. Die App erzeugt diese Frequenzen korrekt, aber du kannst sie aus biologischen Gründen nicht hören.
                    </li>
                    <li>
                        <span class="font-bold">3. Wenn ich den Ton aufzeichne/abspiele, weshalb ist die Aufzeichnung so schlecht?</span><br>
                        Die Qualität der Audioaufnahme und -wiedergabe in einer Web-App wie X-Frequency kann durch mehrere Faktoren beeinflusst werden:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Browser- und Systemlimitierungen:</span> Webbrowser haben oft Einschränkungen bei der Audioverarbeitung, die eine Studioqualität schwierig machen. Die Aufnahme erfolgt im WebM-Format, das für die Echtzeitübertragung optimiert ist, aber nicht immer die höchste Wiedergabetreue bietet.</li>
                            <li><span class="faq-emphasis">Mikrofonqualität:</span> Das eingebaute Mikrofon deines Geräts ist selten für hochwertige Aufnahmen optimiert. Externe Mikrofone verbessern die Qualität erheblich.</li>
                            <li><span class="faq-emphasis">Umgebungsgeräusche:</span> Störgeräusche in deiner Umgebung werden mit aufgezeichnet.</li>
                            <li><span class="faq-emphasis">Hardware-Ressourcen:</span> Langsamere Prozessoren oder unzureichender Arbeitsspeicher können zu "Dropouts" oder Verzerrungen führen.</li>
                            <li><span class="faq-emphasis">"Force Passthrough" (Aux-OUT):</span> Wenn diese Option aktiviert ist, wird das Live-Mikrofonsignal direkt an den Audio-Ausgang geleitet. Dies kann zu Echos oder einer schlechten Klangqualität führen, da das System das Signal zweimal verarbeitet und wiedergibt.</li>
                        </ul>
                        Um die Qualität zu verbessern, achte auf eine ruhige Umgebung, verwende ein hochwertiges externes Mikrofon und deaktiviere <span class="faq-emphasis">"Force Passthrough"</span> während der Aufnahme.
                    </li>
                    <li>
                        <span class="font-bold">4. Bei Input/Output werden nicht die richtigen Geräte MIC/AUX angezeigt, was kann ich tun?</span><br>
                        Wenn die gewünschten Audio-Geräte (Mikrofon/Aux-Ausgang) nicht in den Dropdowns erscheinen, kann das mehrere Ursachen haben:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Berechtigungen:</span> Stelle sicher, dass du deinem Browser die Erlaubnis erteilt hast, auf Audio-Geräte zuzugreifen. Ohne diese Berechtigung können Geräte nicht erkannt werden.</li>
                            <li><span class="faq-emphasis">Geräte angeschlossen?:</span> Prüfe, ob deine Geräte (z.B. externes Mikrofon, USB-Soundkarte, Kopfhörer) korrekt an deinen Computer angeschlossen und eingeschaltet sind.</li>
                            <li><span class="faq-emphasis">Systemeinstellungen:</span> Überprüfe die Audio-Einstellungen deines Betriebssystems (Windows, macOS, Linux), um sicherzustellen, dass die Geräte dort als aktiv erkannt werden.</li>
                            <li><span class="faq-emphasis">Browser-Neustart:</span> Manchmal hilft es, den Browser neu zu starten, nachdem neue Geräte angeschlossen wurden.</li>
                            <li><span class="faq-emphasis">Treiber:</span> Stelle sicher, dass die Treiber für deine Audio-Hardware auf dem neuesten Stand sind.</li>
                            <li><span class="faq-emphasis">Gerätewechsel:</span> Werden neue Mikrofon- oder Audio-Ausgabegeräte hinzugefügt, muss unter Umständen der Computer neu gestartet werden, damit sie korrekt erkannt werden.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-bold">5. Benötige ich spezielle Hardware (Mikrofon, Lautsprecher) für X-Frequency?</span><br>
                        Die X-Frequency App ist so konzipiert, dass sie mit der Standard-Audio-Hardware deines Geräts (integriertes Mikrofon und Lautsprecher) funktioniert. Für die grundlegende Frequenzerzeugung und -analyse reicht dies aus. Um jedoch die volle Leistungsfähigkeit zu nutzen, insbesondere für das "automatische Mithören" ohne Rückkopplung, oder für präzisere Analysen und Aufnahmen, werden <span class="faq-emphasis">externe Kopfhörer</span> oder <span class="faq-emphasis">Full-Range-Vibration-Lautsprecher/Körperschalllautsprecher</span> empfohlen. Ein hochwertiges externes Mikrofon verbessert die Aufnahmequalität erheblich.
                    </li>
                    <li>
                        <span class="font-bold">6. Wie stelle ich eine Frequenz manuell ein und spiele sie ab?</span><br>
                        Im Bereich "Frequenz-Generator" kannst du die gewünschte Frequenz auf zwei Arten einstellen:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Verwende den <span class="faq-emphasis">Schieberegler</span> (`frequencyRange`), um die Frequenz grob einzustellen.</li>
                            <li>Nutze das <span class="faq-emphasis">Eingabefeld</span> (`manualFrequencyInput`), um einen exakten Wert in Hertz (Hz) einzugeben.</li>
                        </ul>
                        Sobald die gewünschte Frequenz eingestellt ist, klicke auf den Button <span class="faq-emphasis">"Manuell abspielen"</span>. Um die Wiedergabe zu stoppen, klicke denselben Button erneut, der sich dann in "Manuell stoppen" geändert hat.
                    </li>
                    <li>
                        <span class="font-bold">7. Warum erhalte ich eine "Mikrofonzugriff verweigert"-Warnung?</span><br>
                        Diese Warnung erscheint, wenn die App nicht auf das Mikrofon deines Geräts zugreifen kann. Dies liegt meist an fehlenden Berechtigungen:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Dein Browser benötigt die explizite <span class="faq-emphasis">Erlaubnis</span>, auf das Mikrofon zuzugreifen. Überprüfe die Einstellungen deines Browsers (oft in den Datenschutz- oder Website-Berechtigungen), ob der Zugriff für diese Seite blockiert ist.</li>
                            <li>Manchmal muss auch das <span class="faq-emphasis">Betriebssystem</span> (Windows, macOS, Android, iOS) den Mikrofonzugriff für den Browser erlauben.</li>
                            <li>Stelle sicher, dass kein anderes Programm das Mikrofon exklusiv nutzt.</li>
                        </ul>
                        Nachdem du die Berechtigungen angepasst hast, lade die Seite neu.
                    </li>
                    <li>
                        <span class="font-bold">8. Wie funktioniert die "Automatisches Mithören"-Funktion und wie richte ich sie ein?</span><br>
                        Die Funktion "Automatisches Mithören" ermöglicht es der App, Frequenzen in deiner Umgebung über das Mikrofon zu überwachen und bei Erkennung einer ausgewählten Frequenz diese automatisch abzuspielen. So richtest du sie ein:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Aktiviere im Bereich "Frequenz-Assistenten & Kategorien" die gewünschten Frequenzen über die <span class="faq-emphasis">Checkboxen</span> oder wähle sie aus den <span class="faq-emphasis">Dropdown-Menüs</span> ("Harmonie-Frequenz", "Umwelt-Frequenz") aus.</li>
                            <li>Die App spielt die ausgewählte Frequenz ab, sobald sie eine Überschneidung mit dem Mikrofonsignal feststellt. Sie wechselt automatisch zu einer neu erkannten Frequenz, sobald die Mindestwiedergabedauer der aktuellen Frequenz (siehe Einstellungen) überschritten ist.</li>
                            <li>Starte die Funktion, indem du auf <span class="faq-emphasis">"Automatisches Mithören starten"</span> klickst. Der Button ändert sich zu "Automatisches Mithören stoppen", um die Funktion jederzeit zu beenden.</li>
                        </ul>
                        Hinweis: Für diese Funktion ist ein aktiviertes Mikrofon erforderlich.
                    </li>
                    <li>
                        <span class="font-bold">9. Was bedeutet "Erkennungs-Empfindlichkeit" (dB) und wie beeinflusst sie die Frequenz-Analyse?</span><br>
                        Die <span class="faq-emphasis">Erkennungs-Empfindlichkeit (dB)</span> bestimmt, wie "laut" ein Signal sein muss, damit die App es als relevante Frequenz erkennt. dB steht für Dezibel, eine logarithmische Masseinheit für Lautstärke:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Ein Wert wie <span class="faq-emphasis">-55 dB</span> bedeutet, dass die App nur Frequenzen erkennt, die über dieser Lautstärke liegen. Alles darunter wird ignoriert.</li>
                            <li><span class="faq-emphasis">Niedrigere dB-Werte</span> (z.B. -70 dB) machen die App empfindlicher, sie erkennt auch leisere Signale.</li>
                            <li><span class="faq-emphasis">Höhere dB-Werte</span> (z.B. -30 dB) machen die App weniger empfindlich, sie reagiert nur auf lautere Signale.</li>
                        </ul>
                        Du kannst den Wert mit dem Schieberegler anpassen, um Umgebungsgeräusche herauszufiltern oder sehr leise Frequenzen zu erfassen.
                    </li>
                    <li>
                        <span class="font-bold">10. Warum gibt es im Debug-Bereich eine Option "Force Output (Testmodus)" und wofür ist sie?</span><br>
                        Der <span class="faq-emphasis">"Force Output (Testmodus)"</span> im Debug-Bereich ist eine erweiterte Funktion für Testzwecke:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Wenn dieser Modus aktiviert ist, <span class="faq-emphasis">deaktiviert</span> er alle automatischen Mikrofon- und Erkennungsfunktionen.</li>
                            <li>Du kannst dann <span class="faq-emphasis">manuell eine einzelne Frequenz</span> aus den "Frequenz-Assistenten"-Kategorien auswählen, die dann <span class="faq-emphasis">sofort und kontinuierlich</span> abgespielt wird, unabhängig vom Mikrofoneingang.</li>
                            <li>Dies ist nützlich, um die Ausgabe bestimmter Frequenzen zu testen, ohne dass die Mikrofonanalyse oder die Automatisierungslogik eingreifen. Es ist eine Art "erzwungener" Frequenzausgang für Debugging-Zwecke.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-bold">11. Wie kann ich Audio mit der App aufnehmen und wiedergeben?</span><br>
                        Im "Debug-Bereich" findest du die Optionen zur Audio-Aufnahme und -Wiedergabe:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Stelle sicher, dass das <span class="faq-emphasis">Mikrofon aktiviert</span> ist ("Mikrofon starten").</li>
                            <li>Klicke auf <span class="faq-emphasis">"⏺️ 5 Sek. Ton aufzeichnen"</span>, um eine kurze Audioaufnahme zu starten. Während der Aufnahme wird ein Countdown angezeigt.</li>
                            <li>Nachdem die Aufnahme beendet ist, wird der Button <span class="faq-emphasis">"▶️ File abspielen"</span> aktiv. Klicke darauf, um die soeben gemachte Aufnahme abzuspielen. Du kannst sie jederzeit durch erneutes Klicken auf den "Abspielen stoppen"-Button anhalten.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-bold">12. Meine Frequenz-Visualisierung auf dem Canvas zeigt keine klaren Spitzen oder ist leer – was mache ich falsch?</span><br>
                        Eine leere oder unklare Frequenz-Visualisierung kann mehrere Gründe haben:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Mikrofon nicht aktiv:</span> Stelle sicher, dass du das Mikrofon mit dem Button "Mikrofon starten" aktiviert hast.</li>
                            <li><span class="faq-emphasis">Mikrofon-Berechtigungen:</span> Prüfe, ob der Browser die Berechtigung zum Mikrofonzugriff hat (siehe FAQ 7).</li>
                            <li><span class="faq-emphasis">Kein Audioeingang:</span> Sprich ins Mikrofon oder spiele einen Ton in der Nähe ab. Die Visualisierung reagiert auf Geräusche.</li>
                            <li><span class="faq-emphasis">Mikrofon-Gain zu niedrig:</span> Erhöhe den "Mikrofon-Gain" im Einstellungsbereich. Wenn der Gain zu niedrig ist, werden auch laute Geräusche nicht erfasst.</li>
                            <li><span class="faq-emphasis">Erkennungs-Empfindlichkeit zu hoch:</span> Wenn die "Erkennungs-Empfindlichkeit" (dB) zu hoch eingestellt ist (z.g. -20 dB), werden nur sehr laute Signale angezeigt. Versuche, den Wert zu senken (z.B. auf -60 dB), um auch leisere Geräusche zu visualisieren.</li>
                            <li><span class="faq-emphasis">"Force Output (Testmodus)" aktiv:</span> Im "Force Output" Modus ist die Mikrofoneingabe deaktiviert, daher wird die Visualisierung leer bleiben.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-bold">13. Was ist der Unterschied zwischen den "Mystischen Frequenzen" und "Weiteren Harmonie-Frequenzen"?</span><br>
                        Beide Kategorien sind Teil der "Frequenz-Assistenten", haben aber unterschiedliche Schwerpunkte:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Mystische Frequenzen für Muster in der Natur:</span> Diese Frequenzen sind eher theoretisch und experimentell. Sie sind mit Konzepten wie Cymatik (Sichtbarmachung von Schall), Wasserstrukturen, Zell-Harmonie und geometrischen Mustern verbunden, die in der Natur vorkommen sollen. Ihre Anwendung ist eher explorativ.</li>
                            <li><span class="faq-emphasis">Weitere Harmonie-Frequenzen:</span> Diese Frequenzen sind typischerweise mit esoterischen oder alternativen Gesundheitskonzepten verbunden, die das Wohlbefinden, die Harmonisierung von Energiezentren (Chakren) oder spezifische Absichten (z.B. "Divine Frequency", "Miracle Frequency") unterstützen sollen. Ihre Wirkung wird oft im Kontext von Resonanz und Schwingung verstanden.</li>
                        </ul>
                        Beide sind als ergänzende Anwendungen zu verstehen und ersetzen keine wissenschaftlich fundierten oder medizinischen Behandlungen.
                    </li>
                    <li>
                        <span class="font-bold">14. Kann ich X-Frequency auch auf meinem Smartphone oder Tablet nutzen?</span><br>
                        Ja, X-Frequency ist als Web-App konzipiert und sollte auf den meisten modernen Smartphones und Tablets über den Browser funktionieren. Die Benutzeroberfläche ist <span class="faq-emphasis">responsive</span> gestaltet, das heisst, sie passt sich automatisch an verschiedene Bildschirmgrössen an, um eine gute Bedienbarkeit auf mobilen Geräten zu gewährleisten.
                        Beachte jedoch, dass die Leistung und die Qualität des Mikrofons und der Lautsprecher je nach Gerät variieren können. Für optimale Ergebnisse, insbesondere bei der Frequenz-Analyse, könnten externe Mikrofone oder Kopfhörer auch auf mobilen Geräten von Vorteil sein. Stelle sicher, dass dein mobiler Browser die Medienberechtigungen für den Mikrofonzugriff erteilen kann.
                    </li>
                    <li>
                        <span class="font-bold">15. Vom Live-Konzert zu einer dynamischen, visuellen Bühnenshow – wie funktioniert das?</span><br>
                        Die X-Frequency App kann als Herzstück einer faszinierenden Live-Performance dienen, die Sound in dynamische visuelle Muster verwandelt:
                        <ul class="list-outside-indent ml-4 mt-1 space-y-1">
                            <li>Ein <span class="faq-emphasis">Mikrofon</span> fängt den <span class="faq-emphasis">Live-Sound</span> des Konzerts oder der Performance ein.</li>
                            <li>Diese App analysiert den eingehenden <span class="faq-emphasis">Audiostream kontinuierlich</span> und erkennt, wenn bestimmte <span class="faq-emphasis">Frequenzen überlagert</span> werden. Du kannst hierfür die "Automatisches Mithören"-Funktion nutzen und die entsprechenden Frequenzen auswählen.</li>
                            <li>Wird eine solche Frequenzüberschneidung erkannt, leitet die App das <span class="faq-emphasis">analysierte Signal</span> (oder einen generierten, korrespondierenden Ton) für die eingestellte Dauer über einen <span class="faq-emphasis">Aux-Ausgang</span> an einen <span class="faq-emphasis">Körperschall-Lautsprecher</span> weiter.</li>
                            <li>Dieser Lautsprecher ist an einer Art <span class="faq-emphasis">Teller mit Wasser</span> befestigt, der dadurch zum <span class="faq-emphasis">Schwingen gebracht</span> wird. So entstehen dynamische und hypnotisierende <span class="faq-emphasis">Wellenmuster auf der Wasseroberfläche</span>. Dies ist das Prinzip der <span class="faq-emphasis">Cymatik</span>.</li>
                            <li>Die gesamte Installation ist von <span class="faq-emphasis">LED-Licht</span> umgeben, das sich farblich an die Bühnenbeleuchtung anpasst und die Wellenmuster eindrucksvoll inszeniert.</li>
                            <li>Eine <span class="faq-emphasis">Kamera</span> (oder ein Smartphone) filmt die sich verändernde Wasseroberfläche, idealerweise aus der Vogelperspektive.</li>
                            <li>Abschliessend projiziert ein <span class="faq-emphasis">Rückprojektionsbeamer</span> das <span class="faq-emphasis">Live-Bild des Wassers</span> auf die grosse <span class="faq-emphasis">Bühnenleinwand</span>, wodurch eine einzigartige, visuelle Darstellung des Konzert-Sounds in Echtzeit entsteht. Das Publikum erlebt den Klang nicht nur auditiv, sondern auch als faszinierendes, flüssiges Kunstwerk.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-bold">16. Wie kann ich meine eigenen "Benutzerdefinierte Frequenzen" hinzufügen, bearbeiten oder löschen?</span><br>
                        Im Bereich <span class="faq-emphasis">"Benutzerdefinierte Frequenzen"</span> können Sie Ihre eigenen Frequenzen verwalten:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Hinzufügen:</span> Geben Sie einfach einen Namen und den gewünschten Frequenzwert (in Hz) in die dafür vorgesehenen Eingabefelder ein und klicken Sie auf den Button <span class="faq-emphasis">"Hinzufügen"</span>. Die neue Frequenz erscheint sofort in der Liste darüber.</li>
                            <li><span class="faq-emphasis">Bearbeiten:</span> Eine direkte Bearbeitungsfunktion für bestehende benutzerdefinierte Frequenzen ist derzeit nicht integriert. Um einen Wert zu ändern, löschen Sie die Frequenz und fügen Sie sie neu mit den korrigierten Daten hinzu.</li>
                            <li><span class="faq-emphasis">Löschen:</span> Neben jeder benutzerdefinierten Frequenz in der Liste finden Sie ein <span class="faq-emphasis">"✖"</span>-Symbol. Klicken Sie darauf, um die entsprechende Frequenz aus Ihrer Liste zu entfernen. Eine Bestätigung wird angefordert, um versehentliche Löschungen zu verhindern.</li>
                        </ul>
                        Alle Änderungen werden automatisch im Browser gespeichert, sodass Ihre benutzerdefinierten Frequenzen auch nach dem Neuladen der Seite erhalten bleiben.
                    </li>
                    <li>
                        <span class="font-bold">17. Kann ich meine "Benutzerdefinierte Frequenzen" mit anderen teilen oder auf ein anderes Gerät übertragen?</span><br>
                        Ja, die App bietet Funktionen zum einfachen Teilen und Übertragen Ihrer benutzerdefinierten Frequenzen:
                        <ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1">
                            <li><span class="faq-emphasis">Exportieren:</span> Im <span class="faq-emphasis">"Einstellungen"</span>-Bereich finden Sie einen Button <span class="faq-emphasis">"Exportieren Frequenzen"</span>. Klicken Sie darauf, um alle Ihre benutzerdefinierten Frequenzen als JSON-Datei herunterzuladen. Diese Datei können Sie dann per E-Mail, Messenger oder USB-Stick teilen.</li>
                            <li><span class="faq-emphasis">Importieren:</span> Ebenfalls im <span class="faq-emphasis">"Einstellungen"</span>-Bereich gibt es eine Option <span class="faq-emphasis">"Importieren Frequenzen"</span>. Klicken Sie darauf, um eine zuvor exportierte JSON-Datei auszuwählen. Sie werden gefragt, ob Sie die importierten Frequenzen zur bestehenden Liste hinzufügen oder die aktuelle Liste damit überschreiben möchten. Dies ist ideal, um Ihre Frequenzen auf ein neues Gerät zu übertragen oder Listen von Freunden zu übernehmen.</li>
                        </ul>
                    </li>
                    <li><span class="font-bold">18. Wie kann ich meine &quot;Benutzerdefinierte Frequenzen&quot; thematisch sortieren?</span><br><p>Direkt in der App lässt sich <span class="faq-emphasis">nicht sortieren</span>. So geht’s in fünf Schritten:</p>
<ul class="list-disc list-outside-indent ml-4 mt-1 space-y-1"><li>Zwei <span class="faq-emphasis">Dummy‑Einträge</span> anlegen (z.&nbsp;B. <em>Dummy‑1 (111&nbsp;Hz)</em> und <em>Dummy‑2 (222&nbsp;Hz)</em>).</li><li>Alle Frequenzen als <code>.json</code> <span class="faq-emphasis">exportieren</span>.</li><li>Die <code>JSON</code> in einem Editor (z.&nbsp;B. <em>Notepad</em> oder <em>VS&nbsp;Code</em>) thematisch <span class="faq-emphasis">ordnen</span> und speichern.</li><li>In der App die bestehenden <span class="faq-emphasis">Custom‑Einträge</span> <span class="faq-emphasis">löschen</span>, damit die Liste leer ist.</li><li>Die thematisch sortierte <code>.json</code> wieder <span class="faq-emphasis">importieren</span>.</li></ul>
<p><span class="faq-emphasis">Durch Erstellungsreihenfolge:</span> Wenn Sie die Sortierung auf <span class="faq-emphasis">„Thematisch“</span> (Standardeinstellung) belassen, werden Ihre benutzerdefinierten Frequenzen in der Reihenfolge angezeigt, in der Sie sie hinzugefügt haben.</p></li>
                        </ul>
                        </li>
                </ul>
            </div>
        </div>

        <!-- NEU: Wichtige Links & Communities Sektion -->
        <div class="mb-6 bg-blue-50 p-4 rounded-xl border border-blue-200">
            <div id="linksHeader" class="collapsible-header" role="button" aria-expanded="false" aria-controls="linksContent"
                title="Klicken Sie, um Links und Community-Plattformen anzuzeigen oder auszublenden.">
                <h2 class="text-xl font-semibold mb-3 text-blue-700">🔗 Links & Communities</h2>
                <span id="linksArrow" class="toggle-icon" aria-hidden="true">⬇️</span>
            </div>
            <div id="linksContent" class="hidden">
                <ul class="list-disc text-gray-600 text-sm space-y-2 list-outside-indent">
                    <li><span class="font-bold">X-Frequency Home:</span> <a href="https://xfrequency.blogspot.com" target="_blank" class="font-semibold text-blue-600 hover:underline">xfrequency.blogspot.com</a></li>
                    <li><span class="font-bold">X-Frequency Bilder Galerie:</span> <a href="https://photos.app.goo.gl/nyzgZgiddFXUd4eW9" target="_blank" class="font-semibold text-blue-600 hover:underline">X-Frequency Bilder Galerie</a></li>
                    <li><span class="font-bold">YouTube-Kanäle von Sound Healing Künstlern:</span> Suchen Sie nach "Sound Healing Music" oder "Klangheilung" auf <a href="https://www.youtube.com/" target="_blank" class="font-semibold text-blue-600 hover:underline">YouTube</a>, um viele Künstler und Meditationskanäle zu finden.</li>
                    <li><span class="font-bold">Foren/Gruppen zu Bioresonanz, Frequenztherapie, esoterische Klangpraktiken und Cymatik-Forschung:</span> Suchen Sie auf Plattformen wie <a href="https://www.reddit.com/subreddits/search?q=sound+healing+cymatics" target="_blank" class="font-semibold text-blue-600 hover:underline">Reddit</a> (z.g. Subreddits wie r/SoundHealing) oder in spezialisierten Bioresonanz- und Alternativmedizin-Foren.</li>
                    <li><span class="font-bold">Facebook-Gruppen:</span> Suchen Sie nach "Sound Healing Practitioners", "Cymatics Art & Science" oder "Alternative Frequenztherapien" auf <a href="https://www.facebook.com/groups/" target="_blank" class="font-semibold text-blue-600 hover:underline">Facebook</a>, um aktive Communities zu finden.</li>
                    <li><span class="font-bold">Hashtags:</span> #cymatik #cymatics #resonanz #resonance #schwingung #vibration #frequenz #frequency #frequenzen #harmonics #overtone #bioresonanz #klang #sound #klangheilung #soundhealing #meditation #relaxation #focus #wellbeing #heilung #healing #chakra #chakras #solfeggio #schumann #infraschall #ultraschall #isocronic #binaural #delta #theta #alpha #beta #gamma #wasser #cymagraph #fft #spectrum #acoustics #psychoakustik #psychoacoustics #entrainment</li>
                </ul>
          </div>
        </div>
        <!-- ENDE: NEU Wichtige Links & Communities Sektion -->


        <div class="mb-6 bg-purple-50 p-4 rounded-xl border border-purple-200">
            <div id="aboutAppHeader" class="collapsible-header" role="button" aria-expanded="false" aria-controls="aboutAppContent"
                title="Klicken Sie, um Informationen über die X-Frequency App anzuzeigen oder auszublenden.">
                <h2 class="text-xl font-semibold mb-3 text-purple-700">ℹ️ Über X-Frequency</h2>
                <span id="aboutAppArrow" class="toggle-icon" aria-hidden="true">⬇️</span>
            </div>
            <div id="aboutAppContent" class="hidden">
                <ul class="list-disc text-gray-600 text-sm space-y-2 list-outside-indent">
                    <li><span class="font-bold">Release:</span> Frequency 1.34.58</li>
                    <li><span class="font-bold">Status:</span> Beta-Version (laufende Entwicklung)</li>
                    <li><span class="font-bold">Entwicklungsteam:</span> Gemini AI & Albertus Zerk</li>
                    <li><span class="font-bold">Zweck:</span> Ein innovatives Tool zur Erforschung und Anwendung von Audiofrequenzen für verschiedene Bereiche des Wohlbefindens und der technischen Analyse.</li>
                    <li><span class="font-bold">Rechtliches:</span> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="license noopener" aria-label="Creative Commons BY-NC-SA 4.0 Lizenz">CC BY-NC-SA 4.0</a></li>
                    <li><span class="font-bold">Homepage:</span> <a href="https://x-event.designo.ch/frequency" target="_blank" class="font-semibold text-blue-600 hover:underline" title="Besuchen Sie die X-Frequency Homepage">x-event.designo.ch/frequency</a></li>
                </ul>
<div style="display:flex;justify-content:center;align-items:center;margin-top:8px;"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="license noopener" aria-label="Creative Commons BY-NC-SA 4.0 Lizenz"><img src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png" alt="CC BY-NC-SA 4.0" style="height:16px; opacity:0.95;"></a></div>
            </div>
        </div>

        <div class="mt-8 text-center text-gray-600 text-sm flex flex-col sm:flex-row justify-center items-center space-y-2 sm:space-y-0 sm:space-x-4">
<p>
                Feurig unterstützt von <a href="https://www.stimmenfeuer.ch/" target="_blank" class="font-semibold text-red-600 hover:underline" title="Besuchen Sie die Stimmenfeuer Homepage.">Stimmenfeuer</a> 🔥
            </p>
        </div>

    </div>
    <script>
        // Global variables for AudioContext, oscillator, analyser, etc.
        let audioContext;
        let oscillator;
        let outputGainNode; // Renamed to clarify it's for the app's output tone
        let analyser;
        let frequencyData;
        let timeDomainData; // To store time domain data for gain visualization
        let micStream;
        let micSourceNode; // Node for the microphone input
        let micInputGainNode; // Gain node for microphone input
        let animationFrameId; // For spectrum visualization

        // Automation related variables
        let isAutomationActive = false;
        let currentPlayingPresetFrequency = null; // Stores the preset object currently playing by automation
        let playbackStartedAt = 0; // Timestamp (audioContext.currentTime) for min. duration tracking
        let playbackDurationMs = 10000; // Configurable: 10 seconds (for automation minimum playback)

        let micWasInitiallyOffBeforeAutomation = false; // Flag to track if mic was started by automation

        // Debug related variables
        let debugActive = false;
        let isLogFrozen = false; // New variable for freezing the log
        let isForceOutputActive = false; // New variable for Force Output mode
        let currentForcedPreset = null; // To track which single preset is playing in force mode.

        // Recording and Playback variables
        let mediaRecorder;
        let audioChunks = [];
        let recordedBlob = null;
        let recordedBlobUrl = null;
        let audioPlayer = new Audio();
        let recordCountdownInterval;
        let playCountdownInterval; // Defined globally now

        let lastLogTime = 0;
        const LOG_INTERVAL_MS = 200; // Log roughly 5 times per second (1000ms / 5 = 200ms)
        const FADE_TIME = 0.05; // 50ms fade time for smooth transitions

        // DOM Elements
        const frequencyRange = document.getElementById('frequencyRange');
        const manualFrequencyInput = document.getElementById('manualFrequencyInput');
        const playStopBtn = document.getElementById('playStopBtn');
        const micToggleBtn = document.getElementById('micToggleBtn');
        const micStatusSpan = document.getElementById('micStatus');
        const micGainRange = document.getElementById('micGainRange');
        const micGainValueSpan = document.getElementById('micGainValue');
        const sensitivityRange = document.getElementById('sensitivityRange');
        const sensitivityValueSpan = document.getElementById('sensitivityValue');
        const frequencyCanvas = document.getElementById('frequencyCanvas');
        const overlapMessage = document.getElementById('overlapMessage');
        const currentPlayingPresetSpan = document.getElementById('currentPlayingPreset');
        const currentPlayingPresetNameSpan = document.getElementById('currentPlayingPresetName');
        const currentPlayingPresetFreqSpan = document.getElementById('currentPlayingPresetFreq');
        const micPermissionWarning = document.getElementById('micPermissionWarning');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const presetFrequenciesContainer = document.getElementById('presetFrequenciesContainer');
        const mysticalFrequenciesContainer = document.getElementById('mysticalFrequenciesContainer');
        const speechFrequencyTestContainer = document.getElementById('speechFrequencyTestContainer'); 
        
        // Harmonie and Umwelt Frequencies DOM Elements
        const enableHarmonyFreq = document.getElementById('enableHarmonyFreq');
        const harmonyFrequencyDropdown = document.getElementById('harmonyFrequencyDropdown');
        const enableEnvironmentFreq = document.getElementById('enableEnvironmentFreq');
        const environmentFrequencyDropdown = document.getElementById('environmentFrequencyDropdown');

        // NEU: DOM Elemente für Benutzerdefinierte Frequenzen
        const customFreqNameInput = document.getElementById('customFreqNameInput');
        const customFreqValueInput = document.getElementById('customFreqValueInput');
        const addCustomFreqBtn = document.getElementById('addCustomFreqBtn');
        const customFrequenciesContainer = document.getElementById('customFrequenciesContainer');
        const exportCustomFrequenciesBtn = document.getElementById('exportCustomFrequenciesBtn');
        const importCustomFrequenciesInput = document.getElementById('importCustomFrequenciesInput');


        // Renamed/Combined automation buttons
        const toggleAutomationBtn = document.getElementById('toggleAutomationBtn');
        const debugToggle = document.getElementById('debugToggle');
        const freezeToggle = document.getElementById('freezeToggle');
        const forceOutputToggle = document.getElementById('forceOutputToggle');
        const debugLog = document.getElementById('debugLog');
        const currentFreqDisplay = document.getElementById('currentFreqDisplay');
        const currentFreqValueSpan = document.getElementById('currentFreqValue');
        const targetFreqDisplay = document.getElementById('targetFreqDisplay');
        const targetFreqValueSpan = document.getElementById('targetFreqValue');
        const inputDropdown = document.getElementById('inputDropdown');
        const outputDropdown = document.getElementById('outputDropdown');
        const codeRemixLink = document.getElementById('codeRemixLink');
        const dynamicAutomationDescriptionDuration = document.getElementById('dynamicAutomationDescriptionDuration');

        // Recording/Playback DOM elements
        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const recordCountdownSpan = document.getElementById('recordCountdown');
        const playCountdownSpan = document.getElementById('playCountdown');
        const forcePassthroughCheckbox = document.getElementById('forcePassthroughCheckbox');

        // Gain Visualizer DOM elements
        const micGainVisualizer = document.getElementById('micGainVisualizer');
        const micGainBar = micGainVisualizer.querySelector('.mic-gain-bar');

        // New DOM elements for automation duration
        const automationDurationInput = document.getElementById('automationDurationInput');
        const automationDurationValueSpan = document.getElementById('automationDurationValue');

        // Variable to hold the base text for the play button after recording
        let playButtonCurrentBaseText = 'File abspielen';

        // Collapsible section elements
        const importantFrequenciesHeader = document.getElementById('importantFrequenciesHeader');
        const importantFrequenciesContent = document.getElementById('importantFrequenciesContent');
        const importantFrequenciesArrow = document.getElementById('importantFrequenciesArrow');

        // New collapsible section elements
        const appUsageHeader = document.getElementById('appUsageHeader');
        const appUsageContent = document.getElementById('appUsageContent');
        const appUsageArrow = document.getElementById('appUsageArrow');

        const faqHeader = document.getElementById('faqHeader');
        const faqContent = document.getElementById('faqContent');
        const faqArrow = document.getElementById('faqArrow');

        const linksHeader = document.getElementById('linksHeader');
        const linksContent = document.getElementById('linksContent');
        const linksArrow = document.getElementById('linksArrow');

        const aboutAppHeader = document.getElementById('aboutAppHeader');
        const aboutAppContent = document.getElementById('aboutAppContent');
        const aboutAppArrow = document.getElementById('aboutAppArrow');

        // Language selection DOM Element and browser language display
        const languageDropdown = document.getElementById('languageDropdown');
        const browserLanguageDisplay = document.getElementById('browserLanguageDisplay');

        // Sorting Dropdown
        const sortDropdown = document.getElementById('sortDropdown');

        const canvasCtx = frequencyCanvas.getContext('2d');

        // State variables
        let isPlaying = false; // For manual playback
        let isMicActive = false;
        let OVERLAP_THRESHOLD_DB = -55; // Initial value, now adjustable

        // Constants for visualization and detection
        const SMOOTHING_TIME_CONSTANT = 0.8; // How much the new value influences the current value
        const FFT_SIZE = 2048; // Number of samples for FFT. Must be a power of 2.
        const RECORD_PLAY_DURATION_SEC = 5; // Duration for recording and playing audio

        // Global Set to track checked presets by their overallIndex in ALL_PRESET_FREQUENCIES
        let checkedPresetIndices = new Set();
        // Map to store event listeners for force output mode, to properly detach them
        const forceModeListeners = new Map();

        // --- Preset Frequencies (immutable master data) ---
        const STANDARD_FREQUENCIES = [
            { name: "Schumann-Resonanz (Erde - Grundwelle)", freq: 7.83, category: "standard" },
            { name: "Schumann-Resonanz (Erde - 2. Harmonie)", freq: 14.1, category: "standard" },
            { name: "Schumann-Resonanz (Erde - 3. Harmonie)", freq: 20.3, category: "standard" },
            { name: "Solfeggio Ut (Befreiung von Schuld & Angst)", freq: 396, category: "standard" },
            { name: "Solfeggio Re (Transformation & Wunder)", freq: 417, category: "standard" },
            { name: "Solfeggio Mi (DNA-Reparatur & Zellregeneration)", freq: 528, category: "standard" },
            { name: "Solfeggio Fa (Verbindungen & Beziehungen)", freq: 639, category: "standard" },
            { name: "Solfeggio Sol (Intuition & Göttliche Führung)", freq: 741, category: "standard" },
            { name: "Solfeggio La (Rückkehr zur Einheit)", freq: 852, category: "standard" },
            { name: "Heilende Wasserfrequenz", freq: 432, category: "standard" },
            { name: "Herzchakra Harmonisierung", freq: 639, category: "standard" },
            { name: "Wurzelchakra Stabilisierung", freq: 256, category: "standard" },
            { name: "Sakralchakra Kreativität", freq: 303, category: "standard" },
            { name: "Solarplexuschakra Kraft", freq: 320, category: "standard" },
            { name: "Halschakra Ausdruck", freq: 384, category: "standard" },
            { name: "Stirnchakra Intuition", freq: 768, category: "standard" },
            { name: "Kronenchakra Verbindung", freq: 963, category: "standard" },
            { name: "Ganzkörper-Entspannung (Delta-Wellen)", freq: 4, category: "standard" },
            { name: "Klarheit des Geistes (Gamma-Wellen)", freq: 40, category: "standard" },
            { name: "Tiefe Erdung", freq: 1.2, category: "standard" },
        ];

        const MYSTICAL_FREQUENCIES = [
            { name: "Wassertropfen-Muster (Cymatik)", freq: 111, category: "mystical" },
            { name: "Schildkrötenpanzer-Muster", freq: 128, category: "mystical" },
            { name: "Schneckenhaus-Spirale", freq: 96, category: "mystical" },
            { name: "Bienenwaben-Struktur", freq: 444, category: "mystical" },
            { name: "Farnblatt-Fraktal", freq: 161.8, category: "mystical" }
        ];

        const SPEECH_FREQUENCY_PRESET = { name: "Menschliche Sprechfrequenz erkennen (Test)", freq: 180, isRange: true, minFreq: 80, maxFreq: 300, category: "speech" };

        const HARMONY_FREQUENCIES = [
            { name: "Divine Frequency", freq: 444, category: "harmony" }, { name: "Miracle Frequency", freq: 777, category: "harmony" },
            { name: "Completion/Unity", freq: 999, category: "harmony" }, { name: "Angelic Frequency", freq: 111, category: "harmony" },
            { name: "Change/Transformation", freq: 555, category: "harmony" }, { name: "Abundance/Balance", freq: 888, category: "harmony" },
            { name: "Nikola Teslas Code", freq: 369, category: "harmony" }, { name: "Growth", freq: 484, category: "harmony" },
            { name: "Serenity", freq: 686, category: "harmony" }, { name: "New Beginnings", freq: 1001, category: "harmony" },
            { name: "Spiritual Alignment", freq: 1212, category: "harmony" }, { name: "Positive Change", freq: 1313, category: "harmony" },
            { name: "Inner Guidance", freq: 1414, category: "harmony" }, { name: "Love/Romance", freq: 1515, category: "harmony" },
            { name: "Spiritual Journey", freq: 1616, category: "harmony" }, { name: "Manifestation", freq: 1717, category: "harmony" },
            { name: "New Cycles", freq: 1818, category: "harmony" }, { name: "Divine Purpose", freq: 1919, category: "harmony" },
            { name: "Clarity/Vision", freq: 2020, category: "harmony" }, { name: "Harmony/Balance", freq: 2121, category: "harmony" }
        ];

        const ENVIRONMENT_FREQUENCIES = [
            { name: "Whale Song", freq: 52, category: "environment" }, { name: "Elephant Subsonic", freq: 18, category: "environment" },
            { name: "Earth Hum", freq: 60, category: "environment" }, { name: "Bird Song Average", freq: 250, category: "environment" },
            { name: "Insect Buzz", freq: 4000, category: "environment" }, { name: "Geomagnetic Pulsation", freq: 10, category: "environment" },
            { name: "Rainfall Sound", freq: 1500, category: "environment" }, { name: "Wind Gusts", freq: 2000, category: "environment" },
            { name: "Thunder Rumbles", freq: 30, category: "environment" }, { name: "Ocean Waves", freq: 75, category: "environment" },
            { name: "River Flow", freq: 120, category: "environment" }, { name: "Earthquake Minor", freq: 20, category: "environment" },
            { name: "Tree Rustling", freq: 50, category: "environment" }, { name: "Crickets Chirping", freq: 300, category: "environment" },
            { name: "Frog Croaks", freq: 800, category: "environment" }, { name: "Mosquito Whine", freq: 1500, category: "environment" },
            { name: "Bee Humming", freq: 2500, category: "environment" }, { name: "Wolf Howl", freq: 45, category: "environment" },
            { name: "Cicada Song", freq: 3000, category: "environment" }, { name: "Coyote Bark", freq: 700, category: "environment" }
        ];

        // NEU: Array für benutzerdefinierte Frequenzen
        let USER_DEFINED_FREQUENCIES = []; // This will be loaded from localStorage

        // This array must remain in a fixed order and contains ALL possible presets for stable data-index lookups.
        // It needs to be re-generated whenever USER_DEFINED_FREQUENCIES changes, and also when sorting changes.
        let ALL_PRESET_FREQUENCIES = [];

        /**
         * Regenerates the ALL_PRESET_FREQUENCIES array by combining all source presets
         * and applying the current sorting. It then triggers the UI rendering.
         * This is the central point to ensure ALL_PRESET_FREQUENCIES is always sorted
         * for correct data-index mapping.
         */
        function updateAllPresetFrequenciesAndRender() {
            // 1. Capture currently checked presets by their unique identifiers
            const currentlyCheckedUniqueIds = new Set();
            checkedPresetIndices.forEach(idx => {
                const preset = ALL_PRESET_FREQUENCIES[idx];
                if (preset) {
                    if (preset.category === "custom" && preset.customIndex !== undefined) {
                        currentlyCheckedUniqueIds.add(`custom-${preset.customIndex}`);
                    } else if (!preset.isDropdown) { // Standard, mystical, speech
                        currentlyCheckedUniqueIds.add(`${preset.category}-${preset.name}-${preset.freq}`);
                    } else { // Dropdown virtual presets
                        currentlyCheckedUniqueIds.add(`dropdown-${preset.id}`);
                    }
                }
            });

            let combinedPresets = [
                ...STANDARD_FREQUENCIES,
                ...MYSTICAL_FREQUENCIES,
                SPEECH_FREQUENCY_PRESET,
                ...USER_DEFINED_FREQUENCIES.map((p, index) => ({ ...p, category: "custom", customIndex: index }))
            ];

            const sortType = sortDropdown.value;

            switch (sortType) {
                case 'alphabetical':
                    combinedPresets.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'frequency_asc':
                    combinedPresets.sort((a, b) => a.freq - b.freq);
                    break;
                case 'frequency_desc':
                    combinedPresets.sort((a, b) => b.freq - a.freq);
                    break;
                case 'thematic':
                default:
                    // For 'thematic', reconstruct in original defined order
                    combinedPresets = [
                        ...STANDARD_FREQUENCIES,
                        ...MYSTICAL_FREQUENCIES,
                        SPEECH_FREQUENCY_PRESET,
                        ...USER_DEFINED_FREQUENCIES.map((p, index) => ({ ...p, category: "custom", customIndex: index }))
                    ];
                    break;
            }

            // Now, ALL_PRESET_FREQUENCIES will hold the sorted list of actual presets.
            // We add the virtual dropdown presets *after* sorting, so their indices are stable at the end.
            ALL_PRESET_FREQUENCIES = [
                ...combinedPresets,
                { id: 'enableHarmonyFreq', name: "Harmony Selected", freq: null, isDropdown: true, elementId: 'enableHarmonyFreq' },
                { id: 'enableEnvironmentFreq', name: "Environment Selected", freq: null, isDropdown: true, elementId: 'enableEnvironmentFreq' }
            ];

            // 2. Clear and then rebuild checkedPresetIndices based on the new ALL_PRESET_FREQUENCIES
            checkedPresetIndices.clear();
            ALL_PRESET_FREQUENCIES.forEach((preset, index) => {
                let uniqueId;
                if (preset.category === "custom" && preset.customIndex !== undefined) {
                    uniqueId = `custom-${preset.customIndex}`;
                } else if (!preset.isDropdown) {
                    uniqueId = `${preset.category}-${preset.name}-${preset.freq}`;
                } else {
                    uniqueId = `dropdown-${preset.id}`;
                }

                if (currentlyCheckedUniqueIds.has(uniqueId)) {
                    checkedPresetIndices.add(index);
                }
            });

            // Re-render all sections based on the new ALL_PRESET_FREQUENCIES order.
            renderStandardPresets();
            renderMysticalPresets();
            renderSpeechPreset();
            renderCustomFrequencies();

            // Re-populate and restore selection for Harmony and Environment Dropdowns
            populateHarmonyAndEnvironmentDropdowns();

            // Re-evaluate automation button state, as checked presets might have changed.
            updateAutomationButtonState();
            updateValueBoxesVisibility();
        }


        /**
         * Loads user-defined frequencies from localStorage.
         */
        function loadCustomFrequencies() {
            try {
                const storedFrequencies = localStorage.getItem('userDefinedFrequencies');
                if (storedFrequencies) {
                    const parsed = JSON.parse(storedFrequencies);
                    // Basic validation to ensure it's an array of objects with name and freq
                    if (Array.isArray(parsed) && parsed.every(f => typeof f.name === 'string' && typeof f.freq === 'number')) {
                        USER_DEFINED_FREQUENCIES = parsed;
                        console.log('Benutzerdefinierte Frequenzen aus localStorage geladen.');
                    } else {
                        console.warn('Ungültiges Format für benutzerdefinierte Frequenzen im localStorage. Daten werden ignoriert.');
                        USER_DEFINED_FREQUENCIES = [];
                    }
                }
            } catch (e) {
                console.error('Fehler beim Laden der benutzerdefinierten Frequenzen aus localStorage:', e);
                USER_DEFINED_FREQUENCIES = [];
            }
            updateAllPresetFrequenciesAndRender(); // Re-populate ALL_PRESET_FREQUENCIES after loading and render
        }

        /**
         * Saves user-defined frequencies to localStorage.
         */
        function saveCustomFrequencies() {
            try {
                localStorage.setItem('userDefinedFrequencies', JSON.stringify(USER_DEFINED_FREQUENCIES));
                console.log('Benutzerdefinierte Frequenzen in localStorage gespeichert.');
            } catch (e) {
                console.error('Fehler beim Speichern der benutzerdefinierten Frequenzen in localStorage:', e);
            }
        }


        /**
         * Initializes the AudioContext and related nodes.
         * This should be called only once initially, but its resume logic can be called multiple times.
         */
        async function initAudioContext() {
            // If AudioContext already exists and is not closed, just ensure it's running
            if (audioContext && audioContext.state !== 'closed') {
                if (audioContext.state === 'suspended') {
                    try {
                        await audioContext.resume();
                        console.log('AudioContext resumed.');
                    } catch (error) {
                        console.error('Failed to resume AudioContext:', error);
                        // Do not re-throw, allow the app to continue trying
                    }
                }
                return; // Context is already created and potentially resumed
            }

            // If context doesn't exist or is closed, create a new one
            loadingOverlay.classList.remove('hidden');
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Ensure context is running immediately after creation if it's not already
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                analyser = audioContext.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                analyser.smoothingTimeConstant = SMOOTHING_TIME_CONSTANT;
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                timeDomainData = new Uint8Array(analyser.fftSize);

                analyser.minDecibels = -90;
                analyser.maxDecibels = -10;

                // Create oscillator and outputGainNode ONLY ONCE here
                oscillator = audioContext.createOscillator();
                outputGainNode = audioContext.createGain();
                outputGainNode.gain.value = 0; // Start with 0 gain
                oscillator.connect(outputGainNode);
                outputGainNode.connect(audioContext.destination);
                oscillator.start(0); // Start oscillator once, let gain control sound

                micInputGainNode = audioContext.createGain();
                micInputGainNode.gain.value = parseFloat(micGainRange.value);

                console.log('AudioContext initialisiert und läuft.');
            } catch (error) {
                console.error('Fehler beim Initialisieren des AudioContext:', error);
                console.error('Entschuldigung, Ihr Browser unterstützt die Web Audio API nicht oder es gab ein Problem beim Starten.');
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        }

        /**
         * Starts the frequency generator.
         * @param {number} freq - The frequency to play.
         */
        async function startOscillator(freq) {
            await initAudioContext(); // Ensure AudioContext is running
            if (!audioContext || audioContext.state !== 'running' || !oscillator || !outputGainNode) {
                console.error("AudioContext oder Oszillator/Gain-Node sind nicht bereit zum Abspielen.");
                return;
            }

            // Immediately set frequency
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

            // Cancel any pending gain ramps and ramp up to target volume
            outputGainNode.gain.cancelScheduledValues(audioContext.currentTime);
            // Ensure current value is the start point for ramp (important if previous ramp was interrupted)
            outputGainNode.gain.setValueAtTime(outputGainNode.gain.value, audioContext.currentTime); 
            outputGainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + FADE_TIME);

            isPlaying = true;
            playStopBtn.textContent = 'Manuell stoppen';
            playStopBtn.setAttribute('title', 'Stoppt die manuelle Frequenzwiedergabe');
            playStopBtn.setAttribute('aria-label', 'Manuelle Frequenzwiedergabe stoppen');
            console.log(`Spiele Frequenz: ${freq} Hz (sanft einblendend). AudioContext state: ${audioContext.state}, Target Gain: ${outputGainNode.gain.value}`);
        }

        /**
         * Stops the frequency generator.
         */
        function stopOscillator() {
            if (isPlaying && oscillator && outputGainNode && audioContext) {
                // Smoothly ramp down the gain to 0
                outputGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                outputGainNode.gain.setValueAtTime(outputGainNode.gain.value, audioContext.currentTime); // Ensure current value is the start point for ramp
                outputGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + FADE_TIME);

                // Set isPlaying to false immediately, but the sound will fade out
                isPlaying = false;
                playStopBtn.textContent = 'Manuell abspielen';
                playStopBtn.setAttribute('title', 'Startet die manuelle Frequenzwiedergabe');
                playStopBtn.setAttribute('aria-label', 'Manuelle Frequenzwiedergabe starten');
                console.log('Frequenz gestoppt (sanft ausblendend).');
            }
            currentForcedPreset = null;
            // Ensure UI for automatic playback is hidden even if it wasn't triggered by an automation stop
            currentPlayingPresetSpan.classList.add('hidden');
            overlapMessage.classList.add('hidden');
            document.body.classList.remove('highlight-background');
        }

        /**
         * Updates the frequency of the oscillator and synchronizes both input fields.
         * This function will be called by both the range slider and the number input.
         */
        function updateFrequencyControls(event) {
            let freq;
            if (event.target.id === 'frequencyRange') {
                freq = parseFloat(frequencyRange.value);
                manualFrequencyInput.value = freq.toFixed(2);
            } else if (event.target.id === 'manualFrequencyInput') {
                const rawValue = manualFrequencyInput.value;
                if (rawValue === '' || isNaN(parseFloat(rawValue))) {
                    if (event.type === 'input') return;
                }
                freq = parseFloat(rawValue);
                const min = parseFloat(manualFrequencyInput.min);
                const max = parseFloat(manualFrequencyInput.max);
                freq = Math.max(min, Math.min(max, freq));

                if (event.type === 'input') {
                    frequencyRange.value = freq;
                } else if (event.type === 'change') {
                    manualFrequencyInput.value = freq.toFixed(2);
                    frequencyRange.value = freq;
                }
            } else {
                freq = parseFloat(manualFrequencyInput.value);
            }

            // Update aria-valuenow for both elements
            if (!isNaN(freq)) {
                manualFrequencyInput.setAttribute('aria-valuenow', freq.toFixed(2));
                frequencyRange.setAttribute('aria-valuenow', freq.toFixed(0)); // Range slider usually integer value for aria-valuenow
            }

            // Only update oscillator frequency if manually playing and not in force mode/automation
            if (oscillator && isPlaying && !currentPlayingPresetFrequency && !isForceOutputActive && !isNaN(freq)) {
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            }
            if (!isNaN(freq)) {
                console.log(`Manuelle Frequenz: ${freq.toFixed(2)} Hz`);
            }
        }

        /**
         * Toggles microphone input on/off.
         */
        async function toggleMicrophone() {
            await initAudioContext(); // Ensure AudioContext is running
            if (!audioContext || audioContext.state !== 'running') {
                console.error("AudioContext ist nicht bereit für Mikrofon-Zugriff.");
                return;
            }

            if (isMicActive) {
                // Stop microphone
                if (micStream) {
                    micStream.getTracks().forEach(track => track.stop());
                }
                if (micSourceNode) {
                    micSourceNode.disconnect();
                }
                if (micInputGainNode) {
                    micInputGainNode.disconnect(analyser);
                    if (forcePassthroughCheckbox.checked) {
                        micInputGainNode.disconnect(audioContext.destination);
                    }
                }
                stopSpectrumVisualization();
                micStatusSpan.textContent = 'Mikrofon-Status: Inaktiv';
                micToggleBtn.textContent = 'Mikrofon starten';
                micToggleBtn.setAttribute('title', 'Aktiviert den Mikrofonzugriff für die Frequenzanalyse.');
                micToggleBtn.setAttribute('aria-label', 'Mikrofon starten');
                isMicActive = false;
                micGainRange.disabled = true;
                overlapMessage.classList.add('hidden');
                micPermissionWarning.classList.add('hidden');
                currentPlayingPresetSpan.classList.add('hidden');

                // If automation was active and playing, stop the oscillator
                if (isAutomationActive && currentPlayingPresetFrequency) {
                    stopOscillator(); // Now uses smooth stop
                    currentPlayingPresetFrequency = null; // Clear playing preset
                    console.log('Automatischer Ton gestoppt, da Mikrofon deaktiviert.');
                    document.body.classList.remove('highlight-background'); // Ensure highlight is removed
                }

                recordBtn.disabled = true;
                playBtn.disabled = !recordedBlob;
                forcePassthroughCheckbox.disabled = true;
                forcePassthroughCheckbox.checked = false;

                updateValueBoxesVisibility();
                updateMicGainVisualizerState(); // Update visualizer state

                console.log('Mikrofon gestoppt.');
            } else {
                // Start microphone
                loadingOverlay.classList.remove('hidden');
                try {
                    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    micSourceNode = audioContext.createMediaStreamSource(micStream);

                    micSourceNode.connect(micInputGainNode);
                    micInputGainNode.connect(analyser);

                    if (forcePassthroughCheckbox.checked) {
                        micInputGainNode.connect(audioContext.destination);
                    }

                    micStatusSpan.textContent = 'Mikrofon-Status: Aktiv';
                    micToggleBtn.textContent = 'Mikrofon stoppen';
                    micToggleBtn.setAttribute('title', 'Deaktiviert den Mikrofonzugriff.');
                    micToggleBtn.setAttribute('aria-label', 'Mikrofon stoppen');
                    isMicActive = true;
                    micGainRange.disabled = false;
                    micPermissionWarning.classList.add('hidden');
                    startSpectrumVisualization();

                    recordBtn.disabled = false;
                    forcePassthroughCheckbox.disabled = false;
                    playBtn.disabled = !recordedBlob;

                    updateValueBoxesVisibility();
                    updateMicGainVisualizerState(); // Update visualizer state

                    console.log('Mikrofon gestartet.');
                } catch (error) {
                    console.error('Fehler beim Zugriff auf das Mikrofon:', error);
                    micStatusSpan.textContent = 'Mikrofon-Status: Fehler';
                    micPermissionWarning.classList.remove('hidden');
                    console.error('Konnte nicht auf das Mikrofon zugreifen. Bitte überprüfen Sie Ihre Berechtigungen.');

                    recordBtn.disabled = true;
                    playBtn.disabled = true;
                    forcePassthroughCheckbox.disabled = true;
                    forcePassthroughCheckbox.checked = false;
                    
                    updateValueBoxesVisibility();
                    updateMicGainVisualizerState(); // Update visualizer state even on error

                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            }
        }

        /**
         * Calculates the amplitude (in dB) for a given frequency bin.
         * @param {number} value - The raw amplitude value from analyser.getByteFrequencyData (0-255).
         * @returns {number} The amplitude in dB.
         */
        function getAmplitudeInDb(value) {
            if (!analyser || value === 0) return analyser ? analyser.minDecibels : -90;
            const minDb = analyser.minDecibels;
            const maxDb = analyser.maxDecibels;
            return minDb + (value / 255) * (maxDb - minDb);
        }

        /**
         * Starts the frequency spectrum visualization loop.
         */
        function startSpectrumVisualization() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(drawFrequencySpectrum);
        }

        /**
         * Stops the frequency spectrum visualization loop.
         */
        function stopSpectrumVisualization() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                canvasCtx.clearRect(0, 0, frequencyCanvas.width, frequencyCanvas.height);
            }
        }

        /**
         * Draws the frequency spectrum on the canvas and performs overlap detection for automation.
         */
        function drawFrequencySpectrum() {
            // Added robust checks for analyser and frequencyData
            if (!isMicActive || !analyser || !frequencyData || audioContext.state !== 'running') {
                stopSpectrumVisualization();
                return;
            }

            animationFrameId = requestAnimationFrame(drawFrequencySpectrum);

            analyser.getByteFrequencyData(frequencyData);
            analyser.getByteTimeDomainData(timeDomainData); // For mic gain visualizer

            // Update aria-valuenow for micGainVisualizer
            const rmsValue = calculateRMS(timeDomainData);
            micGainVisualizer.setAttribute('aria-valuenow', Math.round(rmsValue * 100)); // Assuming 0-100 scale for aria

            const WIDTH = frequencyCanvas.width;
            const HEIGHT = frequencyCanvas.height;

            canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
            canvasCtx.fillStyle = 'rgb(226, 232, 240)'; // Canvas background
            canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

            const barWidth = (WIDTH / analyser.frequencyBinCount) * 2.5; // Adjusted to spread out
            let x = 0;

            let currentPeakFreq = 0;
            let maxAmplitudeOverall = analyser.minDecibels;

            // Draw vertical bars
            for (let i = 0; i < analyser.frequencyBinCount; i++) {
                const value = frequencyData[i]; // 0-255
                const amplitudeDb = getAmplitudeInDb(value);

                if (amplitudeDb > maxAmplitudeOverall) {
                    maxAmplitudeOverall = amplitudeDb;
                    currentPeakFreq = i * (audioContext.sampleRate / analyser.fftSize);
                }

                // Calculate bar height based on amplitude relative to maxDecibels (top of canvas) and minDecibels (bottom of canvas)
                const normalizedHeight = (amplitudeDb - analyser.minDecibels) / (analyser.maxDecibels - analyser.minDecibels);
                const barHeight = normalizedHeight * HEIGHT;

                canvasCtx.fillStyle = 'rgb(' + (value + 100) + ',50,50)'; // Color based on amplitude
                canvasCtx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight); // Draw from bottom up

                x += barWidth + 1; // Spacing between bars
            }

            // Draw the red horizontal threshold line based on OVERLAP_THRESHOLD_DB
            // Convert dB value to Y-coordinate on the canvas
            // Y-axis: 0 (top) is maxDecibels, HEIGHT (bottom) is minDecibels
            const normalizedThresholdY = (OVERLAP_THRESHOLD_DB - analyser.minDecibels) / (analyser.maxDecibels - analyser.minDecibels);
            const thresholdY = HEIGHT - (normalizedThresholdY * HEIGHT); // Invert Y-axis for drawing

            canvasCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; // Bright red, semi-transparent
            canvasCtx.lineWidth = 2;
            canvasCtx.setLineDash([5, 5]); // Dashed line
            canvasCtx.beginPath();
            canvasCtx.moveTo(0, thresholdY);
            canvasCtx.lineTo(WIDTH, thresholdY);
            canvasCtx.stroke();
            canvasCtx.setLineDash([]); // Reset line dash

            // Update Mic Gain Visualizer (RMS based)
            let sumSquares = 0;
            for (let i = 0; i < timeDomainData.length; i++) {
                const value = (timeDomainData[i] - 128) / 128; // Normalize to -1 to 1
                sumSquares += value * value;
            }
            const rms = Math.sqrt(sumSquares / timeDomainData.length);
            
            const visualLevel = Math.min(1, rms * 2); // Scale RMS to a visual level (e.g., 0-1)
            micGainBar.style.width = `${visualLevel * 100}%`;

            // Note: micGainVisualizer visibility is now managed by updateMicGainVisualizerState()
            // This loop only updates the bar's width if visible.


            // Update "Ist-Wert" und "Zielwert" displays
            updateValueBoxesVisibility();
            if (!currentFreqDisplay.classList.contains('hidden')) {
                currentFreqValueSpan.textContent = `${currentPeakFreq.toFixed(1)} Hz`; // Peak frequency
            }


            // Automation logic:
            if (!isForceOutputActive && isAutomationActive) {
                const binWidth = audioContext.sampleRate / analyser.fftSize;
                let highestPriorityOverlappingPreset = null;
                let presetsToMonitor = [];

                // Add selected standard, mystical, and speech presets (checkboxes)
                // Filter ALL_PRESET_FREQUENCIES to include only those that are currently checked AND not dropdowns
                ALL_PRESET_FREQUENCIES.forEach((preset, index) => {
                    if (!preset.isDropdown) {
                        const checkbox = document.getElementById(`preset-${index}`);
                        if (checkbox && checkbox.checked) {
                            presetsToMonitor.push(preset);
                        }
                    }
                });

                // Add selected harmony frequency if enabled
                if (enableHarmonyFreq.checked) {
                    const freq = parseFloat(harmonyFrequencyDropdown.value);
                    if (!isNaN(freq)) {
                        presetsToMonitor.push({ name: harmonyFrequencyDropdown.selectedOptions[0].text, freq: freq, category: "harmony" });
                    }
                }

                // Add selected environment frequency if enabled
                if (enableEnvironmentFreq.checked) {
                    const freq = parseFloat(environmentFrequencyDropdown.value);
                    if (!isNaN(freq)) {
                        presetsToMonitor.push({ name: environmentFrequencyDropdown.selectedOptions[0].text, freq: freq, category: "environment" });
                    }
                }
                
                // Now, iterate through `presetsToMonitor` to find overlaps
                for (const preset of presetsToMonitor) {
                    let isOverlapping = false;
                    const targetFreq = preset.freq;
                    const targetBin = Math.round(targetFreq / binWidth);

                    let maxAmplitudeInTargetArea = analyser.minDecibels;

                    // Check target bin and immediate neighbors to account for FFT spread
                    const binsToCheck = [];
                    // Ensure bins are within valid range
                    if (targetBin >= 0 && targetBin < analyser.frequencyBinCount) {
                        binsToCheck.push(targetBin);
                    }
                    if (targetBin - 1 >= 0) { // Check left neighbor if exists
                        binsToCheck.push(targetBin - 1);
                    }
                    if (targetBin + 1 < analyser.frequencyBinCount) { // Check right neighbor if exists
                        binsToCheck.push(targetBin + 1);
                    }

                    for (const bin of binsToCheck) {
                        const amplitudeDb = getAmplitudeInDb(frequencyData[bin]);
                        if (amplitudeDb > maxAmplitudeInTargetArea) {
                            maxAmplitudeInTargetArea = amplitudeDb;
                        }
                    }
                    if (maxAmplitudeInTargetArea > OVERLAP_THRESHOLD_DB) {
                        isOverlapping = true;
                    }

                    if (isOverlapping) {
                        highestPriorityOverlappingPreset = preset;
                        break; // Found highest priority overlapping preset, exit loop
                    }
                }

                if (highestPriorityOverlappingPreset) {
                    // Eine Frequenz wird im Mikrofon erkannt
                    if (!currentPlayingPresetFrequency) {
                        // Fall 1: Keine Frequenz wird aktuell abgespielt, starte die neu erkannte.
                        startOscillator(highestPriorityOverlappingPreset.freq);
                        currentPlayingPresetFrequency = highestPriorityOverlappingPreset;
                        playbackStartedAt = audioContext.currentTime; // Setze Startzeit für min. Dauer, falls später benötigt
                        currentPlayingPresetNameSpan.textContent = highestPriorityOverlappingPreset.name;
                        currentPlayingPresetFreqSpan.textContent = highestPriorityOverlappingPreset.isRange ? `${highestPriorityOverlappingPreset.minFreq}-${highestPriorityOverlappingPreset.maxFreq} Hz` : `${highestPriorityOverlappingPreset.freq} Hz`;
                        currentPlayingPresetSpan.classList.remove('hidden');
                        overlapMessage.classList.remove('hidden');
                        document.body.classList.add('highlight-background');
                        console.log(`Automatischer Start: ${highestPriorityOverlappingPreset.name} (${highestPriorityOverlappingPreset.freq} Hz)`);
                    } else if (currentPlayingPresetFrequency.freq !== highestPriorityOverlappingPreset.freq) {
                        // Fall 2: Eine andere Frequenz wird erkannt. Prüfe Mindestwiedergabedauer.
                        const timeElapsedSinceLastSwitch = audioContext.currentTime - playbackStartedAt;
                        if (timeElapsedSinceLastSwitch * 1000 >= playbackDurationMs) { // Check if min duration has passed
                            stopOscillator(); // Stoppe die aktuelle (mit Rampe)
                            startOscillator(highestPriorityOverlappingPreset.freq); // Starte die neue (mit Rampe)
                            currentPlayingPresetFrequency = highestPriorityOverlappingPreset;
                            playbackStartedAt = audioContext.currentTime; // Setze Startzeit für den neuen Ton
                            currentPlayingPresetNameSpan.textContent = highestPriorityOverlappingPreset.name;
                            currentPlayingPresetFreqSpan.textContent = highestPriorityOverlappingPreset.isRange ? `${highestPriorityOverlappingPreset.minFreq}-${highestPriorityOverlappingPreset.maxFreq} Hz` : `${highestPriorityOverlappingPreset.freq} Hz`;
                            currentPlayingPresetSpan.classList.remove('hidden');
                            overlapMessage.classList.remove('hidden');
                            document.body.classList.add('highlight-background');
                            console.log(`Automatischer Wechsel zu: ${highestPriorityOverlappingPreset.name} (${highestPriorityOverlappingPreset.freq} Hz) nach Mindestdauer.`);
                        } else {
                            // Mindestdauer noch nicht erreicht, bleibe bei der aktuellen Frequenz
                            console.log(`Automatisches Mithören: Warten auf Mindestdauer (${playbackDurationMs / 1000} Sek.) vor Wechsel zu ${highestPriorityOverlappingPreset.name}.`);
                            // Keep overlap message and highlight active as a new potential overlap is still present
                            overlapMessage.classList.remove('hidden');
                            document.body.classList.add('highlight-background');
                        }
                    } else {
                        // Fall 3: Dieselbe Frequenz wird immer noch erkannt und wird bereits abgespielt.
                        // Der Ton läuft "ewig" weiter. Nur UI-Status aktualisieren.
                        overlapMessage.classList.remove('hidden'); // Überschneidungsnachricht anzeigen
                        document.body.classList.add('highlight-background'); // Hintergrund hervorheben
                    }
                } else {
                    // Keine Frequenz wird im Mikrofon erkannt.
                    if (currentPlayingPresetFrequency) {
                        // Fall 4: Eine Frequenz wird aktuell abgespielt, aber ihre Quelle wird nicht mehr erkannt.
                        // Gemäss neuer Logik spielt der Ton *unbegrenzt* weiter.
                        overlapMessage.classList.add('hidden'); // Überschneidungsnachricht ausblenden
                        document.body.classList.remove('highlight-background'); // Hintergrund-Hervorhebung entfernen
                        console.log('Automatisches Mithören: Aktuelle Frequenz nicht mehr erkannt, spielt aber weiter (gemäss Logik).');
                        // Hier wird stopOscillator() NICHT aufgerufen.
                    } else {
                        // Fall 5: Keine Frequenz wird erkannt und keine Frequenz wird aktuell abgespielt.
                        // UI sauber halten.
                        overlapMessage.classList.add('hidden');
                        document.body.classList.remove('highlight-background');
                    }
                }
            } else {
                // Automatisierung ist nicht aktiv ODER "Force Output" ist aktiv.
                // Überschneidungsnachricht und Hintergrund-Hervorhebung ausblenden.
                overlapMessage.classList.add('hidden');
                document.body.classList.remove('highlight-background');

                // Wenn Automatisierung gerade deaktiviert wurde und ein Ton spielte, stoppe ihn.
                if (currentPlayingPresetFrequency && isPlaying) {
                    stopOscillator(); // Now uses smooth stop
                    currentPlayingPresetFrequency = null;
                    console.log('Automatischer Ton gestoppt, da Automatisierung deaktiviert.');
                }
            }


            if (debugActive && isMicActive && !isLogFrozen && (audioContext.currentTime * 1000 - lastLogTime) > LOG_INTERVAL_MS) {
                lastLogTime = audioContext.currentTime * 1000;
                let logEntry = `[${new Date().toLocaleTimeString()}] `;

                logEntry += `Peak: ${currentPeakFreq.toFixed(1)} Hz (${maxAmplitudeOverall.toFixed(1)} dB)`;

                const speechPresetIndex = ALL_PRESET_FREQUENCIES.findIndex(p => p.name === SPEECH_FREQUENCY_PRESET.name);
                const speechPreset = ALL_PRESET_FREQUENCIES[speechPresetIndex];
                const speechCheckbox = document.getElementById(`preset-${speechPresetIndex}`);

                if (speechPreset && speechPreset.isRange) {
                    const binWidth = audioContext.sampleRate / analyser.fftSize;
                    const minBin = Math.round(speechPreset.minFreq / binWidth);
                    const maxBin = Math.round(speechPreset.maxFreq / binWidth);
                    const actualMinBin = Math.max(0, minBin);
                    const actualMaxBin = Math.min(analyser.frequencyBinCount - 1, maxBin);
                    let speechRangeAmplitude = 0;

                    if (actualMinBin <= actualMaxBin) { // Ensure the range is valid
                        for (let i = actualMinBin; i <= actualMaxBin; i++) {
                            const value = frequencyData[i];
                            speechRangeAmplitude += value;
                        }
                        const averageSpeechAmplitude = speechRangeAmplitude / (actualMaxBin - actualMinBin + 1);
                        const speechAmplitudeDb = getAmplitudeInDb(averageSpeechAmplitude);
                        logEntry += ` | Sprache (AVG): ${speechAmplitudeDb.toFixed(1)} dB`;
                        if (speechCheckbox && speechCheckbox.checked && speechAmplitudeDb > OVERLAP_THRESHOLD_DB) {
                            logEntry += ` - DETECTED!`;
                        }
                    } else {
                        logEntry += ` | Sprache (AVG): N/A (Ungültiger Frequenzbereich)`;
                    }
                } else {
                    logEntry += ` | Sprache (AVG): N/A (Preset nicht gefunden oder kein Bereich)`;
                }

                debugLog.textContent += logEntry + '\n';
                debugLog.scrollTop = debugLog.scrollHeight;
            }
        }

        /**
         * Generic listener for preset checkboxes.
         * @param {Event} event - The change event from the checkbox.
         */
        const presetCheckboxChangeListener = (event) => {
            const index = parseInt(event.target.dataset.index);
            if (event.target.checked) {
                checkedPresetIndices.add(index);
            } else {
                checkedPresetIndices.delete(index);
            }
            updateAutomationButtonState();
            updateValueBoxesVisibility();
            window.dispatchEvent(new Event("xf:ready"));
        };

        /**
         * Creates a checkbox element for a given preset.
         * Attaches the generic presetCheckboxChangeListener.
         * @param {object} preset - The preset object.
         * @param {string} checkboxColorClass - Tailwind class for checkbox color (e.g., 'text-blue-600').
         * @returns {HTMLElement} The created div element containing the checkbox and label.
         */
        function createPresetCheckbox(preset, checkboxColorClass, labelClassOverride) {
            const div = document.createElement('div');
            div.className = 'flex items-center gap-2';

            let overallIndex = -1;
            if (preset.category === "custom" && preset.customIndex !== undefined) {
                // For custom presets, find by customIndex (which should be unique)
                overallIndex = ALL_PRESET_FREQUENCIES.findIndex(p => p.category === "custom" && p.customIndex === preset.customIndex);
            } else {
                // For non-custom presets, find by name, freq, category
                overallIndex = ALL_PRESET_FREQUENCIES.findIndex(p => p.name === preset.name && p.freq === preset.freq && p.category === preset.category);
            }
            
            // Handle cases where preset might not be found (e.g., dropdown virtual presets)
            // if (overallIndex === -1) { /* error or skip */ }


            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = `form-checkbox h-4 w-4 rounded ${checkboxColorClass}`;
            checkbox.id = `preset-${overallIndex}`;
            checkbox.dataset.index = overallIndex; // Store overall index for lookup
            checkbox.checked = checkedPresetIndices.has(overallIndex); // Set initial checked state
            checkbox.setAttribute('aria-label', `${preset.name} Frequenz aktivieren`);
            checkbox.setAttribute('title', `Wählen Sie diese Option, um die Frequenz ${preset.name} für die Automatisierung zu überwachen.`);


            const label = document.createElement('label');
            label.htmlFor = `preset-${overallIndex}`;
            const displayFreq = preset.isRange ? `${preset.minFreq}-${preset.maxFreq} Hz` : `${preset.freq} Hz`;
            label.className = (labelClassOverride && typeof labelClassOverride === 'string' && labelClassOverride.trim().length)
  ? labelClassOverride
  : 'text-gray-700 text-sm';
            label.textContent = `${preset.name} (${displayFreq})`;

            checkbox.addEventListener('change', presetCheckboxChangeListener);

            div.appendChild(checkbox);
            div.appendChild(label);

            // Add delete icon for custom frequencies
            if (preset.category === "custom") {
                const deleteIcon = document.createElement('span');
                deleteIcon.className = 'delete-icon';
                deleteIcon.textContent = '✖'; // Unicode multiplication sign or 'x'
                deleteIcon.title = `Löschen Sie die benutzerdefinierte Frequenz '${preset.name}'`;
                deleteIcon.setAttribute('aria-label', `Frequenz ${preset.name} löschen`);
                deleteIcon.dataset.customIndex = preset.customIndex; // Store original customIndex for deletion
                deleteIcon.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent checkbox from being toggled if clicking delete icon
                    // Use a confirmation dialog (custom, not alert)
                    showConfirmationDialog(`Möchten Sie die Frequenz '${preset.name} (${preset.freq} Hz)' wirklich löschen?`, () => {
                        const indexToDelete = parseInt(e.target.dataset.customIndex);
                        deleteCustomFrequency(indexToDelete);
                    });
                });
                div.appendChild(deleteIcon);
            }

            return div;
        }

        /**
         * Renders standard presets into their container.
         * It now filters directly from the global, sorted ALL_PRESET_FREQUENCIES.
         */
        function renderStandardPresets() {
            presetFrequenciesContainer.innerHTML = ''; // Clear existing
            ALL_PRESET_FREQUENCIES.filter(p => p.category === 'standard').forEach(preset => {
                presetFrequenciesContainer.appendChild(createPresetCheckbox(preset, 'text-blue-600'));
            });
        }

        /**
         * Renders mystical frequencies into their container.
         * It now filters directly from the global, sorted ALL_PRESET_FREQUENCIES.
         */
        function renderMysticalPresets() {
            mysticalFrequenciesContainer.innerHTML = ''; // Clear existing
            ALL_PRESET_FREQUENCIES.filter(p => p.category === 'mystical').forEach(preset => {
                mysticalFrequenciesContainer.appendChild(createPresetCheckbox(preset, 'text-indigo-600'));
            });
        }

        /**
         * Renders the speech frequency preset into its container.
         * It now filters directly from the global, sorted ALL_PRESET_FREQUENCIES.
         */
        function renderSpeechPreset() {
            speechFrequencyTestContainer.innerHTML = '';
            ALL_PRESET_FREQUENCIES.filter(p => p.category === 'speech').forEach(preset => {
                speechFrequencyTestContainer.appendChild(createPresetCheckbox(preset, 'text-cyan-600', 'text-blue-800 font-medium mr-4'));
            });
        }

        /**
         * Renders custom frequencies into their container.
         * Note: This function will be called *after* ALL_PRESET_FREQUENCIES is updated
         * and filtered for category 'custom' to ensure correct indices.
         */
        function renderCustomFrequencies() {
            customFrequenciesContainer.innerHTML = ''; // Clear existing
            // Filter ALL_PRESET_FREQUENCIES for custom ones, as they now contain the correct overallIndex
            ALL_PRESET_FREQUENCIES.filter(p => p.category === 'custom').forEach(preset => {
                // For custom frequencies, use a distinct color, e.g., text-rose-600
                customFrequenciesContainer.appendChild(createPresetCheckbox(preset, 'text-rose-600'));
            });
        }

        // Global references for force mode dropdown listeners to ensure correct removal
        let forceHarmonyDropdownListener = null;
        let forceEnvironmentDropdownListener = null;

        /**
         * Initializes rendering for dropdowns (Harmony, Environment) and the speech preset.
         * Sets up their initial event listeners (for normal mode).
         */
        function initializePresetRenderers() {
            // Setup listeners for Harmony Frequencies dropdown (normal mode)
            if (enableHarmonyFreq) {
                enableHarmonyFreq.addEventListener('change', () => {
                    // This block runs ONLY if NOT in force output mode, or if the force mode listener is removed.
                    // This listener is for normal automation behavior.
                    if (!isForceOutputActive) { 
                       harmonyFrequencyDropdown.disabled = !enableHarmonyFreq.checked;
                       updateAutomationButtonState();
                       updateValueBoxesVisibility();
                    }
                });
            }
            if (harmonyFrequencyDropdown) {
                harmonyFrequencyDropdown.addEventListener('change', () => {
                    // This block runs ONLY if NOT in force output mode.
                    if (!isForceOutputActive) {
                        updateAutomationButtonState();
                        updateValueBoxesVisibility();
                    }
                });
            }

            // Setup listeners for Environment Frequencies dropdown (normal mode)
            if (enableEnvironmentFreq) {
                enableEnvironmentFreq.addEventListener('change', () => {
                    // This block runs ONLY if NOT in force output mode.
                    if (!isForceOutputActive) {
                        environmentFrequencyDropdown.disabled = !enableEnvironmentFreq.checked;
                        updateAutomationButtonState();
                        updateValueBoxesVisibility();
                    }
                });
            }
            if (environmentFrequencyDropdown) {
                environmentFrequencyDropdown.addEventListener('change', () => {
                    // This block runs ONLY if NOT in force output mode.
                    if (!isForceOutputActive) {
                        updateAutomationButtonState();
                        updateValueBoxesVisibility();
                    }
                });
            }
        }
        
        /**
         * Populates and restores selections for Harmony and Environment Dropdowns.
         * This is now separate from the main ALL_PRESET_FREQUENCIES sorting.
         */
        function populateHarmonyAndEnvironmentDropdowns() {
            const currentHarmonySelection = harmonyFrequencyDropdown ? harmonyFrequencyDropdown.value : null;
            const currentEnvironmentSelection = environmentFrequencyDropdown ? environmentFrequencyDropdown.value : null;

            if (harmonyFrequencyDropdown) {
                let sortedHarmony = [...HARMONY_FREQUENCIES];
                const sortType = sortDropdown.value;
                if (sortType === 'alphabetical') sortedHarmony.sort((a, b) => a.name.localeCompare(b.name));
                else if (sortType === 'frequency_asc') sortedHarmony.sort((a, b) => a.freq - b.freq);
                else if (sortType === 'frequency_desc') sortedHarmony.sort((a, b) => b.freq - a.freq);

                harmonyFrequencyDropdown.innerHTML = sortedHarmony.map(p => `<option value="${p.freq}">${p.name} (${p.freq} Hz)</option>`).join('');
                if (currentHarmonySelection && sortedHarmony.some(p => p.freq == currentHarmonySelection)) {
                    harmonyFrequencyDropdown.value = currentHarmonySelection;
                } else {
                    harmonyFrequencyDropdown.value = sortedHarmony.length > 0 ? sortedHarmony[0].freq : '';
                }
                // Ensure the disabled state is re-applied/restored
                harmonyFrequencyDropdown.disabled = !enableHarmonyFreq.checked;
            }

            if (environmentFrequencyDropdown) {
                let sortedEnvironment = [...ENVIRONMENT_FREQUENCIES];
                const sortType = sortDropdown.value;
                if (sortType === 'alphabetical') sortedEnvironment.sort((a, b) => a.name.localeCompare(b.name));
                else if (sortType === 'frequency_asc') sortedEnvironment.sort((a, b) => a.freq - b.freq);
                else if (sortType === 'frequency_desc') sortedEnvironment.sort((a, b) => b.freq - a.freq);

                environmentFrequencyDropdown.innerHTML = sortedEnvironment.map(p => `<option value="${p.freq}">${p.name} (${p.freq} Hz)</option>`).join('');
                if (currentEnvironmentSelection && sortedEnvironment.some(p => p.freq == currentEnvironmentSelection)) {
                    environmentFrequencyDropdown.value = currentEnvironmentSelection;
                } else {
                    environmentFrequencyDropdown.value = sortedEnvironment.length > 0 ? sortedEnvironment[0].freq : '';
                }
                // Ensure the disabled state is re-applied/restored
                environmentFrequencyDropdown.disabled = !enableEnvironmentFreq.checked;
            }
        }


        /**
         * Populates the input and output audio device dropdowns.
         */
        async function populateAudioDevices() {
            try {
                // Request media devices permissions first to ensure labels are available
                await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                const devices = await navigator.mediaDevices.enumerateDevices();

                inputDropdown.innerHTML = '';
                outputDropdown.innerHTML = '';

                let hasInput = false;
                let hasOutput = false;

                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Gerät (${device.kind})`;
                    option.setAttribute('title', `Audio ${device.kind === 'audioinput' ? 'Eingang' : 'Ausgang'}: ${device.label || `Gerät (${device.kind})`}`);

                    if (device.kind === 'audioinput') {
                        inputDropdown.appendChild(option);
                        hasInput = true;
                    } else if (device.kind === 'audiooutput') {
                        outputDropdown.appendChild(option);
                        hasOutput = true;
                    }
                });

                if (!hasInput) {
                    inputDropdown.innerHTML = '<option value="">Keine Eingabegeräte gefunden</option>';
                    inputDropdown.setAttribute('title', 'Keine Audio-Eingabegeräte verfügbar.');
                }
                if (!hasOutput) {
                    outputDropdown.innerHTML = '<option value="">Keine Ausgabegeräte gefunden</option>';
                    outputDropdown.setAttribute('title', 'Keine Audio-Ausgabegeräte gefunden</option>');
                }

                inputDropdown.disabled = true;
                outputDropdown.disabled = true;

                console.log('Audio-Geräte geladen.');

            } catch (err) {
                console.error('Fehler beim Laden der Audio-Geräte:', err);
                inputDropdown.innerHTML = '<option value="">Zugriff verweigert/Fehler beim Laden</option>';
                outputDropdown.innerHTML = '<option value="">Zugriff verweigert/Fehler beim Laden</option>';
                inputDropdown.setAttribute('title', 'Fehler beim Laden der Eingabegeräte oder Zugriff verweigert.');
                outputDropdown.setAttribute('title', 'Fehler beim Laden der Ausgabegeräte oder Zugriff verweigert.');
            }
        }

        /**
         * Calculates the Root Mean Square (RMS) of audio data.
         * @param {Uint8Array} data - The time domain data from analyser.getByteTimeDomainData().
         * @returns {number} The RMS value (0-1).
         */
        function calculateRMS(data) {
            let sumSquares = 0;
            for (let i = 0; i < data.length; i++) {
                const value = (data[i] - 128) / 128; // Normalize to -1 to 1
                sumSquares += value * value;
            }
            return Math.sqrt(sumSquares / data.length);
        }

        /**
         * Shows a custom confirmation dialog.
         * @param {string} message - The message to display.
         * @param {Function} onConfirm - Callback for confirmation.
         * @param {Function} [onCancel] - Callback for cancellation.
         */
        function showConfirmationDialog(message, onConfirm, onCancel = () => {}) {
            const dialog = document.createElement('div');
            dialog.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
            dialog.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
                    <p class="text-lg font-semibold text-gray-800 mb-4">${message}</p>
                    <div class="flex justify-around gap-4">
                        <button id="confirmDialogBtn" class="bg-red-600 text-white py-2 px-4 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">
                            Bestätigen
                        </button>
                        <button id="cancelDialogBtn" class="bg-gray-300 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400">
                            Abbrechen
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);

            document.getElementById('confirmDialogBtn').onclick = () => {
                onConfirm();
                document.body.removeChild(dialog);
            };
            document.getElementById('cancelDialogBtn').onclick = () => {
                onCancel();
                document.body.removeChild(dialog);
            };
        }

        /**
         * Applies or removes "Force Output" mode.
         * @param {boolean} isActive - True to activate, false to deactivate.
         */
        function applyForceOutputMode(isActive) {
            manualFrequencyInput.disabled = isActive;
            frequencyRange.disabled = isActive;
            playStopBtn.disabled = isActive;
            micGainRange.disabled = isActive;
            sensitivityRange.disabled = isActive;
            automationDurationInput.disabled = isActive;
            sortDropdown.disabled = isActive;
            
            // Disable custom frequency input fields and buttons
            customFreqNameInput.disabled = isActive;
            customFreqValueInput.disabled = isActive;
            addCustomFreqBtn.disabled = isActive;
            exportCustomFrequenciesBtn.disabled = isActive;
            importCustomFrequenciesInput.disabled = isActive;
            // Also disable the label acting as the import button
            document.querySelector('label[for="importCustomFrequenciesInput"]').classList.toggle('disabled', isActive);


            debugToggle.disabled = false;
            freezeToggle.disabled = false;

            // Get reference to the Speech Frequency Test checkbox
            const speechPresetIndex = ALL_PRESET_FREQUENCIES.findIndex(p => p.name === SPEECH_FREQUENCY_PRESET.name && p.category === 'speech');
            const speechCheckbox = document.getElementById(`preset-${speechPresetIndex}`);

            // Get all dynamically inserted preset checkboxes (standard, mystical, custom)
            const allDynamicallyInsertedCheckboxes = Array.from(document.querySelectorAll('#presetFrequenciesContainer input[type="checkbox"], #mysticalFrequenciesContainer input[type="checkbox"], #customFrequenciesContainer input[type="checkbox"]'));

            // Combine all checkboxes that *will* be force-controlled (excluding speech initially, it's re-added below)
            const allForceSelectableCheckboxes = [...allDynamicallyInsertedCheckboxes, enableHarmonyFreq, enableEnvironmentFreq].filter(Boolean);


            if (isActive) {
                stopAutomation();
                stopOscillator();
                if (isMicActive) {
                    toggleMicrophone();
                }
                toggleAutomationBtn.disabled = true;
                
                recordBtn.disabled = true;
                playBtn.disabled = true;
                forcePassthroughCheckbox.disabled = true;
                forcePassthroughCheckbox.checked = false;

                stopSpectrumVisualization();

                // Clear checkedPresetIndices as only one will be active in force mode
                checkedPresetIndices.clear();

                // Disable Speech Frequency Test checkbox and ensure it's unchecked
                if (speechCheckbox) {
                    speechCheckbox.disabled = true;
                    speechCheckbox.checked = false;
                    // Remove its generic listener to prevent unexpected behavior while disabled
                    speechCheckbox.removeEventListener('change', presetCheckboxChangeListener);
                }

                // Apply force mode specific listeners to other checkboxes
                allForceSelectableCheckboxes.forEach(checkbox => {
                    // Temporarily remove the generic change listener
                    checkbox.removeEventListener('change', presetCheckboxChangeListener);
                    checkbox.checked = false; // Ensure they start unchecked
                    checkbox.disabled = false; // Make them clickable

                    // Disable delete icons for custom frequencies in force mode
                    const parentDiv = checkbox.closest('div.flex.items-center.gap-2');
                    const deleteIcon = parentDiv ? parentDiv.querySelector('.delete-icon') : null;
                    if (deleteIcon) deleteIcon.style.pointerEvents = 'none';

                    const forceListener = async (event) => {
                        await initAudioContext();
                        if (!audioContext || audioContext.state !== 'running') return;

                        if (event.target.checked) {
                            // Uncheck all other force-selectable checkboxes
                            allForceSelectableCheckboxes.forEach(otherCheckbox => {
                                if (otherCheckbox !== checkbox && otherCheckbox.checked) {
                                    otherCheckbox.checked = false;
                                    // Disable their respective dropdown if it was active
                                    if (otherCheckbox === enableHarmonyFreq && harmonyFrequencyDropdown) harmonyFrequencyDropdown.disabled = true;
                                    if (otherCheckbox === enableEnvironmentFreq && environmentFrequencyDropdown) environmentFrequencyDropdown.disabled = true;
                                }
                            });
                            
                            // Stop any currently forced preset before starting a new one
                            stopOscillator();

                            // Start oscillator for the newly checked item
                            let selectedPreset = null;
                            if (checkbox === enableHarmonyFreq) {
                                if (harmonyFrequencyDropdown) harmonyFrequencyDropdown.disabled = false; // Enable dropdown
                                selectedPreset = { 
                                    name: harmonyFrequencyDropdown.selectedOptions.length > 0 ? harmonyFrequencyDropdown.selectedOptions[0].textContent : "Harmonie Frequenz", 
                                    freq: parseFloat(harmonyFrequencyDropdown.value), 
                                    isDropdown: true, 
                                    elementId: 'enableHarmonyFreq' 
                                };
                                startOscillator(selectedPreset.freq);
                            } else if (checkbox === enableEnvironmentFreq) {
                                if (environmentFrequencyDropdown) environmentFrequencyDropdown.disabled = false; // Enable dropdown
                                selectedPreset = { name: environmentFrequencyDropdown.selectedOptions.length > 0 ? environmentFrequencyDropdown.selectedOptions[0].textContent : "Umwelt Frequenz", freq: parseFloat(environmentFrequencyDropdown.value), isDropdown: true, elementId: 'enableEnvironmentFreq' };
                                startOscillator(selectedPreset.freq);
                            } else { // It's one of the static presets (Standard, Mystical, Custom)
                                const index = parseInt(checkbox.dataset.index);
                                selectedPreset = ALL_PRESET_FREQUENCIES[index];
                                if (selectedPreset) {
                                    startOscillator(selectedPreset.freq);
                                }
                                // Ensure dropdowns remain disabled if a static preset is checked
                                if (enableHarmonyFreq) harmonyFrequencyDropdown.disabled = true;
                                if (enableEnvironmentFreq) environmentFrequencyDropdown.disabled = true;
                            }
                            currentForcedPreset = selectedPreset; // Set the current forced preset
                            // Update checkedPresetIndices for force mode (only the selected one is relevant)
                            checkedPresetIndices.clear(); // Clear all
                            if (selectedPreset && selectedPreset.isDropdown) {
                                const idx = ALL_PRESET_FREQUENCIES.findIndex(p => p.id === selectedPreset.elementId);
                                if (idx !== -1) checkedPresetIndices.add(idx);
                            } else if (selectedPreset && checkbox.dataset.index !== undefined) {
                                checkedPresetIndices.add(parseInt(checkbox.dataset.index));
                            }

                        } else { // Current checkbox is being unchecked
                            let shouldStopOscillator = true;
                            // Check if any other force-selectable checkbox is still checked
                            if (allForceSelectableCheckboxes.some(otherCheckbox => otherCheckbox.checked)) {
                                shouldStopOscillator = false; // Another one is checked, don't stop
                            }

                            if (shouldStopOscillator) {
                                stopOscillator();
                                currentForcedPreset = null;
                            }
                            // Disable dropdown if its enable checkbox is unchecked
                            if (checkbox === enableHarmonyFreq) harmonyFrequencyDropdown.disabled = true;
                            if (checkbox === enableEnvironmentFreq) environmentFrequencyDropdown.disabled = true;

                            // Remove from checkedPresetIndices
                            const index = parseInt(checkbox.dataset.index);
                            if (!isNaN(index)) checkedPresetIndices.delete(index);
                            if (checkbox === enableHarmonyFreq) checkedPresetIndices.delete(ALL_PRESET_FREQUENCIES.findIndex(p => p.id === 'enableHarmonyFreq'));
                            if (checkbox === enableEnvironmentFreq) checkedPresetIndices.delete(ALL_PRESET_FREQUENCIES.findIndex(p => p.id === 'enableEnvironmentFreq'));
                        }
                        updateValueBoxesVisibility(); // Update debug display
                    };
                    checkbox.addEventListener('change', forceListener);
                    forceModeListeners.set(checkbox.id, forceListener); // Store listener for later removal
                });

                // Add force mode listeners for dropdowns (for when the DROPDOWN VALUE changes)
                if (harmonyFrequencyDropdown) {
                     forceHarmonyDropdownListener = async () => {
                         await initAudioContext();
                         if (audioContext && audioContext.state === 'running') {
                             stopOscillator(); // Stop any previous forced preset
                             startOscillator(parseFloat(harmonyFrequencyDropdown.value));
                             currentForcedPreset = { 
                                name: harmonyFrequencyDropdown.selectedOptions.length > 0 ? harmonyFrequencyDropdown.selectedOptions[0].textContent : "Harmonie Frequenz", 
                                freq: parseFloat(harmonyFrequencyDropdown.value), 
                                isDropdown: true, 
                                elementId: 'enableHarmonyFreq' 
                             };
                             updateValueBoxesVisibility();
                         }
                     };
                     harmonyFrequencyDropdown.addEventListener('change', forceHarmonyDropdownListener);
                     forceModeListeners.set('harmony-dropdown-change-force-listener', forceHarmonyDropdownListener);
                }
                if (environmentFrequencyDropdown) {
                     forceEnvironmentDropdownListener = async () => {
                         await initAudioContext();
                         if (audioContext && audioContext.state === 'running') {
                             stopOscillator(); // Stop any previous forced preset
                             startOscillator(parseFloat(environmentFrequencyDropdown.value));
                             currentForcedPreset = { name: environmentFrequencyDropdown.selectedOptions.length > 0 ? environmentFrequencyDropdown.selectedOptions[0].textContent : "Umwelt Frequenz", freq: parseFloat(environmentFrequencyDropdown.value), isDropdown: true, elementId: 'enableEnvironmentFreq' };
                             updateValueBoxesVisibility();
                         }
                     };
                     environmentFrequencyDropdown.addEventListener('change', forceEnvironmentDropdownListener);
                     forceModeListeners.set('environment-dropdown-change-force-listener', forceEnvironmentDropdownListener);
                }


            } else { // isActive is FALSE (exiting force output mode)
                stopOscillator();
                currentForcedPreset = null;
                updateAutomationButtonState();

                recordBtn.disabled = !isMicActive;
                playBtn.disabled = !recordedBlob;
                forcePassthroughCheckbox.disabled = !isMicActive;
                sortDropdown.disabled = false; // Re-enable sort dropdown

                if (debugActive && isMicActive) {
                    startSpectrumVisualization();
                }

                // Clear checkedPresetIndices upon exiting force mode
                checkedPresetIndices.clear();

                // Re-enable Speech Frequency Test checkbox and re-attach generic listener
                if (speechCheckbox) {
                    speechCheckbox.disabled = false;
                    speechCheckbox.addEventListener('change', presetCheckboxChangeListener); // Re-attach generic listener
                }

                allForceSelectableCheckboxes.forEach(checkbox => {
                    // Remove force mode listener if it exists
                    const forceListener = forceModeListeners.get(checkbox.id);
                    if (forceListener) {
                        checkbox.removeEventListener('change', forceListener);
                        forceModeListeners.delete(checkbox.id);
                    }
                    // Re-attach generic listener
                    checkbox.addEventListener('change', presetCheckboxChangeListener);
                    checkbox.disabled = false; // Ensure they are re-enabled
                    // Their checked state is managed by checkedPresetIndices and the rendering functions

                    // Re-enable delete icons for custom frequencies
                    const parentDiv = checkbox.closest('div.flex.items-center.gap-2');
                    const deleteIcon = parentDiv ? parentDiv.querySelector('.delete-icon') : null;
                    if (deleteIcon) deleteIcon.style.pointerEvents = 'auto';
                });

                // Remove dropdown force change listeners and re-attach normal listeners if needed
                if (harmonyFrequencyDropdown && forceModeListeners.has('harmony-dropdown-change-force-listener')) {
                    harmonyFrequencyDropdown.removeEventListener('change', forceModeListeners.get('harmony-dropdown-change-force-listener'));
                    forceModeListeners.delete('harmony-dropdown-change-force-listener');
                }
                if (environmentFrequencyDropdown && forceModeListeners.has('environment-dropdown-change-force-listener')) {
                    environmentFrequencyDropdown.removeEventListener('change', forceModeListeners.get('environment-dropdown-change-force-listener'));
                    forceModeListeners.delete('environment-dropdown-change-force-listener');
                }
                // The dropdown's disabled state is controlled by its checkbox's state in normal mode
                if (enableHarmonyFreq) harmonyFrequencyDropdown.disabled = !enableHarmonyFreq.checked;
                if (enableEnvironmentFreq) environmentFrequencyDropdown.disabled = !enableEnvironmentFreq.checked;
            }

            updateValueBoxesVisibility(); // Call again for final state
            updateMicGainVisualizerState();
            console.log(`Force Output Mode: ${isActive ? 'Aktiviert' : 'Deaktiviert'}`);
        }

        /**
         * Updates the state and text of the automation toggle button.
         */
        function updateAutomationButtonState() {
            if (isForceOutputActive) {
                toggleAutomationBtn.disabled = true;
                toggleAutomationBtn.textContent = 'Automatisches Mithören starten';
                toggleAutomationBtn.setAttribute('title', 'Automatisches Mithören im Force Output Modus deaktiviert.');
                toggleAutomationBtn.setAttribute('aria-label', 'Automatisches Mithören kann im Force Output Modus nicht gestartet werden.');
                return;
            }

            // Get all preset checkboxes (standard, mystical, custom)
            const allPresetCheckboxes = Array.from(document.querySelectorAll('#presetFrequenciesContainer input[type="checkbox"], #mysticalFrequenciesContainer input[type="checkbox"], #customFrequenciesContainer input[type="checkbox"]'));
            const anyPresetChecked = allPresetCheckboxes.some(cb => cb.checked);
            
            const isHarmonyFreqChecked = enableHarmonyFreq ? enableHarmonyFreq.checked : false;
            const isEnvironmentFreqChecked = enableEnvironmentFreq ? enableEnvironmentFreq.checked : false;

            const anyAutomationActive = anyPresetChecked || isHarmonyFreqChecked || isEnvironmentFreqChecked;

            if (isAutomationActive) {
                if (!anyAutomationActive) {
                    console.log('Automatisches Mithören gestoppt, da keine Frequenzen mehr ausgewählt sind.');
                    stopAutomation();
                    return;
                }
                toggleAutomationBtn.disabled = false;
                toggleAutomationBtn.textContent = 'Automatisches Mithören stoppen';
                toggleAutomationBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'focus:ring-yellow-300');
                toggleAutomationBtn.classList.add('bg-red-600', 'hover:bg-red-700', 'focus:ring-red-300');
                toggleAutomationBtn.setAttribute('title', 'Stoppt die automatische Frequenzerkennung und -wiedergabe.');
                toggleAutomationBtn.setAttribute('aria-label', 'Automatisches Mithören stoppen.');

            } else {
                toggleAutomationBtn.disabled = !anyAutomationActive;
                toggleAutomationBtn.textContent = 'Automatisches Mithören starten';
                toggleAutomationBtn.classList.remove('bg-red-600', 'hover:bg-red-700', 'focus:ring-red-300');
                toggleAutomationBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700', 'focus:ring-yellow-300');
                toggleAutomationBtn.setAttribute('title', 'Startet die automatische Frequenzerkennung und -wiedergabe.');
                toggleAutomationBtn.setAttribute('aria-label', 'Automatisches Mithören starten.');
            }
            updateValueBoxesVisibility();
        }

        /**
         * Controls the visibility and content of the "Ist-Wert" und "Zielwert" display boxes.
         */
        function updateValueBoxesVisibility() {
            // Get all preset checkboxes (standard, mystical, speech, custom) and filter for checked ones
            const checkedCheckboxes = Array.from(document.querySelectorAll('#presetFrequenciesContainer input[type="checkbox"], #mysticalFrequenciesContainer input[type="checkbox"], #speechFrequencyTestContainer input[type="checkbox"], #customFrequenciesContainer input[type="checkbox"]'))
                                             .filter(checkbox => checkbox.checked);
            
            const isHarmonyFreqChecked = enableHarmonyFreq ? enableHarmonyFreq.checked : false;
            const isEnvironmentFreqChecked = enableEnvironmentFreq ? enableEnvironmentFreq.checked : false;

            const shouldBeVisible = debugActive && isMicActive && !isLogFrozen && !isForceOutputActive;

            // Determine target frequency display based on active automation mode
            let targetText = 'N/A';
            let showTargetBox = false;

            if (shouldBeVisible) {
                let activeFrequencies = [];

                checkedCheckboxes.forEach(checkbox => {
                    const index = parseInt(checkbox.dataset.index);
                    const preset = ALL_PRESET_FREQUENCIES[index];
                    if (preset) {
                        activeFrequencies.push(preset.isRange ? `${preset.minFreq}-${preset.maxFreq} Hz` : `${preset.freq} Hz`);
                    }
                });

                if (isHarmonyFreqChecked) {
                    const freq = parseFloat(harmonyFrequencyDropdown.value);
                    if (!isNaN(freq)) {
                        activeFrequencies.push(`${freq.toFixed(1)} Hz (Harmonie)`);
                    }
                }
                if (isEnvironmentFreqChecked) {
                    const freq = parseFloat(environmentFrequencyDropdown.value);
                    if (!isNaN(freq)) {
                        activeFrequencies.push(`${freq.toFixed(1)} Hz (Umwelt)`);
                    }
                }

                if (activeFrequencies.length > 0) {
                    targetText = activeFrequencies.join(' & ');
                    showTargetBox = true;
                }
            } else if (isForceOutputActive && currentForcedPreset) { // Show target in force output mode
                targetText = currentForcedPreset.isRange ? 
                                `${currentForcedPreset.minFreq}-${currentForcedPreset.maxFreq} Hz` : 
                                `${currentForcedPreset.freq} Hz`;
                showTargetBox = true;
            }


            // Update visibility and text
            if (debugActive && isMicActive && !isLogFrozen && showTargetBox) {
                currentFreqDisplay.classList.remove('hidden');
                targetFreqDisplay.classList.remove('hidden');
                targetFreqValueSpan.textContent = targetText;
            } else {
                currentFreqDisplay.classList.add('hidden');
                targetFreqDisplay.classList.add('hidden');
                currentFreqValueSpan.textContent = 'N/A';
                targetFreqValueSpan.textContent = 'N/A';
            }
        }


        /**
         * Starts the automatic frequency assistant.
         */
        async function startAutomation() {
            if (isForceOutputActive) {
                console.log('Automatischer Frequenz-Assistent ist im "Force Output" Modus deaktiviert.');
                return;
            }

            // Get all preset checkboxes (standard, mystical, speech, custom)
            const allPresetCheckboxes = Array.from(document.querySelectorAll('#presetFrequenciesContainer input[type="checkbox"], #mysticalFrequenciesContainer input[type="checkbox"], #speechFrequencyTestContainer input[type="checkbox"], #customFrequenciesContainer input[type="checkbox"]'));
            const anyPresetChecked = allPresetCheckboxes.some(cb => cb.checked);

            const isHarmonyFreqChecked = enableHarmonyFreq ? enableHarmonyFreq.checked : false;
            const isEnvironmentFreqChecked = enableEnvironmentFreq ? enableEnvironmentFreq.checked : false;


            if (!anyPresetChecked && !isHarmonyFreqChecked && !isEnvironmentFreqChecked) {
                console.log('Bitte wählen Sie mindestens eine Frequenz für die Automatisierung aus.');
                updateAutomationButtonState();
                return;
            }

            micWasInitiallyOffBeforeAutomation = !isMicActive;

            if (!isMicActive) {
                await toggleMicrophone(); 
                if (!isMicActive) {
                    console.error('Automatisierung konnte nicht gestartet werden: Mikrofonzugriff fehlgeschlagen.');
                    updateAutomationButtonState();
                    return;
                }
            }
            isAutomationActive = true;
            updateAutomationButtonState();
            console.log('Automatischer Frequenz-Assistent gestartet.');
        }

        /**
         * Stops the automatic frequency assistant.
         */
        function stopAutomation() {
            isAutomationActive = false;
            updateAutomationButtonState();

            stopOscillator(); // Now uses smooth stop
            currentPlayingPresetFrequency = null;
            playbackStartedAt = 0;

            currentPlayingPresetSpan.classList.add('hidden');
            overlapMessage.classList.add('hidden'); // Ensure overlap message is hidden on stop
            document.body.classList.remove('highlight-background');

            if (micWasInitiallyOffBeforeAutomation && isMicActive) {
                toggleMicrophone();
            }
            micWasInitiallyOffBeforeAutomation = false;
            console.log('Automatischer Frequenz-Assistent gestoppt.');
        }

        /**
         * Starts audio recording for a fixed duration.
         */
        async function startRecording() {
            await initAudioContext(); // Ensure AudioContext is running
            if (!audioContext || audioContext.state !== 'running') {
                console.error("AudioContext ist nicht bereit für Aufnahme.");
                return;
            }

            if (!isMicActive) {
                console.log("Bitte schalten Sie zuerst das Mikrofon ein, um aufzuzeichnen.");
                return;
            }

            recordBtn.disabled = true;
            playBtn.disabled = true;
            micToggleBtn.disabled = true;
            toggleAutomationBtn.disabled = true;
            forceOutputToggle.disabled = true;
            forcePassthroughCheckbox.disabled = true;

            recordBtn.classList.add('recording');
            recordBtn.querySelector('span:first-child').textContent = '🔴 Aufnahme läuft...';
            recordBtn.setAttribute('title', 'Aufnahme läuft...');
            recordBtn.setAttribute('aria-label', 'Audioaufnahme läuft, bitte warten.');


            audioChunks = [];
            
            if (recordedBlobUrl) {
                URL.revokeObjectURL(recordedBlobUrl);
                recordedBlobUrl = null;
            }
            recordedBlob = null;
            
            playButtonCurrentBaseText = 'File abspielen';
            playBtn.querySelector('span:first-child').textContent = `▶️ ${playButtonCurrentBaseText}`;


            const destinationNode = audioContext.createMediaStreamDestination();
            micInputGainNode.connect(destinationNode);

            mediaRecorder = new MediaRecorder(destinationNode.stream);

            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
                recordedBlob = new Blob(audioChunks, { type: 'audio/webm' });
                recordedBlobUrl = URL.createObjectURL(recordedBlob);
                console.log('Aufnahme beendet. Blob erstellt:', recordedBlob);
                console.log('Aufnahme beendet. Datei bereit zur Wiedergabe.');
                
                recordBtn.classList.remove('recording');
                recordBtn.querySelector('span:first-child').textContent = '⏺️ 5 Sek. Ton aufzeichnen';
                recordBtn.setAttribute('title', 'Zeichnet 5 Sekunden Audio vom Mikrofon auf.');
                recordBtn.setAttribute('aria-label', 'Audio aufzeichnen für 5 Sekunden.');
                recordBtn.disabled = false;

                micToggleBtn.disabled = false;
                updateAutomationButtonState();
                forceOutputToggle.disabled = false;
                forcePassthroughCheckbox.disabled = !isMicActive;

                playBtn.disabled = false; 
                playButtonCurrentBaseText = `File abspielen [Aufnahme (${RECORD_PLAY_DURATION_SEC} Sek.)]`;
                playBtn.querySelector('span:first-child').textContent = `▶️ ${playButtonCurrentBaseText}`;
                playBtn.setAttribute('title', `Spielt die ${RECORD_PLAY_DURATION_SEC} Sekunden Aufnahme ab.`);
                playBtn.setAttribute('aria-label', `Abspielen der ${RECORD_PLAY_DURATION_SEC} Sekunden Aufnahme.`);


                micInputGainNode.disconnect(destinationNode);
            };

            mediaRecorder.start();
            console.log(`Aufnahme für ${RECORD_PLAY_DURATION_SEC} Sekunden gestartet...`);
            console.log('Aufnahme läuft...');
            startCountdown(recordCountdownSpan, RECORD_PLAY_DURATION_SEC, () => {
                if (mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                stopCountdown(recordCountdownSpan);
            });
        }

        /**
         * Resets the playback controls and re-enables relevant buttons.
         */
        function resetPlaybackControls() {
            console.log('Wiedergabe beendet (manuell gestoppt oder natürlich beendet).');
            playBtn.classList.remove('playing');
            
            playBtn.querySelector('span:first-child').textContent = `▶️ ${playButtonCurrentBaseText}`;
            playBtn.setAttribute('title', `Spielt die ${RECORD_PLAY_DURATION_SEC} Sekunden Aufnahme ab.`);
            playBtn.setAttribute('aria-label', `Abspielen der ${RECORD_PLAY_DURATION_SEC} Sekunden Aufnahme.`);
            
            stopCountdown(playCountdownSpan); // Explicitly stop countdown here

            document.body.classList.remove('highlight-background');

            micToggleBtn.disabled = false;
            updateAutomationButtonState();
            forceOutputToggle.disabled = false;
            forcePassthroughCheckbox.disabled = !isMicActive;
            recordBtn.disabled = false;
            playBtn.disabled = !recordedBlob;
        }

        /**
         * Plays the recorded audio.
         */
        async function playRecordedAudio() {
            await initAudioContext(); // Ensure AudioContext is running
            if (!audioContext || audioContext.state !== 'running') {
                console.error("AudioContext ist nicht bereit für Wiedergabe.");
                return;
            }

            if (!recordedBlob || !recordedBlobUrl) {
                console.log("Bitte zeichnen Sie zuerst etwas auf!");
                return;
            }

            recordBtn.disabled = true;
            playBtn.disabled = true;
            micToggleBtn.disabled = true;
            toggleAutomationBtn.disabled = true;
            forceOutputToggle.disabled = true;
            forcePassthroughCheckbox.disabled = true;

            if (audioPlayer.paused) {
                console.log("Play: Starting playback...");
                audioPlayer.src = recordedBlobUrl;
                audioPlayer.currentTime = 0;
                audioPlayer.play();

                playBtn.classList.add('playing');
                playBtn.querySelector('span:first-child').textContent = '⏯️ Abspielen stoppen';
                playBtn.setAttribute('title', 'Stoppt die Audiowiedergabe.');
                playBtn.setAttribute('aria-label', 'Audiowiedergabe stoppen.');

                document.body.classList.add('highlight-background');
                console.log('Wiedergabe gestartet...');
                startCountdown(playCountdownSpan, RECORD_PLAY_DURATION_SEC);
            } else {
                console.log("Stop: Pausing playback...");
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
                resetPlaybackControls(); // This will now correctly stop the countdown
            }
        }

        // Handle when recorded audio playback ends (either naturally or manually stopped)
        audioPlayer.onended = () => {
            console.log("Wiedergabe natürlich beendet.");
            resetPlaybackControls();
        };

        /**
         * Manages a countdown display.
         * @param {HTMLElement} spanElement - The span element to display the countdown.
         * @param {number} duration - The total duration of the countdown in seconds.
         * @param {Function} [callback] - An optional function to call when the countdown finishes.
         */
        function startCountdown(spanElement, duration, callback) {
            let currentCount = duration - 1;

            if (spanElement === recordCountdownSpan) {
                if (recordCountdownInterval) clearInterval(recordCountdownInterval);
                recordCountdownInterval = null;
            } else if (spanElement === playCountdownSpan) {
                if (playCountdownInterval) clearInterval(playCountdownInterval);
                playCountdownInterval = null;
            }

            if (currentCount >= 0) {
                spanElement.textContent = ` (${currentCount}s)`;
            } else {
                spanElement.textContent = '';
            }

            let timerId = setInterval(() => {
                currentCount--;

                if (currentCount >= 0) {
                    spanElement.textContent = ` (${currentCount}s)`;
                } else {
                    clearInterval(timerId);
                    spanElement.textContent = '';
                    if (spanElement === recordCountdownSpan) {
                        recordCountdownInterval = null;
                    } else if (spanElement === playCountdownSpan) {
                        playCountdownInterval = null;
                    }
                    if (callback) callback();
                }
            }, 1000);

            if (spanElement === recordCountdownSpan) {
                recordCountdownInterval = timerId;
            } else if (spanElement === playCountdownSpan) {
                playCountdownInterval = timerId;
            }
        }

        /**
         * Stops the active countdown for a given span element.
         * @param {HTMLElement} spanElement - The span element whose countdown should be stopped.
         */
        function stopCountdown(spanElement) {
            if (spanElement === recordCountdownSpan && recordCountdownInterval) {
                clearInterval(recordCountdownInterval);
                recordCountdownInterval = null;
                spanElement.textContent = '';
            } else if (spanElement === playCountdownSpan && playCountdownInterval) {
                clearInterval(playCountdownInterval);
                playCountdownInterval = null; 
                spanElement.textContent = '';
            }
        }

        // Event Listeners
        frequencyRange.addEventListener('input', updateFrequencyControls);
        manualFrequencyInput.addEventListener('input', updateFrequencyControls);
        manualFrequencyInput.addEventListener('change', updateFrequencyControls);

        micGainRange.addEventListener('input', () => {
            if (micInputGainNode) {
                micInputGainNode.gain.value = parseFloat(micGainRange.value);
            }
            micGainValueSpan.textContent = parseFloat(micGainRange.value).toFixed(2);
            micGainRange.setAttribute('aria-valuenow', parseFloat(micGainRange.value).toFixed(2));
        });

        sensitivityRange.addEventListener('input', () => {
            OVERLAP_THRESHOLD_DB = parseFloat(sensitivityRange.value);
            sensitivityValueSpan.textContent = `${OVERLAP_THRESHOLD_DB}`;
            sensitivityRange.setAttribute('aria-valuenow', OVERLAP_THRESHOLD_DB);
        });
        playStopBtn.addEventListener('click', async () => {
            await initAudioContext();
            if (!audioContext || audioContext.state !== 'running') return;

            if (isForceOutputActive) {
                console.log('Der Frequenz-Generator ist im "Force Output" Modus deaktiviert.');
                return;
            }
            if (isPlaying && !currentPlayingPresetFrequency) {
                stopOscillator();
            } else if (!currentPlayingPresetFrequency) {
                startOscillator(parseFloat(manualFrequencyInput.value));
            } else {
                console.log('Die Automatisierung spielt bereits eine Frequenz ab. Bitte stoppen Sie diese zuerst, um manuell abzuspielen.');
            }
        });
        micToggleBtn.addEventListener('click', async () => {
            await initAudioContext();
            if (!audioContext || audioContext.state !== 'running') return;

            if (isForceOutputActive) {
                console.log('Das Mikrofon kann im "Force Output" Modus nicht manuell gesteuert werden. Es wird bei Bedarf automatisch gestoppt.');
                return;
            }
            toggleMicrophone();
        });

        // Combined automation button click listener
        toggleAutomationBtn.addEventListener('click', async () => {
            await initAudioContext();
            if (!audioContext || audioContext.state !== 'running') return;

            if (isAutomationActive) {
                stopAutomation();
            } else {
                startAutomation();
            }
        });

        // Debug toggle event listener
        debugToggle.addEventListener('change', async () => {
            debugActive = debugToggle.checked;
            if (debugActive) {
                debugLog.classList.remove('hidden');
                debugLog.textContent = '--- Debug-Log gestartet ---\n';
                lastLogTime = 0;
                
                await initAudioContext();
                if (!audioContext || audioContext.state !== 'running') return;

                if (!isMicActive && !isForceOutputActive) {
                    toggleMicrophone();
                } else if (isMicActive) {
                    startSpectrumVisualization();
                }
            } else {
                debugLog.classList.add('hidden');
                debugLog.textContent = '';
                if (!isAutomationActive && isMicActive) {
                    stopSpectrumVisualization();
                }
            }
            updateValueBoxesVisibility();
        });

        // Freeze toggle event listener
        freezeToggle.addEventListener('change', async () => {
            isLogFrozen = freezeToggle.checked;
            if (isLogFrozen) {
                console.log('Debug-Log eingefroren.');
            } else {
                console.log('Debug-Log fortgesetzt.');
                lastLogTime = 0;

                await initAudioContext();
                if (!audioContext || audioContext.state !== 'running') return;

                if (debugActive && isMicActive) {
                    startSpectrumVisualization();
                }
            }
            updateValueBoxesVisibility();
        });

        // Force Output toggle event listener
        forceOutputToggle.addEventListener('change', async () => {
            await initAudioContext();
            if (!audioContext || audioContext.state !== 'running') return;

            isForceOutputActive = forceOutputToggle.checked;
            applyForceOutputMode(isForceOutputActive);
        });

        // Recording and Playback Event Listeners
        recordBtn.addEventListener('click', startRecording);
        playBtn.addEventListener('click', playRecordedAudio);

        // Force Passthrough Checkbox Listener
        forcePassthroughCheckbox.addEventListener('change', async () => {
            await initAudioContext();
            if (!audioContext || audioContext.state !== 'running') {
                console.log('Audio-Kontext ist noch nicht bereit. Bitte klicken Sie zuerst auf "Mikrofon starten".');
                forcePassthroughCheckbox.checked = false;
                return;
            }
            
            if (!isMicActive) {
                console.log('Bitte schalten Sie Sie zuerst das Mikrofon ein, um Passthrough zu aktivieren.');
                forcePassthroughCheckbox.checked = false;
                return;
            }

            if (forcePassthroughCheckbox.checked) {
                micInputGainNode.connect(audioContext.destination);
                console.log('Force Passthrough (Aux-OUT) aktiviert. Beachten Sie mögliche Echos/Drop-Outs.');
                console.log('Mic Input Gain Node connected to AudioContext Destination (Passthrough).');
            } else {
                micInputGainNode.disconnect(audioContext.destination);
                console.log('Force Passthrough (Aux-OUT) deaktiviert.');
                console.log('Mic Input Gain Node disconnected from AudioContext Destination (Passthrough).');
            }
        });

        // Automation Duration Input Listener
        automationDurationInput.addEventListener('input', () => {
            let value = parseInt(automationDurationInput.value);
            const min = parseInt(automationDurationInput.min);
            const max = parseInt(automationDurationInput.max);

            if (isNaN(value) || value < min) {
                value = min;
            } else if (value > max) {
                value = max;
            }
            automationDurationInput.value = value;
            playbackDurationMs = value * 1000;
            
            dynamicAutomationDescriptionDuration.textContent = value; // Update the description text
            automationDurationInput.setAttribute('aria-valuenow', value);
        });

        automationDurationInput.addEventListener('change', () => {
            let value = parseInt(automationDurationInput.value);
            const min = parseInt(automationDurationInput.min);
            const max = parseInt(automationDurationInput.max);

            if (isNaN(value) || value < min) {
                value = min;
            } else if (value > max) {
                value = max;
            }
            automationDurationInput.value = value;
            playbackDurationMs = value * 1000;
            dynamicAutomationDescriptionDuration.textContent = value; // Update the description text
            automationDurationInput.setAttribute('aria-valuenow', value);
            console.log(`Automation Playback Duration set to: ${value} seconds`);
        });

        /**
         * Generic function to toggle collapsible sections.
         * @param {HTMLElement} headerElement - The header element of the collapsible section.
         * @param {HTMLElement} contentElement - The content element of the collapsible section.
         * @param {HTMLElement} arrowElement - The arrow icon element.
         */
        function setupCollapsibleSection(headerElement, contentElement, arrowElement) {
            if (headerElement && contentElement && arrowElement) {
                headerElement.addEventListener('click', () => {
                    const isHidden = contentElement.classList.toggle('hidden');
                    if (isHidden) {
                        arrowElement.textContent = '⬇️'; // Down arrow when hidden
                        headerElement.setAttribute('aria-expanded', 'false');
                    } else {
                        arrowElement.textContent = '⬆️'; // Up arrow when visible
                        headerElement.setAttribute('aria-expanded', 'true');
                    }
                });
            } else {
                console.error("One or more elements for a collapsible section not found!");
            }
        }

        // New helper to manage mic gain visualizer state
        function updateMicGainVisualizerState() {
            if (isMicActive && !isForceOutputActive) {
                micGainVisualizer.classList.remove('hidden');
            } else {
                micGainVisualizer.classList.add('hidden');
                micGainBar.style.width = '0%'; // Ensure bar is reset when hidden
            }
        }

        // --- NEU: Funktionen für Benutzerdefinierte Frequenzen ---
        /**
         * Fügt eine neue benutzerdefinierte Frequenz hinzu.
         */
        addCustomFreqBtn.addEventListener('click', () => {
            const name = customFreqNameInput.value.trim();
            const freq = parseFloat(customFreqValueInput.value);

            if (!name) {
                alert('Bitte geben Sie einen Namen für die Frequenz ein.');
                return;
            }
            if (isNaN(freq) || freq < 0.1 || freq > 20000) {
                alert('Bitte geben Sie eine gültige Frequenz zwischen 0.1 Hz und 20000 Hz ein.');
                return;
            }

            const newCustomFreq = { name: name, freq: freq, category: "custom", customIndex: USER_DEFINED_FREQUENCIES.length };
            USER_DEFINED_FREQUENCIES.push(newCustomFreq);
            saveCustomFrequencies();
            updateAllPresetFrequenciesAndRender(); // Regenerate and re-render all presets
            
            customFreqNameInput.value = '';
            customFreqValueInput.value = '';
            console.log(`Frequenz '${name}' (${freq} Hz) hinzugefügt.`);
        });

        /**
         * Löscht eine benutzerdefinierte Frequenz.
         * @param {number} customIndex - Der einzigartige Index der benutzerdefinierten Frequenz im USER_DEFINED_FREQUENCIES Array.
         */
        function deleteCustomFrequency(customIndex) {
            const initialLength = USER_DEFINED_FREQUENCIES.length;
            USER_DEFINED_FREQUENCIES = USER_DEFINED_FREQUENCIES.filter(f => f.customIndex !== customIndex);

            if (USER_DEFINED_FREQUENCIES.length < initialLength) {
                // Re-assign customIndex to maintain sequential order after deletion
                USER_DEFINED_FREQUENCIES.forEach((f, idx) => f.customIndex = idx);
                saveCustomFrequencies();
                updateAllPresetFrequenciesAndRender(); // Regenerate and re-render all presets
                console.log(`Benutzerdefinierte Frequenz mit customIndex ${customIndex} gelöscht.`);
                // The checkedPresetIndices are handled by updateAllPresetFrequenciesAndRender already
            }
        }

        /**
         * Exportiert benutzerdefinierte Frequenzen als JSON-Datei.
         */
        exportCustomFrequenciesBtn.addEventListener('click', () => {
            const dataStr = JSON.stringify(USER_DEFINED_FREQUENCIES, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const relMatch = (document.getElementById('aboutAppContent')?.textContent || '').match(/Release:\s*Frequency\s*([0-9.]+)/);
            const rel = relMatch ? relMatch[1] : '0.0.0';
            const now = new Date();
            const ts = now.getFullYear().toString() + String(now.getMonth()+1).padStart(2,'0') +
                       String(now.getDate()).padStart(2,'0') + '-' + String(now.getHours()).padStart(2,'0') +
                       String(now.getMinutes()).padStart(2,'0');
            a.download = `x-frequency-${rel}-${ts}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log('Benutzerdefinierte Frequenzen exportiert.');
        });

        /**
         * Importiert benutzerdefinierte Frequenzen aus einer JSON-Datei.
         */
        importCustomFrequenciesInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (Array.isArray(importedData) && importedData.every(f => typeof f.name === 'string' && typeof f.freq === 'number')) {
                        
                        showConfirmationDialog(`Möchten Sie die importierten Frequenzen zur bestehenden Liste hinzufügen oder die bestehende Liste überschreiben?`, () => {
                            // Add logic for adding
                            const newFrequencies = importedData.map((f, idx) => ({ 
                                name: f.name, 
                                freq: f.freq, 
                                category: "custom", 
                                customIndex: USER_DEFINED_FREQUENCIES.length + idx 
                            }));
                            USER_DEFINED_FREQUENCIES.push(...newFrequencies);
                            saveCustomFrequencies();
                            updateAllPresetFrequenciesAndRender();
                            console.log('Benutzerdefinierte Frequenzen hinzugefügt.');
                            // Clear file input to allow re-importing the same file
                            event.target.value = '';
                        }, () => { // On Cancel of "add" implies "overwrite"
                            // Overwriting
                            USER_DEFINED_FREQUENCIES = importedData.map((f, idx) => ({ 
                                name: f.name, 
                                freq: f.freq, 
                                category: "custom", 
                                customIndex: idx 
                            }));
                            saveCustomFrequencies();
                            updateAllPresetFrequenciesAndRender();
                            console.log('Benutzerdefinierte Frequenzen überschrieben.');
                            // Clear file input
                            event.target.value = '';
                        });

                    } else {
                        alert('Ungültiges Dateiformat. Bitte wählen Sie eine JSON-Datei mit einem Array von Frequenzobjekten (Name, Frequenz).');
                        console.error('Ungültiges Dateiformat für benutzerdefinierte Frequenzen:', importedData);
                        event.target.value = ''; // Clear file input
                    }
                } catch (jsonError) {
                    alert('Fehler beim Parsen der JSON-Datei. Stellen Sie sicher, dass es sich um eine gültige JSON-Datei handelt.');
                    console.error('JSON-Parse-Fehler:', jsonError);
                    event.target.value = ''; // Clear file input
                }
            };
            reader.readAsText(file);
        });
        // --- ENDE: Funktionen für Benutzerdefinierte Frequenzen ---


        // Initial setup on window load
        window.onload = () => {
            const resizeCanvas = () => {
                frequencyCanvas.width = frequencyCanvas.offsetWidth;
                frequencyCanvas.height = frequencyCanvas.offsetHeight;
                if (isMicActive && animationFrameId) {
                    drawFrequencySpectrum();
                }
            };
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            loadCustomFrequencies(); // Load custom frequencies first and trigger initial render via updateAllPresetFrequenciesAndRender
            initializePresetRenderers(); // Set up dropdowns initial change listeners

            sensitivityValueSpan.textContent = `${OVERLAP_THRESHOLD_DB}`;
            populateAudioDevices();

            micGainValueSpan.textContent = parseFloat(micGainRange.value).toFixed(2);
            manualFrequencyInput.value = parseFloat(frequencyRange.value).toFixed(2);
            automationDurationInput.value = (playbackDurationMs / 1000).toFixed(0);
            dynamicAutomationDescriptionDuration.textContent = automationDurationInput.value;

            recordBtn.disabled = true;
            playBtn.disabled = !recordedBlob;
            playBtn.querySelector('span:first-child').textContent = `▶️ ${playButtonCurrentBaseText}`;

            forcePassthroughCheckbox.disabled = true;
            
            updateMicGainVisualizerState();

            // Setup and set initial state for collapsible sections
            setupCollapsibleSection(importantFrequenciesHeader, importantFrequenciesContent, importantFrequenciesArrow);
            setupCollapsibleSection(appUsageHeader, appUsageContent, appUsageArrow);
            setupCollapsibleSection(faqHeader, faqContent, faqArrow);
            setupCollapsibleSection(linksHeader, linksContent, linksArrow);
            setupCollapsibleSection(aboutAppHeader, aboutAppContent, aboutAppArrow);

            // Ensure they are hidden on load (and set initial aria-expanded state)
            importantFrequenciesContent.classList.add('hidden');
            importantFrequenciesArrow.textContent = '⬇️';
            importantFrequenciesHeader.setAttribute('aria-expanded', 'false');

            appUsageContent.classList.add('hidden');
            appUsageArrow.textContent = '⬇️';
            appUsageHeader.setAttribute('aria-expanded', 'false');

            faqContent.classList.add('hidden');
            faqArrow.textContent = '⬇️';
            faqHeader.setAttribute('aria-expanded', 'false');

            linksContent.classList.add('hidden');
            linksArrow.textContent = '⬇️';
            linksHeader.setAttribute('aria-expanded', 'false');

            aboutAppContent.classList.add('hidden');
            aboutAppArrow.textContent = '⬇️';
            aboutAppHeader.setAttribute('aria-expanded', 'false');

            // Ensure harmony/environment dropdowns are disabled initially
            if (enableHarmonyFreq) harmonyFrequencyDropdown.disabled = !enableHarmonyFreq.checked;
            if (enableEnvironmentFreq) environmentFrequencyDropdown.disabled = !enableEnvironmentFreq.checked;

            // Display browser language
            if (browserLanguageDisplay) {
                const browserLang = navigator.language || 'N/A';
                let displayLang = '';
                if (browserLang.startsWith('de')) {
                    displayLang = 'Deutsch';
                } else if (browserLang.startsWith('en')) {
                    displayLang = 'English';
                } else {
                    displayLang = browserLang; // Display actual browser language if not de/en
                }
                browserLanguageDisplay.textContent = displayLang; // Removed "Voreingestellt:" from JS
            }

            // Event listener for the sort dropdown
            sortDropdown.addEventListener('change', updateAllPresetFrequenciesAndRender);

            // Set initial aria-valuenow for sliders/inputs
            manualFrequencyInput.setAttribute('aria-valuenow', manualFrequencyInput.value);
            frequencyRange.setAttribute('aria-valuenow', frequencyRange.value);
            micGainRange.setAttribute('aria-valuenow', micGainRange.value);
            sensitivityRange.setAttribute('aria-valuenow', sensitivityRange.value);
            automationDurationInput.setAttribute('aria-valuenow', automationDurationInput.value);
            
            // Initial update of automation button and value boxes (after all setup)
            updateAutomationButtonState();
            updateValueBoxesVisibility();
            window.dispatchEvent(new Event("xf:ready"));
        };
    </script>

<script>
// xf-loader-logic (single-pass)
(function(){
  const el   = document.getElementById('appLoader');
  const text = document.getElementById('loaderText');
  const bar  = document.getElementById('loaderBar');
  if(!el || !text || !bar) return;

  const steps = [
    { p: 0.00, msg: 'Module laden…' },
    { p: 0.33, msg: 'Audio vorbereiten…' },
    { p: 0.66, msg: 'UI initialisieren…' }
  ];

  const start = performance.now();
  const total = 1800; // ms bis 90%
  const holdAt = 0.90;
  let finished = false;

  function setMsg(progress){
    let msg = steps[0].msg;
    for (let i=0;i<steps.length;i++){
      if (progress >= steps[i].p) msg = steps[i].msg;
    }
    text.textContent = msg;
  }

  function setBar(p){
    const clamped = Math.max(0, Math.min(1, p));
    bar.style.width = Math.round(clamped*100) + '%';
  }

  function hide(){
    if (finished) return;
    finished = true;
    el.setAttribute('hidden','');
    setTimeout(()=>{ el.remove && el.remove(); }, 700);
  }

  function finishTo100AndHide(){
    const startW = parseFloat(bar.style.width) || 90;
    const startP = startW / 100;
    const dur = 320;
    const t0 = performance.now();
    (function step2(t){
      const k = Math.min(1, (t - t0)/dur);
      const p = startP + (1 - startP)*k;
      setBar(p);
      if (k < 1) requestAnimationFrame(step2);
      else hide();
    })(performance.now());
  }

  // Animate once to 90%
  (function loop(t){
    if (finished) return;
    const k = Math.min(1, (t - start)/total);
    const p = holdAt * k;
    setBar(p);
    setMsg(p);
    if (k < 1) {
      requestAnimationFrame(loop);
    } else {
      setBar(holdAt);
    }
  })(performance.now());

  window.addEventListener('xf:ready', function(){
    text.textContent = 'Fertig.';
    finishTo100AndHide();
  }, { once:true });

  // Safety: niemals länger als 12s
  setTimeout(()=>{
    if (!finished) {
      text.textContent = 'Start…';
      finishTo100AndHide();
    }
  }, 12000);
})();
</script>



<div id="xf-mini-toggle"><button type="button" id="xfMiniBtn" title="Diagnose ein/aus" >⚙︎ Diagnose</button></div>
<div id="xf-mini-diag" role="region" aria-label="X‑Frequency Diagnose">
  <h4>Diagnose (leicht) <button id="xfMiniClose" title="Schließen" style="float:right; background:transparent; border:0; color:#bcd7ff; cursor:pointer; font-size:14px">×</button></h4>
  <div class="row"><div class="key">Mic Permission</div><div class="val" id="diagMicPerm">–</div></div>
  <div class="row"><div class="key">Output Device</div><div class="val" id="diagOutDev">–</div></div>
  <div class="row"><div class="key">Input Device</div><div class="val" id="diagInDev">–</div></div>
  <div class="row"><div class="key">Input Peak</div><div class="val" id="diagPeak">– dBFS</div></div>
  <div class="row"><div class="key">Release</div><div class="val" id="diagRelease">–</div></div>
  <div class="row"><div class="key">Clipping</div><div class="val"> <span id="clipDot" class="clipping-dot" aria-label="clipping"></span> </div></div>
  <div class="log" id="diagLog" aria-live="polite"></div>
</div>


<script id="diag-mini-js-13439">
(function(){
  const $ = sel => document.querySelector(sel);
  const log = (msg) => {
    const el = $("#diagLog"); if(!el) return;
    const t = new Date().toLocaleTimeString();
    el.textContent += `[${t}] ${msg}\n`; el.scrollTop = el.scrollHeight;
  };
  const diag = {
    setMicPerm(s){ const el=$("#diagMicPerm"); if(el) el.textContent = s; },
    setAC(state){ const el=$("#diagACState"); if(el) el.textContent = state; },
    setOutDev(name){ const el=$("#diagOutDev"); if(el) el.textContent = name || "default"; },
    setRelease(txt){ const el=$("#diagRelease"); if(el) el.textContent = txt; },
    clip(on){ const el=$("#clipDot"); if(el) el.style.opacity = on ? 1 : 0; }
  };
  // Sync Input/Output labels with dropdowns if present
  function syncFromDropdowns(){
    try{
      const inSel = document.querySelector('#inputDropdown');
      const outSel = document.querySelector('#outputDropdown');
      if(inSel){ const opt = inSel.options[inSel.selectedIndex]; const name=(opt?.text||opt?.label||opt?.innerText||'').trim(); if(name) { const el=$("#diagInDev"); if(el) el.textContent = name; } }
      if(outSel){ const opt = outSel.options[outSel.selectedIndex]; const name=(opt?.text||opt?.label||opt?.innerText||'').trim(); if(name) { const el=$("#diagOutDev"); if(el) el.textContent = name; } }
    }catch(e){}
  }
  ['inputDropdown','outputDropdown'].forEach(id => {
    const el = document.getElementById(id);
    if(el) el.addEventListener('change', syncFromDropdowns);
  });
  syncFromDropdowns();

  // Open/close panel; on first open, if mic permission not granted, request once
  let diagOpenedOnce = false;
  const btn = $("#xfMiniBtn"), panel = $("#xf-mini-diag"), closeBtn = $("#xfMiniClose");
  const setVisible = (on)=>{ if(panel) panel.style.display = on ? "block" : "none"; };
  if(btn && panel){
    btn.addEventListener("click", async ()=>{
      const willOpen = (panel.style.display === "none" || !panel.style.display);
      setVisible(willOpen);
      if(willOpen && !diagOpenedOnce){
        diagOpenedOnce = true;
        try {
          if(navigator.permissions && navigator.permissions.query){
            const p = await navigator.permissions.query({name:'microphone'});
            if(p.state !== 'granted'){
              await navigator.mediaDevices.getUserMedia({audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }});
            }
          } else {
            await navigator.mediaDevices.getUserMedia({audio:true});
          }
        } catch(e){ /* user may deny; it's fine */ }
        // After any attempt, refresh permission label and device labels
        try {
          if(navigator.permissions && navigator.permissions.query){
            const p2 = await navigator.permissions.query({name:'microphone'});
            diag.setMicPerm(p2.state);
          }
        } catch(e){}
        if(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices){
          try{
            const list = await navigator.mediaDevices.enumerateDevices();
            const out = list.find(d=> d.kind==='audiooutput' && d.label);
            diag.setOutDev(out?.label || 'default');
            const ins = list.filter(d=> d.kind==='audioinput' && d.label);
            const preferredIn = ins.find(d=> /default|microphone/i.test(d.label)) || ins[0];
            if(preferredIn){ const el = document.querySelector("#diagInDev"); if(el) el.textContent = preferredIn.label; }
          }catch(e){}
        }
      }
    });
  }
  if(closeBtn){ closeBtn.addEventListener("click", ()=> setVisible(false)); }
  window.addEventListener("keydown", (e)=>{ if(e.key === "Escape") setVisible(false); });

  // Build analyser for Input Peak (dBFS)
  let micStream = null, analyser = null, workBuf = null;
  async function ensureAnalyser(){
    try {
      if(!AC && window.AudioContext){ AC = new AudioContext(); window.AudioContextInstance = AC; }
      if(!micStream){
        micStream = await navigator.mediaDevices.getUserMedia({audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }});
      }
      if(AC && micStream && !analyser){
        const src = AC.createMediaStreamSource(micStream);
        analyser = AC.createAnalyser();
        analyser.fftSize = 2048;
        src.connect(analyser);
        workBuf = new Float32Array(analyser.fftSize);
      }
    } catch(e){ /* if denied, we simply skip peak display */ }
  }
  function updatePeak(){
    if(!analyser || !workBuf){ return; }
    try {
      analyser.getFloatTimeDomainData(workBuf);
      let peak = 0;
      for(let i=0;i<workBuf.length;i++){
        const v = Math.abs(workBuf[i]);
        if(v > peak) peak = v;
      }
      // Convert to dBFS (approx): 20*log10(peak)
      const db = peak > 0 ? (20*Math.log10(peak)) : -Infinity;
      const txt = (db === -Infinity) ? '−∞ dBFS' : `${db.toFixed(1)} dBFS`;
      const el = $("#diagPeak"); if(el) el.textContent = txt;
      // Clipping indicator at >= -1 dBFS (~0.891)
      diag.clip(peak >= 0.891);
    } catch(e){}
  }
  // Try to keep analyser running when panel is visible
  setInterval(async ()=>{
    if(document.querySelector('#xf-mini-diag')?.style.display === 'block'){
      await ensureAnalyser();
      updatePeak();
    }
  }, 200);


  const btn = $("#xfMiniBtn"), panel = $("#xf-mini-diag"), closeBtn = $("#xfMiniClose");
  const setVisible = (on)=>{ if(panel) panel.style.display = on ? "block" : "none"; };
  if(btn && panel){
    btn.addEventListener("click", ()=>{ setVisible(panel.style.display === "none" || !panel.style.display); });
  }
  if(closeBtn){ closeBtn.addEventListener("click", ()=> setVisible(false)); }
  window.addEventListener("keydown", (e)=>{ if(e.key === "Escape") setVisible(false); });

  try {
    const li = Array.from(document.querySelectorAll("li")).find(li => li.textContent.trim().startsWith("Release:"));
    if(li){ diag.setRelease(li.textContent.trim().replace(/^Release:\s*/,"")); }
  } catch(e){}

  if(navigator.permissions && navigator.permissions.query){
    navigator.permissions.query({name:"microphone"}).then(p => {
      diag.setMicPerm(p.state);
      p.onchange = () => diag.setMicPerm(p.state);
    }).catch(()=> diag.setMicPerm("unknown"));
  } else { diag.setMicPerm("unknown"); }

  let AC = window.AudioContextInstance || null;
  try { if(!AC && window.AudioContext) { AC = new AudioContext(); window.AudioContextInstance = AC; } } catch(e){}

  let masterGain = window.masterGain || window.gainNode || null;
  if(!masterGain && AC){
    try { masterGain = AC.createGain(); masterGain.gain.value = 0.0; masterGain.connect(AC.destination); window.masterGain = masterGain; } catch(e){}
  }

  function rampTo(target, time=0.02){
    if(!masterGain || !AC) return;
    try {
      const g = masterGain.gain;
      const now = AC.currentTime;
      const cur = g.value;
      g.setValueAtTime(cur, now);
      g.linearRampToValueAtTime(target, now + time);
    } catch(e){}
  }

  const playBtn = document.querySelector('#playButton, #btnPlay, button[data-action="play"]');
  const stopBtn = document.querySelector('#stopButton, #btnStop, button[data-action="stop"]');
  if(playBtn){ playBtn.addEventListener("click", ()=>{ try{ AC && AC.resume && AC.resume(); }catch(e){} rampTo((window.uiVolumeLinear||0.5), 0.03); log("Play ramp"); }, {capture:true}); }
  if(stopBtn){ stopBtn.addEventListener("click", ()=>{ rampTo(0.0, 0.04); log("Stop ramp"); }, {capture:true}); }

  const vol = document.querySelector('#volumeSlider, input[type="range"][name="volume"], input#gain');
  if(vol){
    vol.addEventListener("input", (e)=>{
      const max = parseFloat(e.target.max || "100");
      const v = Math.min(1, Math.max(0, (parseFloat(e.target.value)||0) / (max||100)));
      window.uiVolumeLinear = v;
      rampTo(v, 0.02);
      log(`Gain -> ${v.toFixed(3)}`);
    }, {capture:true});
  }

  setInterval(()=>{
    try {
      const v = masterGain?.gain?.value || 0;
      diag.clip(v >= 0.98);
    } catch(e){}
  }, 150);

  if(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices){
    navigator.mediaDevices.enumerateDevices().then(list=>{
      const out = list.find(d=> d.kind==="audiooutput" && d.label);
      diag.setOutDev(out?.label || "default");
      const ins = list.filter(d=> d.kind==="audioinput" && d.label);
      const preferredIn = ins.find(d=> /default|microphone/i.test(d.label)) || ins[0];
      if(preferredIn){ const el = document.querySelector("#diagInDev"); if(el) el.textContent = preferredIn.label; }
    }).catch(()=>{});
  }
})();
</script>
<script>
window.toggleXfDiag = function(force){
  try {
    var p = document.getElementById('xf-mini-diag');
    if(!p) return;
    var show = (force!==undefined) ? !!force : (p.style.display === 'none' || !p.style.display);
    p.style.display = show ? 'block' : 'none';
  } catch(e){}
};
</script>























<script id="xf-diag-1352">
(function(){
  try {
    const $  = (s)=>document.querySelector(s);
    const $$ = (s)=>Array.from(document.querySelectorAll(s));

    function getVersion(){
      const meta = document.querySelector('meta[name="app:version"]');
      if (meta && meta.content) return meta.content;
      try {
        const name = (location.href.split('/').pop()||'');
        const m = name.match(/Release[-_]?(\d+(?:\.\d+){1,3})/i);
        if (m) return "Frequency " + m[1];
      } catch(e){}
      return "Frequency 1.34.51"; // fallback
    }
    function getBuild(){
      const m = document.querySelector('meta[name="app:build"]');
      return (m && m.content) ? m.content : "";
    }

    const VERSION_TEXT = getVersion();
    const BUILD_TEXT   = getBuild();

    // --- About: set "<strong>Release:</strong> Frequency x.y.z — Build: YYYY-MM-DD HH:MM"
    function applyAboutVersion(){
      try {
        const lis = $$("li");
        const target = lis.find(li => /^\s*Release\s*:/i.test(li.textContent||""));
        if (target){
          const buildPart = BUILD_TEXT ? " — Build: " + BUILD_TEXT : "";
          target.innerHTML = "<strong>Release:</strong> " + VERSION_TEXT + buildPart;
        }
      } catch(e){}
    }

    // --- Hide any "Clipping" entries in mini diagnose ---
    function purgeClippingFromPanel(root){
      try {
        root = root || document;
        ["#diagClip","#clipDot"].forEach(sel=>{ const el = root.querySelector(sel); if (el) el.style.display="none"; });
        // Heuristic: any node with text "Clipping" hide its cell/row and next value sibling
        $$("*").forEach(node=>{
          try{
            const t = (node.textContent||"").trim().toLowerCase();
            if (t === "clipping" || t === "clipping:" || t === "clip"){
              node.style.display="none";
              if (node.nextElementSibling) node.nextElementSibling.style.display="none";
              const p = node.parentElement;
              if (p && /row|kv|item/i.test(p.className||"")) p.style.display="none";
            }
          }catch(_){}
        });
      } catch(_){}
    }

    // --- Mini Diagnose with live peak while open ---
    function applyMiniDiag(){
      const panel   = $("#xf-mini-diag");
      const btn     = $("#xfMiniBtn");
      const closeBtn= $("#xfMiniClose");
      if (!btn) return;

      const diagRel = $("#diagRelease");
      if (diagRel) diagRel.textContent = VERSION_TEXT;

      // shared audio state
      let AC = window.AudioContextInstance || null;
      let micStream = null, analyser = null, workBuf = null, meterTimer = null;

      function prevent(ev){ try{ ev.preventDefault(); ev.stopImmediatePropagation(); ev.stopPropagation(); }catch(_){ } }

      async function ensureAnalyser(){
        try{
          if (!AC){
            AC = (window.AudioContext? new AudioContext() : (window.webkitAudioContext? new webkitAudioContext(): null));
            if (!AC) return false;
            window.AudioContextInstance = AC;
          }
          if (!micStream){
            try {
              micStream = await navigator.mediaDevices.getUserMedia({
                audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false },
                video:false
              });
            } catch(e){ return false; }
          }
          if (!analyser){
            const src = AC.createMediaStreamSource(micStream);
            analyser = AC.createAnalyser();
            analyser.fftSize = 2048;
            src.connect(analyser);
            workBuf = new Float32Array(analyser.fftSize);
          }
          return true;
        } catch(_){ return false; }
      }

      function startMeter(){
        const peakEl = $("#diagPeak");
        if (meterTimer) return;
        meterTimer = setInterval(()=>{
          try{
            if (!analyser || !workBuf) return;
            analyser.getFloatTimeDomainData(workBuf);
            let peak=0; for (let i=0;i<workBuf.length;i++){ const v=Math.abs(workBuf[i]); if (v>peak) peak=v; }
            const db = peak>0? 20*Math.log10(peak) : -Infinity;
            if (peakEl) peakEl.textContent = (db===-Infinity? "−∞ dBFS" : db.toFixed(1)+" dBFS");
          }catch(_){}
        }, 200);
      }

      function stopMeter(){
        if (meterTimer){ clearInterval(meterTimer); meterTimer=null; }
        try{
          if (micStream){ micStream.getTracks().forEach(t=>t.stop()); }
        }catch(_){}
        micStream = null; analyser = null; workBuf = null;
      }

      async function refreshMiniDiag(){
        try {
          // Permission
          const permEl = $("#diagMicPerm");
          if (navigator.permissions && navigator.permissions.query){
            try{
              const p = await navigator.permissions.query({name:"microphone"});
              if (permEl) permEl.textContent = p.state;
            }catch{ if (permEl) permEl.textContent = "unknown"; }
          }
          // Devices
          const outEl = $("#diagOutDev");
          const inEl  = $("#diagInDev");
          try {
            try { await navigator.mediaDevices.getUserMedia({audio:true, video:false}); } catch(_){}
            const list = await navigator.mediaDevices.enumerateDevices();
            const out = list.find(d=> d.kind==='audiooutput' && d.label);
            if (outEl) outEl.textContent = out?.label || "default";
            const ins = list.filter(d=> d.kind==='audioinput' && d.label);
            const pref = ins.find(d=> /default|microphone|mikrofon/i.test(d.label)) || ins[0];
            if (inEl && pref) inEl.textContent = pref.label;
          } catch(_){}
        } catch(_){}
      }

      btn.addEventListener("click", async function(ev){
        prevent(ev);
        const isVisible = panel && getComputedStyle(panel).display !== "none";
        const willOpen = !isVisible;
        if (panel) panel.style.display = willOpen ? "block" : "none";
        if (willOpen){
          purgeClippingFromPanel(panel);
          await refreshMiniDiag();
          if (await ensureAnalyser()) startMeter();
        } else {
          stopMeter();
        }
      }, true);

      if (closeBtn){
        closeBtn.addEventListener("click", function(ev){
          prevent(ev);
          if (panel) panel.style.display="none";
          stopMeter();
        });
      }
      window.addEventListener("keydown", (e)=>{
        if (e.key==="Escape" && panel && getComputedStyle(panel).display !== "none"){
          panel.style.display="none";
          stopMeter();
        }
      });

      // Also purge Clipping on load in case the panel is initially visible
      purgeClippingFromPanel(panel||document);
    }

    function init(){
      applyAboutVersion();
      applyMiniDiag();
    }
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
    else init();
  } catch(e){ /* noop */ }
})();
</script>











<style id="xf-playfix-css">
  .xf-dup { display: none !important; }
</style>
<script id="xf-playfix-ovl17">
(function(){
  try{
    function findPlayButton(){
      return document.getElementById('playBtn')
          || document.querySelector('#playButton, #btnPlay, button[data-action="play"]');
    }
    function getAudioEl(){
      var el = document.getElementById('audioPlayer');
      if (el) return el;
      if (!window._xfOverlayAudio){ window._xfOverlayAudio = new Audio(); }
      return window._xfOverlayAudio;
    }

    function pruneDuplicates(btn, iconEl, labelEl){
      try{
        // Hide any extra spans/i with label-like text
        var labelRegex = /(File abspielen|\[Aufnahme)|(Abspielen stoppen)/i;
        Array.from(btn.querySelectorAll('span,i')).forEach(function(el){
          if (el === iconEl || el === labelEl) return;
          if (el.querySelector && el.querySelector('svg')) return;
          var t = (el.textContent||'').trim();
          if (t && labelRegex.test(t)){
            el.classList.add('xf-dup');
            el.textContent = ''; // for good measure
          }
        });
        // Clear stray text nodes anywhere under the button except inside icon/label
        var walker = document.createTreeWalker(btn, NodeFilter.SHOW_TEXT, null, false);
        var toClear = [];
        while (walker.nextNode()){
          var n = walker.currentNode;
          if (iconEl.contains(n) || labelEl.contains(n)) continue;
          if ((n.nodeValue||'').trim().length>0) toClear.push(n);
        }
        toClear.forEach(function(n){ n.nodeValue=''; });
      }catch(_){}
    }

    function scanIcon(btn){
      var icon = btn.querySelector('.xf-icon');
      if (icon) return icon;
      var cand = Array.from(btn.querySelectorAll('span,i')).find(function(s){
        if (s.classList && s.classList.contains('xf-labeltext')) return false;
        if (s.querySelector && s.querySelector('svg')) return true;
        var t = (s.textContent||'').trim();
        return t === '▶' || t === '⏯️';
      });
      if (!cand){
        cand = document.createElement('span');
        btn.insertBefore(cand, btn.firstChild || null);
      }
      cand.classList.add('xf-icon');
      return cand;
    }

    function scanOrCreateLabel(btn){
      var lbl = btn.querySelector('.xf-labeltext');
      if (lbl) return lbl;
      var cands = Array.from(btn.querySelectorAll('span,i')).filter(function(s){
        return !(s.querySelector && s.querySelector('svg')) && !(s.classList && s.classList.contains('xf-icon'));
      });
      lbl = cands.find(function(s){
        var t = (s.textContent||'').trim();
        return /File abspielen|Abspielen stoppen/i.test(t);
      }) || cands.pop();
      if (!lbl){
        lbl = document.createElement('span');
        btn.appendChild(lbl);
      }
      lbl.classList.add('xf-labeltext');
      return lbl;
    }

    function ensureStructure(btn){
      var icon = scanIcon(btn);
      var label = scanOrCreateLabel(btn);
      if (!btn.dataset.xfIdleIconSnapshot){
        // Save EXACT idle icon outerHTML for pixel-identical restore
        btn.dataset.xfIdleIconSnapshot = icon.outerHTML;
      }
      pruneDuplicates(btn, icon, label);
      return {icon, label};
    }

    function restoreIdleIcon(btn, currentIcon){
      try{
        var snap = btn.dataset.xfIdleIconSnapshot;
        if (!snap) return currentIcon;
        // Replace current icon element with snapshot
        var tmp = document.createElement('span');
        tmp.innerHTML = snap;
        var restored = tmp.firstElementChild;
        if (!restored){ return currentIcon; }
        currentIcon.replaceWith(restored);
        restored.classList.add('xf-icon'); // mark for our selectors (no visual impact)
        return restored;
      }catch(_){ return currentIcon; }
    }

    function setPlayIcon(iconEl){
      // Use emoji ⏯️ during play; style blue (emoji ignores color in some OS, but try)
      if (!(iconEl.querySelector && iconEl.querySelector('svg'))){
        iconEl.textContent = '⏯️';
      } else {
        iconEl.innerHTML = ''; iconEl.textContent = '⏯️';
      }
      try{
        iconEl.style.color = '#3b82f6';
        iconEl.classList.add('text-blue-500','fill-blue-500');
      }catch(_){}
    }

    function urlFromAudioTags(){
      try {
        var a = document.querySelector('audio[src^="blob:"], audio source[src^="blob:"]');
        if (a){
          var src = a.getAttribute('src');
          if (!src && a.tagName.toLowerCase() === 'audio') src = a.currentSrc || a.src;
          if (src && /^blob:/.test(src)) return src;
        }
      } catch(_){}
      return null;
    }
    function hasRecording(){
      try {
        return !!(window.recordedBlobUrl || (window.recordedBlob instanceof Blob) ||
                 (Array.isArray(window.recordedChunks) && window.recordedChunks.length) ||
                 (Array.isArray(window.__xf_rec_chunks) && window.__xf_rec_chunks.length) ||
                 urlFromAudioTags());
      } catch(_){ return false; }
    }
    function chunksSig(arr){
      try{
        var n = arr.length;
        var last = arr[n-1];
        var sz = last && last.size ? last.size : 0;
        var typ = last && last.type ? last.type : '';
        return n+':'+sz+':'+typ;
      }catch(_){ return ''; }
    }
    function ensureFreshRecordedUrl(forceRebuildIfString){
      var made = false;
      try {
        if (Array.isArray(window.recordedChunks) && window.recordedChunks.length){
          var sig = chunksSig(window.recordedChunks);
          if (sig && sig !== window.__xf_last_sig_rc){
            window.__xf_last_sig_rc = sig;
            if (window.recordedBlobUrl && /^blob:/.test(window.recordedBlobUrl)) {
              try { URL.revokeObjectURL(window.recordedBlobUrl); } catch(_) {}
            }
            var b = new Blob(window.recordedChunks, {type: window.recordedChunks[0].type || 'audio/webm'});
            window.recordedBlobUrl = URL.createObjectURL(b);
            made = true;
          }
        } else if (window.recordedBlob instanceof Blob){
          var sigb = 'blob:'+(window.recordedBlob.size||0)+':'+(window.recordedBlob.type||'');
          if (sigb !== window.__xf_last_sig_rb || forceRebuildIfString){
            window.__xf_last_sig_rb = sigb;
            if (window.recordedBlobUrl && /^blob:/.test(window.recordedBlobUrl)) {
              try { URL.revokeObjectURL(window.recordedBlobUrl); } catch(_) {}
            }
            window.recordedBlobUrl = URL.createObjectURL(window.recordedBlob);
            made = true;
          }
        }
      }catch(_){}
      try {
        if (Array.isArray(window.__xf_rec_chunks) && window.__xf_rec_chunks.length){
          var sig2 = chunksSig(window.__xf_rec_chunks);
          if (sig2 && sig2 !== window.__xf_last_sig_xf){
            window.__xf_last_sig_xf = sig2;
            if (window.recordedBlobUrl && /^blob:/.test(window.recordedBlobUrl)) {
              try { URL.revokeObjectURL(window.recordedBlobUrl); } catch(_) {}
            }
            var b2 = new Blob(window.__xf_rec_chunks, {type: window.__xf_rec_chunks[0].type || 'audio/webm'});
            window.recordedBlobUrl = URL.createObjectURL(b2);
            made = true;
          }
        }
      }catch(_){}
      if (!made && (!window.recordedBlobUrl || forceRebuildIfString)){
        var domUrl = urlFromAudioTags();
        if (domUrl) { window.recordedBlobUrl = domUrl; made = true; }
      }
      if (made){
        try{ document.dispatchEvent(new CustomEvent('recorded-blob-changed')); }catch(_){}
      }
      return !!window.recordedBlobUrl;
    }

    (function hookMR(){
      try {
        if (window.__xf_mr_hooked || !window.MediaRecorder) return;
        window.__xf_mr_hooked = true;
        var NativeMR = window.MediaRecorder;
        window.MediaRecorder = function(stream, options){
          var mr = new NativeMR(stream, options);
          try{
            if (!mr.__xf_patched){
              var chunks = [];
              mr.addEventListener('dataavailable', function(e){
                try { if (e && e.data && e.data.size) chunks.push(e.data); } catch(_){}
              });
              mr.addEventListener('stop', function(){
                try {
                  window.__xf_rec_chunks = chunks.slice();
                  if (chunks.length){
                    if (window.recordedBlobUrl && /^blob:/.test(window.recordedBlobUrl)){
                      try{ URL.revokeObjectURL(window.recordedBlobUrl); }catch(_){}
                    }
                    var blob = new Blob(chunks, {type: chunks[0].type || 'audio/webm'});
                    window.recordedBlobUrl = URL.createObjectURL(blob);
                    document.dispatchEvent(new CustomEvent('recorded-blob-changed'));
                  }
                } catch(_){}
              });
              mr.__xf_patched = true;
            }
          }catch(_){}
          return mr;
        };
        window.MediaRecorder.prototype = NativeMR.prototype;
      } catch(_){}
    })();

    var countdownTimer = null;
    var onTimeUpdate = null;
    var onLoadedMeta = null;
    function clearCountdown(audioEl){
      if (countdownTimer){ try{ clearInterval(countdownTimer); }catch(_){ } countdownTimer=null; }
      try{
        if (onTimeUpdate){ audioEl.removeEventListener('timeupdate', onTimeUpdate); }
        if (onLoadedMeta){ audioEl.removeEventListener('loadedmetadata', onLoadedMeta); }
      }catch(_){}
      onTimeUpdate = onLoadedMeta = null;
    }
    function remainingSeconds(audioEl){
      var dur = audioEl && isFinite(audioEl.duration) ? audioEl.duration : 5;
      var rem = dur - (audioEl.currentTime||0);
      var n = Math.max(0, Math.ceil(rem - 1.0));
      return n;
    }

    function setup(){
      var playBtn = findPlayButton();
      var audioEl = getAudioEl();
      if (!playBtn || !audioEl) return;
      var parts = ensureStructure(playBtn);
      var iconEl = parts.icon, labelEl = parts.label;

      function setIdle(){
        try{ audioEl.pause(); }catch(_){}
        try{ audioEl.currentTime = 0; }catch(_){}
        playBtn.classList.remove('playing');
        clearCountdown(audioEl);
        iconEl = restoreIdleIcon(playBtn, iconEl); // exact original idle icon
        labelEl.textContent = hasRecording() ? 'File abspielen [Aufnahme (5 Sek)]' : 'File abspielen';
        pruneDuplicates(playBtn, iconEl, labelEl);
      }

      function startCountdown(){
        clearCountdown(audioEl);
        function update(){
          if (!playBtn.classList.contains('playing')) return;
          setPlayIcon(iconEl);
          labelEl.textContent = 'Abspielen stoppen (' + remainingSeconds(audioEl) + 's)';
          pruneDuplicates(playBtn, iconEl, labelEl);
        }
        update();
        countdownTimer = setInterval(update, 250);
        onLoadedMeta = update;
        onTimeUpdate = update;
        audioEl.addEventListener('loadedmetadata', onLoadedMeta);
        audioEl.addEventListener('timeupdate', onTimeUpdate);
      }

      async function start(){
        ensureFreshRecordedUrl(false);
        if (!window.recordedBlobUrl) return false;
        async function doPlay(){
          audioEl.pause();
          audioEl.src = '';
          audioEl.load();
          audioEl.src = window.recordedBlobUrl;
          audioEl.currentTime = 0;
          await audioEl.play();
        }
        try{
          await doPlay();
        }catch(e1){
          try{
            ensureFreshRecordedUrl(true);
            if (!window.recordedBlobUrl) throw e1;
            await doPlay();
          }catch(e2){
            setIdle();
            return true;
          }
        }
        playBtn.classList.add('playing');
        startCountdown();
        return true;
      }

      function stopNow(){ setIdle(); return true; }

      setIdle();

      playBtn.addEventListener('click', function(ev){
        try{
          ev.preventDefault(); ev.stopImmediatePropagation(); ev.stopPropagation();
          var wantsStop = playBtn.classList.contains('playing');
          if (wantsStop){ stopNow(); } else { start(); }
        }catch(_){}
      }, true);

      // Observer to keep things tidy & icon identical after DOM mutations
      try{
        var mo = new MutationObserver(function(){
          var parts2 = ensureStructure(playBtn);
          iconEl = parts2.icon; labelEl = parts2.label;
          pruneDuplicates(playBtn, iconEl, labelEl);
        });
        mo.observe(playBtn, {childList:true, subtree:true, characterData:true, attributes:true});
      }catch(_){}

      audioEl.addEventListener('ended', function(){ setIdle(); });
      document.addEventListener('recorded-blob-changed', function(){ setIdle(); });
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', setup);
    } else { setup(); }
  }catch(e){ /* noop */ }
})();
</script>

<script id="xf-ovl19">
(function(){
  try{
    var playBtn = document.getElementById('playBtn');
    var recordBtn = document.getElementById('recordBtn');
    var audio = document.getElementById('audioPlayer') || window._xfOverlayAudio || null;
    if (!playBtn || !recordBtn) return;

    
    function hardStopPlayback(){
      try{
        // pause known audio handles
        var list = Array.prototype.slice.call(document.querySelectorAll('audio'));
        for (var i=0;i<list.length;i++){
          try{ list[i].pause(); }catch(_){}
          try{ list[i].currentTime = 0; }catch(_){}
          try{ list[i].src = ''; list[i].load(); }catch(_){}
        }
        // also try the known overlay audio handle
        if (window._xfOverlayAudio){
          try{ window._xfOverlayAudio.pause(); window._xfOverlayAudio.currentTime = 0; window._xfOverlayAudio.src=''; window._xfOverlayAudio.load(); }catch(_){}
        }
        // Best-effort: dispatch an app-level hint
        try{ document.dispatchEvent(new CustomEvent('xf-force-stop-playback')); }catch(_){}
      }catch(_){}
    }
var reLabel = /(File abspielen|Abspielen stoppen|\[Aufnahme|\(5\s*Sek)/i;

    function qIcon(){
      var ic = playBtn.querySelector('.xf-icon');
      if (!ic){
        ic = document.createElement('span');
        ic.className = 'xf-icon text-blue-600 fill-blue-600';
        var label = playBtn.querySelector('.xf-labeltext');
        if (label){ playBtn.insertBefore(ic, label); }
        else { playBtn.insertBefore(ic, playBtn.firstChild || null); }
      }
      return ic;
    }
    function qLabel(){
      var lb = playBtn.querySelector('.xf-labeltext');
      if (!lb){
        // pick first non-svg span/i
        var cands = playBtn.querySelectorAll('span,i');
        for (var i=0;i<cands.length;i++){
          var el = cands[i];
          if (el.classList && el.classList.contains('xf-icon')) continue;
          if (el.querySelector && el.querySelector('svg')) continue;
          lb = el; break;
        }
        if (!lb){ lb = document.createElement('span'); playBtn.appendChild(lb); }
        lb.classList.add('xf-labeltext');
      }
      return lb;
    }
    function setBluePlayIcon(ic){
      if(!ic) return;
      ic.innerHTML='';
      ic.textContent='▶';
      ic.style.color='#1d4ed8'; // blue-700
      if (ic.classList){ ic.classList.add('text-blue-600','fill-blue-600'); }
    }
    function isPlaying(){ return playBtn.classList && playBtn.classList.contains('playing'); }

    function cleanPlayButton(){
      var ic = qIcon();
      var lb = qLabel();
      // Ensure icon contains only symbol, not label text
      var t = (ic.textContent||'').trim();
      if (reLabel.test(t) || t.length>2){ setBluePlayIcon(ic); }
      if (!ic.textContent || !ic.textContent.trim()){ setBluePlayIcon(ic); }

      // Remove duplicate label-like spans
      var nodes = playBtn.querySelectorAll('span,i');
      for (var i=0;i<nodes.length;i++){
        var el = nodes[i];
        if (el===ic || el===lb) continue;
        if (el.querySelector && el.querySelector('svg')) continue;
        var txt = (el.textContent||'').trim();
        if (txt && (txt===(lb.textContent||'').trim() || reLabel.test(txt))){
          el.textContent=''; el.classList.add('xf-dup');
        }
      }
      // Clear root text nodes
      var kids = playBtn.childNodes;
      for (var k=0;k<kids.length;k++){
        var n = kids[k];
        if (n.nodeType===3 && (n.nodeValue||'').trim().length>0){ n.nodeValue=''; }
      }
    }

    function setPlayView1(){
      var ic = qIcon(), lb = qLabel();
      setBluePlayIcon(ic);
      lb.textContent = 'File abspielen';
      playBtn.classList.remove('playing');
      if (audio){ try{ audio.pause(); audio.currentTime = 0; }catch(_){ } }
      cleanPlayButton();
    }
    function setPlayView2(){
      var ic = qIcon(), lb = qLabel();
      setBluePlayIcon(ic);
      lb.textContent = 'File abspielen [Aufnahme (5 Sek)]';
      playBtn.classList.remove('playing');
      cleanPlayButton();
    }

    // Initial cleanup
    setTimeout(cleanPlayButton, 0);

    // --- Exception A --- (immediate View 1 on record start)
    ['mousedown','touchstart','keydown','click'].forEach(function(evt){
      recordBtn.addEventListener(evt, function(){ setPlayView1(); }, true);
    });

    // When recording ends -> View 2 (poll for .recording toggle)
    var lastRec = recordBtn.classList.contains('recording');
    setInterval(function(){
      var now = recordBtn.classList.contains('recording');
      if (lastRec && !now){ setPlayView2(); }
      lastRec = now;
    }, 200);

    // --- Exception B --- (stop playback first if recording during play)
    ['click','keydown','touchstart','mousedown'].forEach(function(evt){
      recordBtn.addEventListener(evt, function(){
        if (isPlaying()){ hardStopPlayback(); setPlayView1(); }
      }, true);
    });

    // Keep tidy if app mutates the button
    try{
      var deb=null;
      var mo = new MutationObserver(function(){
        if (deb) return;
        deb = setTimeout(function(){ deb=null; cleanPlayButton(); }, 60);
      });
      mo.observe(playBtn, {childList:true, subtree:true, characterData:true});
    }catch(_){}

    // Also tidy after blob change (new recording)
    document.addEventListener('recorded-blob-changed', function(){ setPlayView2(); });

    // Safety: on window focus
    window.addEventListener('focus', cleanPlayButton);

  }catch(e){ /* noop */ }
})();
</script>

<script id="xf-ovl21">
(function(){
  try{
    // Collect AudioContexts (new + future)
    if (!window.__xf_audioContexts) window.__xf_audioContexts = [];
    function _registerCtx(ctx){
      try{
        if (ctx && window.__xf_audioContexts.indexOf(ctx) === -1){
          window.__xf_audioContexts.push(ctx);
        }
      }catch(_){}
      return ctx;
    }
    try{
      if (!window.__xf_ac_hooked && (window.AudioContext || window.webkitAudioContext)){
        window.__xf_ac_hooked = true;
        var NativeAC = window.AudioContext;
        if (NativeAC){
          var AC = function(){
            var ctx = new (Function.prototype.bind.apply(NativeAC, [null].concat([].slice.call(arguments))))();
            return _registerCtx(ctx);
          };
          AC.prototype = NativeAC.prototype;
          window.AudioContext = AC;
        }
        var NativeWAC = window.webkitAudioContext;
        if (NativeWAC){
          var WAC = function(){
            var ctx = new (Function.prototype.bind.apply(NativeWAC, [null].concat([].slice.call(arguments))))();
            return _registerCtx(ctx);
          };
          WAC.prototype = NativeWAC.prototype;
          window.webkitAudioContext = WAC;
        }
      }
    }catch(_){}

    // Provide global stop/mute helpers
    window.__xf_suspendAllContexts = function(){
      try{
        (window.__xf_audioContexts||[]).forEach(function(ctx){
          try{
            if (ctx && typeof ctx.state === 'string' && ctx.state === 'running'){
              ctx.__xf_was_running = true;
              ctx.suspend();
            }
          }catch(_){}
        });
      }catch(_){}
    };
    window.__xf_resumeSuspendedContexts = function(){
      try{
        (window.__xf_audioContexts||[]).forEach(function(ctx){
          try{
            if (ctx && ctx.__xf_was_running && ctx.state !== 'closed'){
              ctx.resume();
            }
            if (ctx) ctx.__xf_was_running = false;
          }catch(_){}
        });
      }catch(_){}
    };

    // Wire into existing handlers: record start/stop
    var recordBtn = document.getElementById('recordBtn');
    if (recordBtn){
      ['click','mousedown','touchstart','keydown'].forEach(function(evt){
        recordBtn.addEventListener(evt, function(){
          // stop any <audio> and suspend all contexts immediately
          try {
            var list = Array.prototype.slice.call(document.querySelectorAll('audio'));
            for (var i=0;i<list.length;i++){ try{ list[i].pause(); }catch(_){}
              try{ list[i].currentTime=0; }catch(_){}
              try{ list[i].src=''; list[i].load(); }catch(_){}
            }
          }catch(_){}
          if (window._xfOverlayAudio){
            try{ _xfOverlayAudio.pause(); _xfOverlayAudio.currentTime=0; _xfOverlayAudio.src=''; _xfOverlayAudio.load(); }catch(_){}
          }
          window.__xf_suspendAllContexts();
        }, true);
      });

      // Poll for recording end to resume contexts
      var lastRec = recordBtn.classList.contains('recording');
      setInterval(function(){
        var now = recordBtn.classList.contains('recording');
        if (lastRec && !now){
          // recording ended
          window.__xf_resumeSuspendedContexts();
        }
        lastRec = now;
      }, 200);
    }
  }catch(e){ /* noop */ }
})();
</script>



<script id="xf-speech-label-color">
(function(){
  try{
    function tint(){
      var root = document.getElementById('speechFrequencyTestContainer');
      if (!root) return; // do nothing if container not found
      var label = root.querySelector('label');
      if (!label) return;
      // apply Tailwind class; do not touch text or structure
      try{ label.classList.add('text-blue-600'); }catch(_){}
    }
    if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', tint); } else { tint(); }
  }catch(e){ /* noop */ }
})();
</script>

<script id="xf-version-autodetect">
(function(){
  try{
    function detectVersion(){
      try{
        var m = (location.pathname || '').match(/Release-(\d+\.\d+\.\d+)/);
        if (m && m[1]) return m[1];
      }catch(e){}
      try{
        var meta = document.querySelector('meta[name="app:version"]');
        if (meta){
          var c = meta.getAttribute('content') || '';
          var m2 = c.match(/(\d+\.\d+\.\d+)/);
          if (m2 && m2[1]) return m2[1];
        }
      }catch(e){}
      try{
        var m3 = (document.title || '').match(/Release-(\d+\.\d+\.\d+)/);
        if (m3 && m3[1]) return m3[1];
      }catch(e){}
      return null;
    }

    function applyVersion(ver){
      if (!ver) return;
      var text = 'Frequency ' + ver;
      try{ window.VERSION_TEXT = text; }catch(e){}
      try{
        var meta = document.querySelector('meta[name="app:version"]');
        if (meta){ meta.setAttribute('content', text); }
      }catch(e){}
      try{
        var scope = document.getElementById('aboutAppContent') || document;
        var candidates = scope.querySelectorAll('li, p, div, span');
        for (var i=0;i<candidates.length;i++){
          var n = candidates[i];
          var t = n.textContent || '';
          if (/^\s*Release:\s*/i.test(t)){
            n.innerHTML = n.innerHTML.replace(/Frequency\s*\d+\.\d+\.\d+/, text);
            break;
          }
        }
      }catch(e){}
    }

    function init(){
      var ver = detectVersion();
      applyVersion(ver);
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
    window.addEventListener('load', init);
  }catch(e){}
})();
</script>
</body>
</html>
